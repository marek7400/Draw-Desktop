import sys
import os
import json
import ctypes
import platform
from copy import deepcopy
import math
import traceback
import time  # [1]
import functools
import re
import uuid
import subprocess
import qdarkstyle
from typing import Optional, List, Tuple

_GLOBAL_LINE_NUMBER = 0


def _gln():
    global _GLOBAL_LINE_NUMBER
    _GLOBAL_LINE_NUMBER += 1  # [2]
    return f"# [{_GLOBAL_LINE_NUMBER}]"


_PYAUTOGUI_AVAILABLE = False
try:
    import pyautogui

    _PYAUTOGUI_AVAILABLE = True
    print(
        "PyAutoGUI module found. Magnifier hotkey control for closing will be available."
    )
except ImportError:
    print(
        "WARNING: PyAutoGUI module not found. Magnifier closing via hotkey will be DISABLED."
    )  # [3]
    print(
        "To enable Magnifier closing via hotkey, please install pyautogui: pip install pyautogui"
    )

_QDARKSTYLE_AVAILABLE = False  # [4]
try:  # [5]
    import qdarkstyle  # [6]

    _QDARKSTYLE_AVAILABLE = True  # [7]
    print("qdarkstyle module found. Dark mode will be available.")  # [8]
except ImportError:  # [9]
    print("WARNING: qdarkstyle module not found. Dark mode will be DISABLED.")  # [10]
    print(
        "To enable Dark mode, please install qdarkstyle: pip install qdarkstyle"
    )  # [11]

    # Create an empty placeholder class to avoid NameError if qdarkstyle is not available # [12]
    class qdarkstyle:  # [13]
        @staticmethod  # [14]
        def load_stylesheet(qt_api):  # [15]
            print(
                "qdarkstyle.load_stylesheet called but module not available. Returning empty stylesheet."
            )  # [16]
            return ""  # [17]


_QT_PRINT_SUPPORT_AVAILABLE = False

try:
    from PySide6.QtPrintSupport import QPrinter, QPrintDialog

    _QT_PRINT_SUPPORT_AVAILABLE = True
    print("QtPrintSupport found.")
except ImportError:  # [18]
    print(
        "WARNING: QtPrintSupport module not found. Printing functionality will be disabled."
    )

    class QPrinter:
        pass

    class QPrintDialog:
        pass


_PSUTIL_AVAILABLE = False
try:
    import psutil

    _PSUTIL_AVAILABLE = True
    print("psutil module found. Process killing will be available.")
except ImportError:
    print("WARNING: psutil module not found. Process killing will be DISABLED.")
    print("To enable process killing, please install psutil: pip install psutil")

from PySide6.QtWidgets import (
    QApplication,
    QWidget,
    QPushButton,
    QVBoxLayout,
    QLabel,
    QColorDialog,
    QSlider,
    QRadioButton,
    QButtonGroup,
    QFileDialog,
    QDialog,
    QTextEdit,
    QFontComboBox,
    QSpinBox,
    QComboBox,
    QCheckBox,
    QHBoxLayout,
    QDockWidget,  # [19]
    QFrame,
    QSizePolicy,
    QMessageBox,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QStyle,
    QDialogButtonBox,
    QDoubleSpinBox,
    QLineEdit,
    QGridLayout,
    QFormLayout,
    QListWidget,
    QListWidgetItem,
    QGroupBox,
    QMainWindow,
)
from PySide6.QtGui import (
    QPainter,
    QPen,
    QBrush,
    QColor,
    QPolygonF,
    QGuiApplication,
    QFont,
    QTransform,
    QCursor,
    QPixmap,
    QFontMetrics,
    QPalette,
    QKeyEvent,
    QTextDocument,
    QPainterPath,
    QMouseEvent,
    QLinearGradient,
    QRadialGradient,
    QConicalGradient,
    QCloseEvent,
)
from PySide6.QtCore import (
    Qt,
    QPointF,
    QRectF,
    QSizeF,
    QTimer,
    Signal,
    Slot,
    QEvent,
    QRect,
    QSettings,
    QPoint,
    QAbstractNativeEventFilter,
    QStandardPaths,
    QSize,
    QObject,
    QThread,  # Added for LinesApp.get_id_glownego_watku
)  # [22]

# Globals to hold instances of Grid and Lines apps/widgets
grid_overlay_instance = None
grid_settings_window_instance = None
lines_app_instance = None
lines_settings_dialog_instance = None

# --- INTEGRATED Grid_DesktopEN.py (Converted to PySide6) ---

# --- Keyboard import (from Grid_DesktopEN.py) --- # [23]
_GRID_HAS_KEYBOARD_LIB = False
try:
    import keyboard as grid_keyboard_module  # Use an alias to avoid conflict

    _GRID_HAS_KEYBOARD_LIB = True
except ImportError:
    _GRID_HAS_KEYBOARD_LIB = False
except Exception:
    _GRID_HAS_KEYBOARD_LIB = False

# --- Translation Data (from Grid_DesktopEN.py, namespaced) --- # [24]
grid_translations = {
    "ENG": {
        "warning_keyboard_lib": "GRID WARNING: Library 'keyboard' not installed. Grid's original global shortcuts might not work if re-enabled.",
        "error_import_keyboard": "GRID WARNING: Error importing 'keyboard': {e}",
        "info_qtwin_removed": "GRID INFO: Windows taskbar integration (thumbnail buttons) has been removed in the PySide6 version.",
        "info_linux_sudo": "GRID INFO: On Linux, grid's original global shortcuts might require 'sudo' privileges if re-enabled.",
        "settings_window_title": "Grid Settings",
        "show_grid_checkbox": "Show Grid",  # Shortcut removed, will be in tooltip
        "grid_mode_label": "Grid Mode:",  # [25]
        "mode_sections": "Division by Number of Sections",
        "mode_cell_size": "Division by Cell Size (px)",
        "sections_group_title": "Settings for Division by COUNT",
        "rows_group_title": "Rows (Horizontal Lines) [Ctrl+Alt+Left/Right]",
        "count_label": "Count:",
        "color_label": "Color:",
        "opacity_label": "Opacity:",
        "thickness_label": "Thickness:",
        "cols_group_title": "Columns (Vertical Lines) [Ctrl+Alt+Up/Down]",  # [26]
        "preset_group_title": "Quick Count Selection",
        "columns_label": "Columns:",
        "rows_label": "Rows:",
        "apply_button": "Apply",
        "cellsize_group_title": "Settings for Division by CELL SIZE",
        "cell_dims_group_title": "Cell Size (px)",
        "width_label": "Width:",
        "height_label": "Height:",
        "cell_h_style_group_title": "Horizontal Line Style (Rows)",  # [27]
        "cell_v_style_group_title": "Vertical Line Style (Columns)",
        "offset_group_title": "Grid Start Position (Offset) [Ctrl+Alt+. , [ ] F11]",
        "offset_x_label": "X:",
        "offset_y_label": "Y:",
        "reset_offset_button": "Reset Offset to 0,0 (Ctrl+Alt+F11)",
        "dots_group_title": "Dots in Section/Cell Centers (Common)",
        "show_dots_checkbox": "Show Dots (Ctrl+Alt+F12)",
        "hide_dots": "Hide Dots",
        "dot_size_label": "Size (Diameter):",  # [28]
        "choose_color_sections_h": "Choose Color (Sections - Horizontal)",
        "choose_color_sections_v": "Choose Color (Sections - Vertical)",
        "choose_color_cells_h": "Choose Color (Cells - Horizontal)",
        "choose_color_cells_v": "Choose Color (Cells - Vertical)",
        "choose_color_dots": "Choose Color (Dots)",
        "info_preset_sections_only": "Info: 'Apply' in quick selection only works in 'Division by Number of Sections' mode.",
        "resetting_offset": "GRID: Resetting offset to 0,0",
        "saving_settings_exit": "GRID: Saving settings on exit...",
        "settings_saved": "GRID: Settings saved.",  # [29]
        "loading_settings": "GRID: Loading settings...",
        "app_quit_code": "GRID: Application finished with code: {exit_code}",
        "tray_show_grid": "Show Grid (Ctrl+Alt+F10)",
        "tray_settings": "Grid Settings",
        "tray_exit": "Exit Grid (managed by main app)",
        "shortcuts_registered": "GRID: Original global hotkeys registered (if keyboard lib active).",
        "shortcuts_fail": "GRID WARNING: Failed to register original global hotkeys: {e}",
        "shortcuts_warn_no_lib": "GRID WARNING: 'keyboard' library not available, original global hotkeys disabled.",
        "clearing_shortcuts": "GRID: Clearing original global hotkeys...",  # [30]
        "shortcuts_cleared": "GRID: Original hotkeys removed.",
        "shortcuts_clear_fail": "GRID: Error removing original hotkeys: {e}",
        "shortcut_inc_cols": "GRID Shortcut: Increase Columns (Sections) to {new_val}",
        "shortcut_dec_cols": "GRID Shortcut: Decrease Columns (Sections) to {new_val}",
        "shortcut_inc_rows": "GRID Shortcut: Increase Rows (Sections) to {new_val}",
        "shortcut_dec_rows": "GRID Shortcut: Decrease Rows (Sections) to {new_val}",
        "shortcut_inc_x": "GRID Shortcut: Increase X Offset to {new_val}",
        "shortcut_dec_x": "GRID Shortcut: Decrease X Offset to {new_val}",
        "shortcut_inc_y": "GRID Shortcut: Increase Y Offset to {new_val}",  # [31]
        "shortcut_dec_y": "GRID Shortcut: Decrease Y Offset to {new_val}",
        "shortcut_ignored_mode": "GRID Shortcut ignored: Change only works in 'Sections' mode.",
        "shortcut_reset_offset": "GRID Shortcut: Reset Offset to 0,0",
        "shortcut_toggle_dots": "GRID Shortcut: Toggle Dots (New state: {state})",
        "switch_mode_log": "GRID: Switched grid mode to: {mode_name}",
    }
}
grid_current_lang = "ENG"


def grid_tr(key, **kwargs):  # [32]
    """Translates a key using the current language (fixed to English) for Grid."""
    lang_dict = grid_translations["ENG"]
    base_string = lang_dict.get(key, key)
    try:
        return base_string.format(**kwargs)
    except KeyError as e:
        print(
            f"Warning: Missing format key '{e}' for translation key '{key}' in lang '{grid_current_lang}'"
        )  # [33]
        return base_string


class GridOverlay(QWidget):
    MODE_SECTIONS = 0
    MODE_CELL_SIZE = 1

    def __init__(self, parent=None):
        super(GridOverlay, self).__init__(parent)
        self.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.setAttribute(Qt.WA_TranslucentBackground)  # [34]
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)

        # Default values
        self.grid_mode = GridOverlay.MODE_SECTIONS
        self.visible = True
        self.offset_x = 0  # [35]
        self.offset_y = 0
        self.horizontal_sections = 11
        self.vertical_sections = 11
        self.horizontal_color = QColor(0, 120, 215, 128)
        self.vertical_color = QColor(0, 120, 215, 128)
        self.horizontal_width = 1
        self.vertical_width = 1
        self.cell_width = 50
        self.cell_height = 50  # [36]
        self.cell_horizontal_color = QColor(215, 120, 0, 128)
        self.cell_vertical_color = QColor(215, 120, 0, 128)
        self.cell_horizontal_width = 1
        self.cell_vertical_width = 1
        self.show_dots = False
        self.dot_size = 4
        self.dot_color = QColor(0, 255, 0, 192)

        # Make it cover the whole screen initially
        self.update_geometry_to_screen()  # [37]

        app_instance = QApplication.instance()
        if app_instance:
            app_instance.primaryScreenChanged.connect(self.update_geometry_to_screen)
        else:
            # This should not happen if GridOverlay is created after MainApplication
            print(
                "WARNING: QApplication.instance() is None during GridOverlay init for primaryScreenChanged."
            )

        # This might be too aggressive if there are many screens or frequent changes. # [38]
        # Consider connecting only to primaryScreen().geometryChanged()
        for screen in QGuiApplication.screens():
            screen.geometryChanged.connect(self.update_geometry_to_screen)

    def update_geometry_to_screen(self):
        # This method ensures the overlay covers the entire virtual desktop or primary screen
        screen_geometry = QGuiApplication.primaryScreen().virtualGeometry()
        if not screen_geometry.isValid():
            screen_geometry = QGuiApplication.primaryScreen().geometry()  # [39]
        self.setGeometry(screen_geometry)
        self.update()

    def paintEvent(self, event):
        if not self.visible:
            return
        painter = QPainter(self)
        h_width = (  # [40]
            self.horizontal_width
            if self.grid_mode == self.MODE_SECTIONS
            else self.cell_horizontal_width
        )
        v_width = (
            self.vertical_width
            if self.grid_mode == self.MODE_SECTIONS
            else self.cell_vertical_width
        )  # [41]
        painter.setRenderHint(QPainter.Antialiasing, h_width > 1 or v_width > 1)
        painter.save()
        painter.translate(float(self.offset_x), float(self.offset_y))
        draw_width = self.width()
        draw_height = self.height()
        if self.grid_mode == GridOverlay.MODE_SECTIONS:
            self._paint_by_sections(painter, draw_width, draw_height)
        elif self.grid_mode == GridOverlay.MODE_CELL_SIZE:  # [42]
            self._paint_by_cell_size(painter, draw_width, draw_height)
        if self.show_dots:
            self._paint_dots(painter, draw_width, draw_height)
        painter.restore()

    def _paint_by_sections(self, painter, w, h):
        if self.horizontal_sections <= 0 or self.vertical_sections <= 0:
            return
        horizontal_spacing = (  # [43]
            float(w) / self.vertical_sections if self.vertical_sections else 0
        )
        vertical_spacing = (
            float(h) / self.horizontal_sections if self.horizontal_sections else 0
        )
        num_horizontal_lines = max(0, self.horizontal_sections - 1)
        num_vertical_lines = max(0, self.vertical_sections - 1)
        if num_horizontal_lines > 0:
            pen = QPen(self.horizontal_color)  # [44]
            pen.setWidth(self.horizontal_width)
            painter.setPen(pen)
            for i in range(1, num_horizontal_lines + 1):
                y = int(i * vertical_spacing)
                painter.drawLine(0, y, w, y)
        if num_vertical_lines > 0:
            pen = QPen(self.vertical_color)
            pen.setWidth(self.vertical_width)
            painter.setPen(pen)  # [45]
            for i in range(1, num_vertical_lines + 1):
                x = int(i * horizontal_spacing)
                painter.drawLine(x, 0, x, h)

    def _paint_by_cell_size(self, painter, w, h):
        if self.cell_width <= 0 or self.cell_height <= 0:
            return
        start_y_limit = -self.offset_y
        start_x_limit = -self.offset_x  # [46]

        # Draw horizontal lines
        if self.cell_height > 0:
            pen = QPen(self.cell_horizontal_color)
            pen.setWidth(self.cell_horizontal_width)
            painter.setPen(pen)
            first_y_index = math.floor(start_y_limit / self.cell_height)
            y = float(first_y_index * self.cell_height)
            while y < h - self.offset_y:  # [47]
                iy = int(y)
                painter.drawLine(0, iy, w, iy)
                y += self.cell_height

        # Draw vertical lines
        if self.cell_width > 0:
            pen = QPen(self.cell_vertical_color)
            pen.setWidth(self.cell_vertical_width)
            painter.setPen(pen)  # [48]
            first_x_index = math.floor(start_x_limit / self.cell_width)
            x = float(first_x_index * self.cell_width)
            while x < w - self.offset_x:
                ix = int(x)
                painter.drawLine(ix, 0, ix, h)
                x += self.cell_width

    def _paint_dots(self, painter, w, h):
        painter.setPen(Qt.NoPen)  # [49]
        painter.setBrush(self.dot_color)
        half_dot = self.dot_size / 2.0
        if self.grid_mode == GridOverlay.MODE_SECTIONS:
            if self.horizontal_sections <= 0 or self.vertical_sections <= 0:
                return
            horizontal_spacing = (
                float(w) / self.vertical_sections if self.vertical_sections else 0
            )
            vertical_spacing = (  # [50]
                float(h) / self.horizontal_sections if self.horizontal_sections else 0
            )
            for row_idx in range(self.horizontal_sections):
                for col_idx in range(self.vertical_sections):
                    x = (col_idx + 0.5) * horizontal_spacing
                    y = (row_idx + 0.5) * vertical_spacing
                    painter.drawEllipse(QPointF(x, y), half_dot, half_dot)
        elif self.grid_mode == GridOverlay.MODE_CELL_SIZE:
            if self.cell_width <= 0 or self.cell_height <= 0:  # [51]
                return
            start_y_limit = -self.offset_y
            start_x_limit = -self.offset_x
            first_y_index = (
                math.floor(start_y_limit / self.cell_height) if self.cell_height else 0
            )
            first_x_index = (  # [52]
                math.floor(start_x_limit / self.cell_width) if self.cell_width else 0
            )
            first_center_y = (first_y_index + 0.5) * self.cell_height
            first_center_x = (first_x_index + 0.5) * self.cell_width
            y = first_center_y
            while y < h - self.offset_y:
                x = first_center_x
                while x < w - self.offset_x:
                    painter.drawEllipse(QPointF(x, y), half_dot, half_dot)
                    if self.cell_width <= 0:  # [53]
                        break
                    x += self.cell_width
                if self.cell_height <= 0:
                    break
                y += self.cell_height
                if y == first_center_y and self.cell_height > 0:
                    break

    def get_visible_grid_lines(self) -> Tuple[List[int], List[int]]:  # [54]
        """
        Returns lists of Y coordinates for horizontal lines and X coordinates for vertical lines
        that are currently visible and drawn on the screen, considering the offset.
        Coordinates are relative to the GridOverlay widget (i.e., after translation by offset).
        """
        if not self.visible:
            return [], []

        h_lines_y_coords = []  # [55]
        v_lines_x_coords = []

        # Widget coordinates
        widget_width = self.width()
        widget_height = self.height()

        if self.grid_mode == GridOverlay.MODE_SECTIONS:
            if self.horizontal_sections > 0 and self.vertical_sections > 0:
                # Spacing is calculated on the full width/height because lines are drawn # [56]
                # after translation by offset.
                horizontal_spacing = float(widget_width) / self.vertical_sections
                vertical_spacing = float(widget_height) / self.horizontal_sections

                num_h_grid_lines = max(0, self.horizontal_sections - 1)
                for i in range(1, num_h_grid_lines + 1):
                    # y_on_translated_plane is the Y position in the coordinate system *after* translation by offset_y
                    y_on_translated_plane = int(i * vertical_spacing)
                    h_lines_y_coords.append(
                        y_on_translated_plane + self.offset_y
                    )  # [57]

                num_v_grid_lines = max(0, self.vertical_sections - 1)
                for i in range(1, num_v_grid_lines + 1):
                    x_on_translated_plane = int(i * horizontal_spacing)
                    v_lines_x_coords.append(x_on_translated_plane + self.offset_x)

        elif self.grid_mode == GridOverlay.MODE_CELL_SIZE:
            if self.cell_width > 0 and self.cell_height > 0:  # [58]
                # Horizontal lines
                # start_y_limit_unoffset is the "virtual" start before applying offset_y
                start_y_limit_unoffset = -self.offset_y
                first_y_index_unoffset = math.floor(
                    start_y_limit_unoffset / self.cell_height
                )

                y_unoffset = float(first_y_index_unoffset * self.cell_height)

                # Iterate as long as the line (in the pre-offset system) is within the widget's range
                while y_unoffset < widget_height - self.offset_y:  # [59]
                    # Actual Y position on the GridOverlay widget (after translation)
                    actual_y_on_widget = int(y_unoffset + self.offset_y)
                    if 0 <= actual_y_on_widget <= widget_height:
                        h_lines_y_coords.append(actual_y_on_widget)
                    y_unoffset += self.cell_height

                # Vertical lines
                start_x_limit_unoffset = -self.offset_x
                first_x_index_unoffset = math.floor(
                    start_x_limit_unoffset / self.cell_width
                )  # [60]
                x_unoffset = float(first_x_index_unoffset * self.cell_width)

                while x_unoffset < widget_width - self.offset_x:
                    actual_x_on_widget = int(x_unoffset + self.offset_x)
                    if 0 <= actual_x_on_widget <= widget_width:
                        v_lines_x_coords.append(actual_x_on_widget)
                    x_unoffset += self.cell_width

        return sorted(list(set(h_lines_y_coords))), sorted(
            list(set(v_lines_x_coords))
        )  # [61]


class GridSettingsWindow(QMainWindow):
    # Signal to notify when visibility changes, so ControlPanel can update its checkbox
    grid_visibility_changed_signal = Signal(bool)

    def __init__(self, grid_overlay_widget):
        super(GridSettingsWindow, self).__init__()
        self.grid_overlay = grid_overlay_widget
        self.settings = QSettings("GridToolIntegrated", "ConfigurableGrid")  # [62]
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        self._loading_settings = False
        self.initUI()
        self.loadSettings()


    def closeEvent(self, event: QCloseEvent):
        """Intercepts the window close event to only hide it and save settings."""
        print("GridSettingsWindow closeEvent: Saving settings and hiding window.")
        self.saveSettings()
        self.hide()
        # Używamy event.ignore(), aby kliknięcie "X" tylko ukrywało okno.
        # Rzeczywiste zamknięcie i zniszczenie okna jest zarządzane przez
        # MainApplication podczas procesu zamykania całej aplikacji.
        event.ignore()

    def initUI(self):
        self.setMinimumWidth(470)
        self.central_widget = QWidget()  # [64]
        self.setCentralWidget(self.central_widget)
        main_layout = QVBoxLayout(self.central_widget)

        # Visibility
        self.grid_checkbox = QCheckBox()
        self.grid_checkbox.setChecked(self.grid_overlay.visible)
        self.grid_checkbox.stateChanged.connect(self.toggleGrid)
        main_layout.addWidget(self.grid_checkbox)

        # Mode # [65]
        mode_layout = QHBoxLayout()
        self.mode_label = QLabel()
        mode_layout.addWidget(self.mode_label)
        self.mode_combobox = QComboBox()
        self.mode_combobox.currentIndexChanged.connect(self._update_mode_ui)
        mode_layout.addWidget(self.mode_combobox)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Sections Group # [66]
        self.sections_group = QGroupBox()
        sections_layout = QVBoxLayout()
        self.horizontal_group = QGroupBox()
        horizontal_layout = QVBoxLayout()
        h_count_layout = QHBoxLayout()
        self.h_count_label = QLabel()
        h_count_layout.addWidget(self.h_count_label)
        self.h_slider = QSlider(Qt.Horizontal)
        self.h_slider.setRange(1, 100)  # [67]
        self.h_slider.valueChanged.connect(self.updateHorizontalSections)
        h_count_layout.addWidget(self.h_slider)
        self.h_value = QSpinBox()
        self.h_value.setRange(1, 10000)
        self.h_value.valueChanged.connect(self.updateHorizontalSectionsValue)
        h_count_layout.addWidget(self.h_value)
        horizontal_layout.addLayout(h_count_layout)
        h_color_layout = QHBoxLayout()
        self.h_color_label = QLabel()  # [68]
        h_color_layout.addWidget(self.h_color_label)
        self.h_color_button = QPushButton()
        self.h_color_button.setMinimumSize(QSize(40, 20))
        self.h_color_button.clicked.connect(self.chooseHorizontalColor)
        h_color_layout.addWidget(self.h_color_button)
        self.h_opacity_label = QLabel()
        h_color_layout.addWidget(self.h_opacity_label)
        self.h_opacity_slider = QSlider(Qt.Horizontal)
        self.h_opacity_slider.setRange(0, 255)  # [69]
        self.h_opacity_slider.valueChanged.connect(self.updateHorizontalOpacity)
        h_color_layout.addWidget(self.h_opacity_slider)
        horizontal_layout.addLayout(h_color_layout)
        h_width_layout = QHBoxLayout()
        self.h_width_label = QLabel()
        h_width_layout.addWidget(self.h_width_label)
        self.h_width_slider = QSlider(Qt.Horizontal)
        self.h_width_slider.setRange(1, 10)
        self.h_width_slider.valueChanged.connect(self.updateHorizontalWidth)  # [70]
        h_width_layout.addWidget(self.h_width_slider)
        self.h_width_value = QSpinBox()
        self.h_width_value.setRange(1, 20)
        self.h_width_value.valueChanged.connect(self.updateHorizontalWidthValue)
        h_width_layout.addWidget(self.h_width_value)
        horizontal_layout.addLayout(h_width_layout)
        self.horizontal_group.setLayout(horizontal_layout)
        sections_layout.addWidget(self.horizontal_group)

        self.vertical_group = QGroupBox()  # [71]
        vertical_layout = QVBoxLayout()
        v_count_layout = QHBoxLayout()
        self.v_count_label = QLabel()
        v_count_layout.addWidget(self.v_count_label)
        self.v_slider = QSlider(Qt.Horizontal)
        self.v_slider.setRange(1, 100)
        self.v_slider.valueChanged.connect(self.updateVerticalSections)
        v_count_layout.addWidget(self.v_slider)
        self.v_value = QSpinBox()  # [72]
        self.v_value.setRange(1, 10000)
        self.v_value.valueChanged.connect(self.updateVerticalSectionsValue)
        v_count_layout.addWidget(self.v_value)
        vertical_layout.addLayout(v_count_layout)
        v_color_layout = QHBoxLayout()
        self.v_color_label = QLabel()
        v_color_layout.addWidget(self.v_color_label)
        self.v_color_button = QPushButton()
        self.v_color_button.setMinimumSize(QSize(40, 20))  # [73]
        self.v_color_button.clicked.connect(self.chooseVerticalColor)
        v_color_layout.addWidget(self.v_color_button)
        self.v_opacity_label = QLabel()
        v_color_layout.addWidget(self.v_opacity_label)
        self.v_opacity_slider = QSlider(Qt.Horizontal)
        self.v_opacity_slider.setRange(0, 255)
        self.v_opacity_slider.valueChanged.connect(self.updateVerticalOpacity)
        v_color_layout.addWidget(self.v_opacity_slider)
        vertical_layout.addLayout(v_color_layout)  # [74]
        v_width_layout = QHBoxLayout()
        self.v_width_label = QLabel()
        v_width_layout.addWidget(self.v_width_label)
        self.v_width_slider = QSlider(Qt.Horizontal)
        self.v_width_slider.setRange(1, 10)
        self.v_width_slider.valueChanged.connect(self.updateVerticalWidth)
        v_width_layout.addWidget(self.v_width_slider)
        self.v_width_value = QSpinBox()
        self.v_width_value.setRange(1, 20)  # [75]
        self.v_width_value.valueChanged.connect(self.updateVerticalWidthValue)
        v_width_layout.addWidget(self.v_width_value)
        vertical_layout.addLayout(v_width_layout)
        self.vertical_group.setLayout(vertical_layout)
        sections_layout.addWidget(self.vertical_group)

        self.grid_preset_group = QGroupBox()
        grid_preset_layout = QHBoxLayout()
        self.columns_preset_label = QLabel()
        grid_preset_layout.addWidget(self.columns_preset_label)  # [76]
        self.columns_spinbox = QSpinBox()
        self.columns_spinbox.setRange(1, 10000)
        grid_preset_layout.addWidget(self.columns_spinbox)
        self.rows_preset_label = QLabel()
        grid_preset_layout.addWidget(self.rows_preset_label)
        self.rows_spinbox = QSpinBox()
        self.rows_spinbox.setRange(1, 10000)
        grid_preset_layout.addWidget(self.rows_spinbox)
        self.apply_button = QPushButton()  # [77]
        self.apply_button.clicked.connect(self.applyGridPreset)
        grid_preset_layout.addWidget(self.apply_button)
        self.grid_preset_group.setLayout(grid_preset_layout)
        sections_layout.addWidget(self.grid_preset_group)
        self.sections_group.setLayout(sections_layout)
        main_layout.addWidget(self.sections_group)

        # Cell Size Group
        self.cellsize_group = QGroupBox()
        cellsize_layout = QVBoxLayout()  # [78]
        self.cell_dims_group = QGroupBox()
        cell_dims_layout = QHBoxLayout()
        self.cell_width_label = QLabel()
        cell_dims_layout.addWidget(self.cell_width_label)
        self.cell_width_spinbox = QSpinBox()
        self.cell_width_spinbox.setRange(1, 5000)
        self.cell_width_spinbox.valueChanged.connect(self._update_cell_width)
        cell_dims_layout.addWidget(self.cell_width_spinbox)
        cell_dims_layout.addSpacing(20)  # [79]
        self.cell_height_label = QLabel()
        cell_dims_layout.addWidget(self.cell_height_label)
        self.cell_height_spinbox = QSpinBox()
        self.cell_height_spinbox.setRange(1, 5000)
        self.cell_height_spinbox.valueChanged.connect(self._update_cell_height)
        cell_dims_layout.addWidget(self.cell_height_spinbox)
        cell_dims_layout.addStretch()
        self.cell_dims_group.setLayout(cell_dims_layout)
        cellsize_layout.addWidget(self.cell_dims_group)  # [80]

        self.cell_h_style_group = QGroupBox()
        cell_h_style_layout = QVBoxLayout()
        cell_h_color_layout = QHBoxLayout()
        self.cell_h_color_label = QLabel()
        cell_h_color_layout.addWidget(self.cell_h_color_label)
        self.cell_h_color_button = QPushButton()
        self.cell_h_color_button.setMinimumSize(QSize(40, 20))
        self.cell_h_color_button.clicked.connect(self.chooseCellHorizontalColor)
        cell_h_color_layout.addWidget(self.cell_h_color_button)  # [81]
        self.cell_h_opacity_label = QLabel()
        cell_h_color_layout.addWidget(self.cell_h_opacity_label)
        self.cell_h_opacity_slider = QSlider(Qt.Horizontal)
        self.cell_h_opacity_slider.setRange(0, 255)
        self.cell_h_opacity_slider.valueChanged.connect(
            self.updateCellHorizontalOpacity
        )
        cell_h_color_layout.addWidget(self.cell_h_opacity_slider)
        cell_h_style_layout.addLayout(cell_h_color_layout)  # [82]
        cell_h_width_layout = QHBoxLayout()
        self.cell_h_width_label = QLabel()
        cell_h_width_layout.addWidget(self.cell_h_width_label)
        self.cell_h_width_slider = QSlider(Qt.Horizontal)
        self.cell_h_width_slider.setRange(1, 10)
        self.cell_h_width_slider.valueChanged.connect(self.updateCellHorizontalWidth)
        cell_h_width_layout.addWidget(self.cell_h_width_slider)
        self.cell_h_width_value = QSpinBox()
        self.cell_h_width_value.setRange(1, 20)  # [83]
        self.cell_h_width_value.valueChanged.connect(
            self.updateCellHorizontalWidthValue
        )
        cell_h_width_layout.addWidget(self.cell_h_width_value)
        cell_h_style_layout.addLayout(cell_h_width_layout)
        self.cell_h_style_group.setLayout(cell_h_style_layout)
        cellsize_layout.addWidget(self.cell_h_style_group)

        self.cell_v_style_group = QGroupBox()
        cell_v_style_layout = QVBoxLayout()  # [84]
        cell_v_color_layout = QHBoxLayout()
        self.cell_v_color_label = QLabel()
        cell_v_color_layout.addWidget(self.cell_v_color_label)
        self.cell_v_color_button = QPushButton()
        self.cell_v_color_button.setMinimumSize(QSize(40, 20))
        self.cell_v_color_button.clicked.connect(self.chooseCellVerticalColor)
        cell_v_color_layout.addWidget(self.cell_v_color_button)
        self.cell_v_opacity_label = QLabel()
        cell_v_color_layout.addWidget(self.cell_v_opacity_label)  # [85]
        self.cell_v_opacity_slider = QSlider(Qt.Horizontal)
        self.cell_v_opacity_slider.setRange(0, 255)
        self.cell_v_opacity_slider.valueChanged.connect(self.updateCellVerticalOpacity)
        cell_v_color_layout.addWidget(self.cell_v_opacity_slider)
        cell_v_style_layout.addLayout(cell_v_color_layout)
        cell_v_width_layout = QHBoxLayout()
        self.cell_v_width_label = QLabel()
        cell_v_width_layout.addWidget(self.cell_v_width_label)
        self.cell_v_width_slider = QSlider(Qt.Horizontal)  # [86]
        self.cell_v_width_slider.setRange(1, 10)
        self.cell_v_width_slider.valueChanged.connect(self.updateCellVerticalWidth)
        cell_v_width_layout.addWidget(self.cell_v_width_slider)
        self.cell_v_width_value = QSpinBox()
        self.cell_v_width_value.setRange(1, 20)
        self.cell_v_width_value.valueChanged.connect(self.updateCellVerticalWidthValue)
        cell_v_width_layout.addWidget(self.cell_v_width_value)
        cell_v_style_layout.addLayout(cell_v_width_layout)
        self.cell_v_style_group.setLayout(cell_v_style_layout)  # [87]
        cellsize_layout.addWidget(self.cell_v_style_group)
        self.cellsize_group.setLayout(cellsize_layout)
        main_layout.addWidget(self.cellsize_group)
        self.cellsize_group.setVisible(False)

        # Common Settings (Offset, Dots)
        self.offset_group = QGroupBox()
        offset_layout = QVBoxLayout()
        x_offset_layout = QHBoxLayout()
        self.x_offset_label = QLabel()  # [88]
        x_offset_layout.addWidget(self.x_offset_label)
        self.x_offset_slider = QSlider(Qt.Horizontal)
        self.x_offset_slider.setRange(-500, 500)
        self.x_offset_slider.valueChanged.connect(self.updateOffsetX)
        x_offset_layout.addWidget(self.x_offset_slider)
        self.x_offset_value = QSpinBox()
        self.x_offset_value.setRange(-10000, 10000)
        self.x_offset_value.valueChanged.connect(self.updateOffsetXValue)
        x_offset_layout.addWidget(self.x_offset_value)  # [89]
        offset_layout.addLayout(x_offset_layout)
        y_offset_layout = QHBoxLayout()
        self.y_offset_label = QLabel()
        y_offset_layout.addWidget(self.y_offset_label)
        self.y_offset_slider = QSlider(Qt.Horizontal)
        self.y_offset_slider.setRange(-500, 500)
        self.y_offset_slider.valueChanged.connect(self.updateOffsetY)
        y_offset_layout.addWidget(self.y_offset_slider)
        self.y_offset_value = QSpinBox()  # [90]
        self.y_offset_value.setRange(-10000, 10000)
        self.y_offset_value.valueChanged.connect(self.updateOffsetYValue)
        y_offset_layout.addWidget(self.y_offset_value)
        offset_layout.addLayout(y_offset_layout)
        reset_button_layout = QHBoxLayout()
        reset_button_layout.addStretch()
        self.reset_offset_button = QPushButton()
        self.reset_offset_button.clicked.connect(self.resetOffsets)
        reset_button_layout.addWidget(self.reset_offset_button)  # [91]
        offset_layout.addLayout(reset_button_layout)
        self.offset_group.setLayout(offset_layout)
        main_layout.addWidget(self.offset_group)

        self.dots_group = QGroupBox()
        dots_layout = QVBoxLayout()
        self.dots_checkbox = QCheckBox()
        self.dots_checkbox.stateChanged.connect(self.toggleDots)
        dots_layout.addWidget(self.dots_checkbox)
        dot_size_layout = QHBoxLayout()  # [92]
        self.dot_size_label = QLabel()
        dot_size_layout.addWidget(self.dot_size_label)
        self.dot_size_slider = QSlider(Qt.Horizontal)
        self.dot_size_slider.setRange(1, 20)
        self.dot_size_slider.valueChanged.connect(self.updateDotSize)
        dot_size_layout.addWidget(self.dot_size_slider)
        self.dot_size_value = QSpinBox()
        self.dot_size_value.setRange(1, 50)
        self.dot_size_value.valueChanged.connect(self.updateDotSizeValue)  # [93]
        dot_size_layout.addWidget(self.dot_size_value)
        dots_layout.addLayout(dot_size_layout)
        dot_color_layout = QHBoxLayout()
        self.dot_color_label = QLabel()
        dot_color_layout.addWidget(self.dot_color_label)
        self.dot_color_button = QPushButton()
        self.dot_color_button.setMinimumSize(QSize(40, 20))
        self.dot_color_button.clicked.connect(self.chooseDotColor)
        dot_color_layout.addWidget(self.dot_color_button)  # [94]
        self.dot_opacity_label = QLabel()
        dot_color_layout.addWidget(self.dot_opacity_label)
        self.dot_opacity_slider = QSlider(Qt.Horizontal)
        self.dot_opacity_slider.setRange(0, 255)
        self.dot_opacity_slider.valueChanged.connect(self.updateDotOpacity)
        dot_color_layout.addWidget(self.dot_opacity_slider)
        dots_layout.addLayout(dot_color_layout)
        self.dots_group.setLayout(dots_layout)
        main_layout.addWidget(self.dots_group)  # [95]

        main_layout.addStretch()
        self.retranslateUi()

    def retranslateUi(self):
        self.setWindowTitle(grid_tr("settings_window_title"))
        self.grid_checkbox.setText(grid_tr("show_grid_checkbox"))
        self.mode_label.setText(grid_tr("grid_mode_label"))
        selected_mode_data = self.mode_combobox.currentData()
        self.mode_combobox.blockSignals(True)  # [96]
        self.mode_combobox.clear()
        self.mode_combobox.addItem(grid_tr("mode_sections"), GridOverlay.MODE_SECTIONS)
        self.mode_combobox.addItem(
            grid_tr("mode_cell_size"), GridOverlay.MODE_CELL_SIZE
        )
        mode_index = self.mode_combobox.findData(selected_mode_data)
        self.mode_combobox.setCurrentIndex(mode_index if mode_index != -1 else 0)
        self.mode_combobox.blockSignals(False)
        self.sections_group.setTitle(grid_tr("sections_group_title"))
        self.horizontal_group.setTitle(grid_tr("rows_group_title"))
        self.h_count_label.setText(grid_tr("count_label"))  # [97]
        self.h_color_label.setText(grid_tr("color_label"))
        self.h_opacity_label.setText(grid_tr("opacity_label"))
        self.h_width_label.setText(grid_tr("thickness_label"))
        self.vertical_group.setTitle(grid_tr("cols_group_title"))
        self.v_count_label.setText(grid_tr("count_label"))
        self.v_color_label.setText(grid_tr("color_label"))
        self.v_opacity_label.setText(grid_tr("opacity_label"))
        self.v_width_label.setText(grid_tr("thickness_label"))
        self.grid_preset_group.setTitle(grid_tr("preset_group_title"))  # [98]
        self.columns_preset_label.setText(grid_tr("columns_label"))
        self.rows_preset_label.setText(grid_tr("rows_label"))
        self.apply_button.setText(grid_tr("apply_button"))
        self.cellsize_group.setTitle(grid_tr("cellsize_group_title"))
        self.cell_dims_group.setTitle(grid_tr("cell_dims_group_title"))
        self.cell_width_label.setText(grid_tr("width_label"))
        self.cell_height_label.setText(grid_tr("height_label"))
        self.cell_h_style_group.setTitle(grid_tr("cell_h_style_group_title"))
        self.cell_h_color_label.setText(grid_tr("color_label"))  # [99]
        self.cell_h_opacity_label.setText(grid_tr("opacity_label"))
        self.cell_h_width_label.setText(grid_tr("thickness_label"))
        self.cell_v_style_group.setTitle(grid_tr("cell_v_style_group_title"))
        self.cell_v_color_label.setText(grid_tr("color_label"))
        self.cell_v_opacity_label.setText(grid_tr("opacity_label"))
        self.cell_v_width_label.setText(grid_tr("thickness_label"))
        self.offset_group.setTitle(grid_tr("offset_group_title"))
        self.x_offset_label.setText(grid_tr("offset_x_label"))
        self.y_offset_label.setText(grid_tr("offset_y_label"))  # [100]
        self.reset_offset_button.setText(grid_tr("reset_offset_button"))
        self.dots_group.setTitle(grid_tr("dots_group_title"))
        self.dots_checkbox.setText(grid_tr("show_dots_checkbox"))
        self.dot_size_label.setText(grid_tr("dot_size_label"))
        self.dot_color_label.setText(grid_tr("color_label"))
        self.dot_opacity_label.setText(grid_tr("opacity_label"))
        self.h_color_dialog_title = grid_tr("choose_color_sections_h")
        self.v_color_dialog_title = grid_tr("choose_color_sections_v")
        self.cell_h_color_dialog_title = grid_tr("choose_color_cells_h")  # [101]
        self.cell_v_color_dialog_title = grid_tr("choose_color_cells_v")
        self.dot_color_dialog_title = grid_tr("choose_color_dots")

    def _update_mode_ui(self, index):
        selected_mode = self.mode_combobox.itemData(index)
        if selected_mode is None:
            return
        self.sections_group.setVisible(selected_mode == GridOverlay.MODE_SECTIONS)
        self.cellsize_group.setVisible(selected_mode == GridOverlay.MODE_CELL_SIZE)
        if not self._loading_settings:  # [102]
            self.grid_overlay.grid_mode = selected_mode
            mode_name = (
                grid_tr("mode_sections")
                if selected_mode == GridOverlay.MODE_SECTIONS
                else grid_tr("mode_cell_size")
            )
            print(grid_tr("switch_mode_log", mode_name=mode_name))
            self.grid_overlay.update()

    def toggleGrid(self, state_int):  # [103]
        # In PySide6, stateChanged provides the CheckState enum directly if type hint is used,
        # or an int otherwise. Let's assume state_int is int for wider compatibility.
        checked = state_int == Qt.Checked.value
        self.grid_overlay.visible = checked
        self.grid_overlay.setVisible(checked)
        # Emit signal for ControlPanel
        self.grid_visibility_changed_signal.emit(checked)

        # Update tray icon state if it exists (will be managed by MainApplication) # [104]
        # app = QApplication.instance()
        # if hasattr(app, "grid_tray_show_action"): # Check for a specific grid tray action
        #     app.grid_tray_show_action.setChecked(checked)

        if not self._loading_settings:
            self.settings.setValue("visible", checked)

    def updateHorizontalSections(self, value):
        if not self._loading_settings:
            self.grid_overlay.horizontal_sections = value  # [105]
            self.grid_overlay.update()
        self.h_value.setValue(value)
        self.rows_spinbox.setValue(value)

    def updateHorizontalSectionsValue(self, value):
        if not self._loading_settings:
            self.grid_overlay.horizontal_sections = value
            self.grid_overlay.update()
        self.rows_spinbox.setValue(value)
        if 1 <= value <= self.h_slider.maximum():
            self.h_slider.setValue(value)  # [106]

    def updateVerticalSections(self, value):
        if not self._loading_settings:
            self.grid_overlay.vertical_sections = value
            self.grid_overlay.update()
        self.v_value.setValue(value)
        self.columns_spinbox.setValue(value)

    def updateVerticalSectionsValue(self, value):
        if not self._loading_settings:  # [107]
            self.grid_overlay.vertical_sections = value
            self.grid_overlay.update()
        self.columns_spinbox.setValue(value)
        if 1 <= value <= self.v_slider.maximum():
            self.v_slider.setValue(value)

    def chooseHorizontalColor(self):
        color = QColorDialog.getColor(
            self.grid_overlay.horizontal_color,
            self,
            self.h_color_dialog_title,  # [108]
            options=QColorDialog.ShowAlphaChannel,
        )
        if color.isValid():
            self.grid_overlay.horizontal_color = color
            self.updateHorizontalColorButton()
            self.h_opacity_slider.setValue(color.alpha())
            self.grid_overlay.update()

    def updateHorizontalOpacity(self, value):
        color = self.grid_overlay.horizontal_color  # [109]
        color.setAlpha(value)
        self.grid_overlay.horizontal_color = color
        self.updateHorizontalColorButton()
        self.grid_overlay.update()

    def updateHorizontalWidth(self, value):
        self.grid_overlay.horizontal_width = value
        self.h_width_value.setValue(value)
        self.grid_overlay.update()

    def updateHorizontalWidthValue(self, value):  # [110]
        self.grid_overlay.horizontal_width = value
        if 1 <= value <= self.h_width_slider.maximum():
            self.h_width_slider.setValue(value)
        self.grid_overlay.update()

    def chooseVerticalColor(self):
        color = QColorDialog.getColor(
            self.grid_overlay.vertical_color,
            self,
            self.v_color_dialog_title,
            options=QColorDialog.ShowAlphaChannel,  # [111]
        )
        if color.isValid():
            self.grid_overlay.vertical_color = color
            self.updateVerticalColorButton()
            self.v_opacity_slider.setValue(color.alpha())
            self.grid_overlay.update()

    def updateVerticalOpacity(self, value):
        color = self.grid_overlay.vertical_color
        color.setAlpha(value)  # [112]
        self.grid_overlay.vertical_color = color
        self.updateVerticalColorButton()
        self.grid_overlay.update()

    def updateVerticalWidth(self, value):
        self.grid_overlay.vertical_width = value
        self.v_width_value.setValue(value)
        self.grid_overlay.update()

    def updateVerticalWidthValue(self, value):
        self.grid_overlay.vertical_width = value  # [113]
        if 1 <= value <= self.v_width_slider.maximum():
            self.v_width_slider.setValue(value)
        self.grid_overlay.update()

    def applyGridPreset(self):
        if self.grid_overlay.grid_mode == GridOverlay.MODE_SECTIONS:
            self.updateVerticalSectionsValue(self.columns_spinbox.value())
            self.updateHorizontalSectionsValue(self.rows_spinbox.value())
        else:
            print(grid_tr("info_preset_sections_only"))

    def _update_cell_width(self, value):  # [114]
        if not self._loading_settings:
            self.grid_overlay.cell_width = value
            self.grid_overlay.update()

    def _update_cell_height(self, value):
        if not self._loading_settings:
            self.grid_overlay.cell_height = value
            self.grid_overlay.update()

    def chooseCellHorizontalColor(self):
        color = QColorDialog.getColor(  # [115]
            self.grid_overlay.cell_horizontal_color,
            self,
            self.cell_h_color_dialog_title,
            options=QColorDialog.ShowAlphaChannel,
        )
        if color.isValid():
            self.grid_overlay.cell_horizontal_color = color
            self.updateCellHorizontalColorButton()
            self.cell_h_opacity_slider.setValue(color.alpha())
            self.grid_overlay.update()  # [116]

    def updateCellHorizontalOpacity(self, value):
        color = self.grid_overlay.cell_horizontal_color
        color.setAlpha(value)
        self.grid_overlay.cell_horizontal_color = color
        self.updateCellHorizontalColorButton()
        self.grid_overlay.update()

    def updateCellHorizontalWidth(self, value):
        self.grid_overlay.cell_horizontal_width = value
        self.cell_h_width_value.setValue(value)  # [117]
        self.grid_overlay.update()

    def updateCellHorizontalWidthValue(self, value):
        self.grid_overlay.cell_horizontal_width = value
        if 1 <= value <= self.cell_h_width_slider.maximum():
            self.cell_h_width_slider.setValue(value)
        self.grid_overlay.update()

    def chooseCellVerticalColor(self):
        color = QColorDialog.getColor(
            self.grid_overlay.cell_vertical_color,
            self,  # [118]
            self.cell_v_color_dialog_title,
            options=QColorDialog.ShowAlphaChannel,
        )
        if color.isValid():
            self.grid_overlay.cell_vertical_color = color
            self.updateCellVerticalColorButton()
            self.cell_v_opacity_slider.setValue(color.alpha())
            self.grid_overlay.update()

    def updateCellVerticalOpacity(self, value):
        color = self.grid_overlay.cell_vertical_color  # [119]
        color.setAlpha(value)
        self.grid_overlay.cell_vertical_color = color
        self.updateCellVerticalColorButton()
        self.grid_overlay.update()

    def updateCellVerticalWidth(self, value):
        self.grid_overlay.cell_vertical_width = value
        self.cell_v_width_value.setValue(value)
        self.grid_overlay.update()

    def updateCellVerticalWidthValue(self, value):  # [120]
        self.grid_overlay.cell_vertical_width = value
        if 1 <= value <= self.cell_v_width_slider.maximum():
            self.cell_v_width_slider.setValue(value)
        self.grid_overlay.update()

    def updateOffsetX(self, value):
        self.grid_overlay.offset_x = value
        self.x_offset_value.setValue(value)
        self.grid_overlay.update()

    def updateOffsetXValue(self, value):
        self.grid_overlay.offset_x = value  # [121]
        if self.x_offset_slider.minimum() <= value <= self.x_offset_slider.maximum():
            self.x_offset_slider.setValue(value)
        self.grid_overlay.update()

    def updateOffsetY(self, value):
        self.grid_overlay.offset_y = value
        self.y_offset_value.setValue(value)
        self.grid_overlay.update()

    def updateOffsetYValue(self, value):
        self.grid_overlay.offset_y = value
        if self.y_offset_slider.minimum() <= value <= self.y_offset_slider.maximum():
            self.y_offset_slider.setValue(value)  # [122]
        self.grid_overlay.update()

    def resetOffsets(self):
        print(grid_tr("resetting_offset"))
        self.updateOffsetXValue(0)
        self.updateOffsetYValue(0)

    def toggleDots(self, state_int):
        checked = state_int == Qt.Checked.value
        self.grid_overlay.show_dots = checked
        if not self._loading_settings:  # [123]
            self.grid_overlay.update()

    def updateDotSize(self, value):
        self.grid_overlay.dot_size = value
        self.dot_size_value.setValue(value)
        self.grid_overlay.update()

    def updateDotSizeValue(self, value):
        self.grid_overlay.dot_size = value
        if 1 <= value <= self.dot_size_slider.maximum():
            self.dot_size_slider.setValue(value)
        self.grid_overlay.update()  # [124]

    def chooseDotColor(self):
        color = QColorDialog.getColor(
            self.grid_overlay.dot_color,
            self,
            self.dot_color_dialog_title,
            options=QColorDialog.ShowAlphaChannel,
        )
        if color.isValid():
            self.grid_overlay.dot_color = color  # [125]
            self.updateDotColorButton()
            self.dot_opacity_slider.setValue(color.alpha())
            self.grid_overlay.update()

    def updateDotOpacity(self, value):
        color = self.grid_overlay.dot_color
        color.setAlpha(value)
        self.grid_overlay.dot_color = color
        self.updateDotColorButton()
        self.grid_overlay.update()  # [126]

    def updateHorizontalColorButton(self):
        self.h_color_button.setStyleSheet(
            f"background-color: {self.grid_overlay.horizontal_color.name(QColor.HexArgb)};"
        )

    def updateVerticalColorButton(self):
        self.v_color_button.setStyleSheet(
            f"background-color: {self.grid_overlay.vertical_color.name(QColor.HexArgb)};"
        )  # [127]

    def updateCellHorizontalColorButton(self):
        self.cell_h_color_button.setStyleSheet(
            f"background-color: {self.grid_overlay.cell_horizontal_color.name(QColor.HexArgb)};"
        )

    def updateCellVerticalColorButton(self):
        self.cell_v_color_button.setStyleSheet(
            f"background-color: {self.grid_overlay.cell_vertical_color.name(QColor.HexArgb)};"
        )  # [128]

    def updateDotColorButton(self):
        self.dot_color_button.setStyleSheet(
            f"background-color: {self.grid_overlay.dot_color.name(QColor.HexArgb)};"
        )

    def saveSettings(self):
        self.settings.setValue("gridMode", self.grid_overlay.grid_mode)
        self.settings.setValue("visible", self.grid_overlay.visible)
        self.settings.setValue(  # [129]
            "horizontalSections", self.grid_overlay.horizontal_sections
        )
        self.settings.setValue("verticalSections", self.grid_overlay.vertical_sections)
        self.settings.setValue(
            "horizontalColor",
            self.grid_overlay.horizontal_color.name(QColor.HexArgb),
        )
        self.settings.setValue(  # [130]
            "verticalColor",
            self.grid_overlay.vertical_color.name(QColor.HexArgb),
        )
        self.settings.setValue("horizontalWidth", self.grid_overlay.horizontal_width)
        self.settings.setValue("verticalWidth", self.grid_overlay.vertical_width)
        self.settings.setValue("cellWidth", self.grid_overlay.cell_width)
        self.settings.setValue("cellHeight", self.grid_overlay.cell_height)
        self.settings.setValue(
            "cellHorizontalColor",
            self.grid_overlay.cell_horizontal_color.name(QColor.HexArgb),  # [131]
        )
        self.settings.setValue(
            "cellVerticalColor",
            self.grid_overlay.cell_vertical_color.name(QColor.HexArgb),
        )
        self.settings.setValue(
            "cellHorizontalWidth", self.grid_overlay.cell_horizontal_width
        )
        self.settings.setValue(  # [132]
            "cellVerticalWidth", self.grid_overlay.cell_vertical_width
        )
        self.settings.setValue("offsetX", self.grid_overlay.offset_x)
        self.settings.setValue("offsetY", self.grid_overlay.offset_y)
        self.settings.setValue("showDots", self.grid_overlay.show_dots)
        self.settings.setValue("dotSize", self.grid_overlay.dot_size)
        self.settings.setValue(
            "dotColor", self.grid_overlay.dot_color.name(QColor.HexArgb)
        )
        self.settings.sync()  # [133]

    def loadSettings(self):
        print(grid_tr("loading_settings"))
        self._loading_settings = True
        self.retranslateUi()

        self.grid_overlay.visible = self.settings.value("visible", True, type=bool)
        self.grid_checkbox.setChecked(self.grid_overlay.visible)
        loaded_mode = int(  # [134]
            self.settings.value("gridMode", GridOverlay.MODE_SECTIONS, type=int)
        )
        index = self.mode_combobox.findData(loaded_mode)
        self.mode_combobox.setCurrentIndex(index if index != -1 else 0)
        self.grid_overlay.grid_mode = loaded_mode

        h_sections = int(self.settings.value("horizontalSections", 11, type=int))
        v_sections = int(self.settings.value("verticalSections", 11, type=int))
        self.grid_overlay.horizontal_sections = max(1, h_sections)
        self.grid_overlay.vertical_sections = max(1, v_sections)  # [135]
        self.h_value.setValue(self.grid_overlay.horizontal_sections)
        if 1 <= self.grid_overlay.horizontal_sections <= self.h_slider.maximum():
            self.h_slider.setValue(self.grid_overlay.horizontal_sections)
        self.rows_spinbox.setValue(self.grid_overlay.horizontal_sections)
        self.v_value.setValue(self.grid_overlay.vertical_sections)
        if 1 <= self.grid_overlay.vertical_sections <= self.v_slider.maximum():
            self.v_slider.setValue(self.grid_overlay.vertical_sections)
        self.columns_spinbox.setValue(self.grid_overlay.vertical_sections)

        h_color_default = QColor(0, 120, 215, 128).name(QColor.HexArgb)
        self.grid_overlay.horizontal_color = QColor(
            self.settings.value("horizontalColor", h_color_default, type=str)  # [136]
        )
        self.updateHorizontalColorButton()
        self.h_opacity_slider.setValue(self.grid_overlay.horizontal_color.alpha())
        v_color_default = QColor(0, 120, 215, 128).name(QColor.HexArgb)
        self.grid_overlay.vertical_color = QColor(
            self.settings.value("verticalColor", v_color_default, type=str)
        )
        self.updateVerticalColorButton()
        self.v_opacity_slider.setValue(
            self.grid_overlay.vertical_color.alpha()
        )  # [137]

        self.grid_overlay.horizontal_width = max(
            1, int(self.settings.value("horizontalWidth", 1, type=int))
        )
        self.h_width_value.setValue(self.grid_overlay.horizontal_width)
        if 1 <= self.grid_overlay.horizontal_width <= self.h_width_slider.maximum():
            self.h_width_slider.setValue(self.grid_overlay.horizontal_width)
        self.grid_overlay.vertical_width = max(  # [138]
            1, int(self.settings.value("verticalWidth", 1, type=int))
        )
        self.v_width_value.setValue(self.grid_overlay.vertical_width)
        if 1 <= self.grid_overlay.vertical_width <= self.v_width_slider.maximum():
            self.v_width_slider.setValue(self.grid_overlay.vertical_width)

        self.grid_overlay.cell_width = max(
            1, int(self.settings.value("cellWidth", 50, type=int))
        )
        self.grid_overlay.cell_height = max(  # [139]
            1, int(self.settings.value("cellHeight", 50, type=int))
        )
        self.cell_width_spinbox.setValue(self.grid_overlay.cell_width)
        self.cell_height_spinbox.setValue(self.grid_overlay.cell_height)

        cell_h_color_default = QColor(215, 120, 0, 128).name(QColor.HexArgb)
        self.grid_overlay.cell_horizontal_color = QColor(
            self.settings.value("cellHorizontalColor", cell_h_color_default, type=str)
        )
        self.updateCellHorizontalColorButton()
        self.cell_h_opacity_slider.setValue(  # [140]
            self.grid_overlay.cell_horizontal_color.alpha()
        )
        cell_v_color_default = QColor(215, 120, 0, 128).name(QColor.HexArgb)
        self.grid_overlay.cell_vertical_color = QColor(
            self.settings.value("cellVerticalColor", cell_v_color_default, type=str)
        )
        self.updateCellVerticalColorButton()
        self.cell_v_opacity_slider.setValue(  # [141]
            self.grid_overlay.cell_vertical_color.alpha()
        )

        self.grid_overlay.cell_horizontal_width = max(
            1, int(self.settings.value("cellHorizontalWidth", 1, type=int))
        )
        self.cell_h_width_value.setValue(self.grid_overlay.cell_horizontal_width)
        if (
            1
            <= self.grid_overlay.cell_horizontal_width
            <= self.cell_h_width_slider.maximum()
        ):
            self.cell_h_width_slider.setValue(self.grid_overlay.cell_horizontal_width)
        self.grid_overlay.cell_vertical_width = max(  # [142]
            1, int(self.settings.value("cellVerticalWidth", 1, type=int))
        )
        self.cell_v_width_value.setValue(self.grid_overlay.cell_vertical_width)
        if (
            1
            <= self.grid_overlay.cell_vertical_width
            <= self.cell_v_width_slider.maximum()
        ):
            self.cell_v_width_slider.setValue(self.grid_overlay.cell_vertical_width)

        self.grid_overlay.offset_x = int(self.settings.value("offsetX", 0, type=int))
        self.grid_overlay.offset_y = int(self.settings.value("offsetY", 0, type=int))
        self.x_offset_value.setValue(self.grid_overlay.offset_x)
        if (
            self.x_offset_slider.minimum()
            <= self.grid_overlay.offset_x
            <= self.x_offset_slider.maximum()
        ):
            self.x_offset_slider.setValue(self.grid_overlay.offset_x)
        self.y_offset_value.setValue(self.grid_overlay.offset_y)
        if (
            self.y_offset_slider.minimum()
            <= self.grid_overlay.offset_y
            <= self.y_offset_slider.maximum()
        ):
            self.y_offset_slider.setValue(self.grid_overlay.offset_y)  # [143]

        self.grid_overlay.show_dots = self.settings.value("showDots", False, type=bool)
        self.dots_checkbox.setChecked(self.grid_overlay.show_dots)
        self.grid_overlay.dot_size = max(
            1, int(self.settings.value("dotSize", 4, type=int))
        )
        self.dot_size_value.setValue(self.grid_overlay.dot_size)
        if 1 <= self.grid_overlay.dot_size <= self.dot_size_slider.maximum():
            self.dot_size_slider.setValue(self.grid_overlay.dot_size)

        dot_color_default = QColor(0, 255, 0, 192).name(QColor.HexArgb)  # [144]
        self.grid_overlay.dot_color = QColor(
            self.settings.value("dotColor", dot_color_default, type=str)
        )
        self.updateDotColorButton()
        self.dot_opacity_slider.setValue(self.grid_overlay.dot_color.alpha())

        self._update_mode_ui(self.mode_combobox.currentIndex())
        self._loading_settings = False
        self.grid_overlay.update()


# The GridApp class from Grid_DesktopEN.py will be largely refactored. # [145]
# Its core functionalities (managing GridOverlay and SettingsWindow, handling signals/slots
# for hotkeys) will be integrated into MainApplication and DesktopOverlayRgn.
# The tray icon part of GridApp will be merged with MainApplication's tray icon.

# --- End of Integrated Grid_DesktopEN.py (converted to PySide6) ---


# --- INTEGRATED Lines_DesktopEN.py ---
# Helper function to format hotkey strings for display
def formatuj_skrot_klawiszowy(skrot_str):  # [146]
    """
    Formats a hotkey string for better readability.
    E.g., "ctrl+alt+pageup" -> "Ctrl + Alt + PageUp"
    """
    if not skrot_str:
        return ""
    czesci = skrot_str.lower().split("+")
    sformatowane_czesci = []
    for czesc in czesci:  # [147]
        czesc_strip = czesc.strip()
        if czesc_strip in ["ctrl", "alt", "shift", "win"]:
            sformatowane_czesci.append(czesc_strip.capitalize())
        elif czesc_strip.startswith("page"):
            sformatowane_czesci.append(czesc_strip.capitalize())
        elif (
            czesc_strip.startswith("f")
            and len(czesc_strip) > 1
            and czesc_strip[1:].isdigit()
        ):
            sformatowane_czesci.append(czesc_strip.upper())
        else:
            sformatowane_czesci.append(czesc_strip)  # [148]
    return " + ".join(sformatowane_czesci)


# Constants from Lines_DesktopEN.py
LINES_ROZMIAR_LINIJKI = 1
LINES_KOLOR_TLA_LINIJKI = QColor(238, 238, 238)
LINES_KOLOR_ZNACZNIKA_GLOWNEGO = QColor(0, 0, 0)
LINES_KOLOR_ZNACZNIKA_SREDNIEGO = QColor(102, 102, 102)
LINES_KOLOR_ZNACZNIKA_POMNIEJSZEGO = QColor(170, 170, 170)
LINES_KOLOR_RAMKI = QColor(204, 204, 204)  # [149]
LINES_KOLOR_TLA_PODPOWIEDZI = QColor(0, 0, 0, 200)
LINES_KOLOR_TEKSTU_PODPOWIEDZI = QColor(255, 255, 255)
LINES_SZEROKOSC_UCHWYTU_SIATKI = 5
LINES_PLIK_STANU = os.path.join(
    os.path.expanduser("~"), ".gridlines_app_state_integrated.json"
)
LINES_DOMYSLNA_GRUBOŚĆ_SIATKI = 1
LINES_DOMYSLNY_KOLOR_SIATKI = "#00FCEA"
LINES_DOMYSLNA_PRZEZROCZYSTOŚĆ_SIATKI = 200
LINES_DOMYSLNA_POZYCJA_LINIJEK = "top-left"
LINES_POZYCJE_LINIJEK = [
    "top-left",
    "top-right",
    "bottom-right",
    "bottom-left",
]  # [150]
LINES_MAKS_GRUBOŚĆ_SIATKI = 20
LINES_KROK_ZMIANY_GRUBOSCI = 1
LINES_DOMYSLNY_JEZYK = "en"

# --- Keyboard Shortcuts (from Lines_DesktopEN.py - will be managed by DrawDesktop.py) ---
# LINES_SKROT_POZYCJA_LINIJEK = "alt+shift+pageup"
# LINES_SKROT_WYCZYSC_WSZYSTKO = "ctrl+alt+f9"
# LINES_SKROT_ZWIEKSZ_GRUBOSC = "ctrl+alt+pageup"
# LINES_SKROT_ZMNIEJSZ_GRUBOSC = "ctrl+alt+pagedown" # [151]

# --- Global variables (from Lines_DesktopEN.py - to be refactored) ---
# lines_instancja_aplikacji = None
# lines_instancja_ikony_zasobnika = None
# lines_id_glownego_watku = None

# --- Translation Contexts (from Lines_DesktopEN.py) ---
LINES_KONTEKST_TRAY = "LinesTrayMenu"
LINES_KONTEKST_SETTINGS = "LinesSettingsDialog"
LINES_KONTEKST_GRIDLINE = "LinesGridlineWidget"  # [152]
LINES_KONTEKST_APP = "LinesApp"

# --- Translation Dictionary (from Lines_DesktopEN.py, namespaced) ---
lines_slownik_tlumaczen = {
    "en": {
        # TrayMenu
        f"{LINES_KONTEKST_TRAY}|Zmień Pozycję ({{}})": "Change Lines Position ({})",
        f"{LINES_KONTEKST_TRAY}|Wyczyść Wszystko ({{}})": "Clear All Lines ({})",
        f"{LINES_KONTEKST_TRAY}|Ustawienia Wyglądu...": "Lines Appearance Settings...",  # [153]
        f"{LINES_KONTEKST_TRAY}|Wyjście ({{}})": "Exit Lines (managed by main app)",
        f"{LINES_KONTEKST_TRAY}|Linie Pomocnicze": "Guide Lines",
        # SettingsDialog
        f"{LINES_KONTEKST_SETTINGS}|Ustawienia Linii Pomocniczych": "Guide Lines Settings",
        f"{LINES_KONTEKST_SETTINGS}|Grubość:": "Thickness:",
        f"{LINES_KONTEKST_SETTINGS}| px": " px",
        f"{LINES_KONTEKST_SETTINGS}|Skróty: Zwiększ: {{}}, Zmniejsz: {{}}": "Shortcuts: Increase: {}, Decrease: {}",
        f"{LINES_KONTEKST_SETTINGS}|Kolor:": "Color:",
        f"{LINES_KONTEKST_SETTINGS}|Wybierz Kolor": "Select Color",  # [154]
        f"{LINES_KONTEKST_SETTINGS}|Wybierz Kolor Linii": "Select Line Color",
        f"{LINES_KONTEKST_SETTINGS}|Przezroczystość:": "Transparency:",
        f"{LINES_KONTEKST_SETTINGS}|Zamknij": "Close",
        f"{LINES_KONTEKST_SETTINGS}|Akcje:": "Actions:",
        f"{LINES_KONTEKST_SETTINGS}|Zmień Pozycję ({{}})": "Change Position ({})",
        f"{LINES_KONTEKST_SETTINGS}|Wyczyść Wszystko ({{}})": "Clear All ({})",
        # GridlineWidget
        f"{LINES_KONTEKST_GRIDLINE}|Y: {{pos}}px": "Y: {pos}px",
        f"{LINES_KONTEKST_GRIDLINE}|X: {{pos}}px": "X: {pos}px",  # [155]
    }
}


def lines_tr(kontekst, tekst_zrodlowy):
    """Translation helper for the Lines module."""
    biezacy_jezyk = LINES_DOMYSLNY_JEZYK
    klucz = f"{kontekst}|{tekst_zrodlowy}"
    tlumaczenie = lines_slownik_tlumaczen.get(biezacy_jezyk, {}).get(
        klucz, tekst_zrodlowy
    )
    return tlumaczenie


class LinesEmiterSygnalow(QObject):  # [156]
    # Signals will be emitted by the main application or ControlPanel
    zadanie_wyczyszczenia_wszystkiego_lines = Signal()
    # zadanie_wyjscia_z_aplikacji_lines = Signal()
    zadanie_zmiany_pozycji_linijek_lines = Signal()
    zadanie_okna_ustawien_lines = Signal()
    zadanie_zwiekszenia_grubosci_lines = Signal()
    zadanie_zmniejszenia_grubosci_lines = Signal()


lines_signal_emitter = LinesEmiterSygnalow()


class LinesOknoNakladki(QWidget):  # [157]
    def __init__(self, parent=None):
        super().__init__(parent=None)
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.hide()


class LinesWidzetLinijki(LinesOknoNakladki):  # [158]
    sygnal_klikniecia_lines = Signal(str, QPoint)

    def __init__(self, orientacja, lines_app_ref):
        super().__init__()
        self.orientacja = orientacja
        self.lines_app = lines_app_ref
        self.setObjectName(
            "LinijkaPoziomaLines"
            if orientacja == Qt.Horizontal
            else "LinijkaPionowaLines"  # [159]
        )
        self.setAttribute(Qt.WA_TranslucentBackground, False)
        self.setAutoFillBackground(True)
        paleta = self.palette()
        paleta.setColor(self.backgroundRole(), LINES_KOLOR_TLA_LINIJKI)
        self.setPalette(paleta)
        self.setMouseTracking(True)
        if self.orientacja == Qt.Horizontal:
            self.setCursor(Qt.SplitVCursor)
            self.setFixedHeight(LINES_ROZMIAR_LINIJKI)  # [160]
            self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        else:
            self.setCursor(Qt.SplitHCursor)
            self.setFixedWidth(LINES_ROZMIAR_LINIJKI)
            self.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Expanding)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, False)
        prostokat = self.rect()  # [161]
        pioro = QPen()
        pioro.setWidth(1)
        pioro.setColor(LINES_KOLOR_RAMKI)
        painter.setPen(pioro)
        if self.orientacja == Qt.Horizontal:
            painter.drawLine(prostokat.bottomLeft(), prostokat.bottomRight())
        else:
            painter.drawLine(prostokat.topRight(), prostokat.bottomRight())
        odstep_znacznika = 5  # [162]

        if self.orientacja == Qt.Horizontal:
            dlugosc = prostokat.width()
            start_abs_x = self.mapToGlobal(QPoint(0, 0)).x()
            for x_abs in range(
                start_abs_x, start_abs_x + dlugosc + odstep_znacznika, odstep_znacznika
            ):
                x_rel = x_abs - start_abs_x
                if x_rel < 0 or x_rel > dlugosc:  # [163]
                    continue
                if x_abs == 0 and start_abs_x != 0:
                    continue
                if x_abs % 50 == 0:
                    pioro.setColor(LINES_KOLOR_ZNACZNIKA_GLOWNEGO)
                    wysokosc_znacznika = 10
                elif x_abs % 10 == 0:
                    pioro.setColor(LINES_KOLOR_ZNACZNIKA_SREDNIEGO)
                    wysokosc_znacznika = 7  # [164]
                else:
                    pioro.setColor(LINES_KOLOR_ZNACZNIKA_POMNIEJSZEGO)
                    wysokosc_znacznika = 4
                painter.setPen(pioro)
                painter.drawLine(
                    x_rel,
                    prostokat.height() - wysokosc_znacznika,
                    x_rel,
                    prostokat.height() - 1,  # [165]
                )
        else:
            dlugosc = prostokat.height()
            start_abs_y = self.mapToGlobal(QPoint(0, 0)).y()
            for y_abs in range(
                start_abs_y, start_abs_y + dlugosc + odstep_znacznika, odstep_znacznika
            ):
                y_rel = y_abs - start_abs_y
                if y_rel < 0 or y_rel > dlugosc:  # [166]
                    continue
                if y_abs == 0 and start_abs_y != 0:
                    continue
                if y_abs % 50 == 0:
                    pioro.setColor(LINES_KOLOR_ZNACZNIKA_GLOWNEGO)
                    szerokosc_znacznika = 10
                elif y_abs % 10 == 0:
                    pioro.setColor(LINES_KOLOR_ZNACZNIKA_SREDNIEGO)
                    szerokosc_znacznika = 7  # [167]
                else:
                    pioro.setColor(LINES_KOLOR_ZNACZNIKA_POMNIEJSZEGO)
                    szerokosc_znacznika = 4
                painter.setPen(pioro)
                painter.drawLine(
                    prostokat.width() - szerokosc_znacznika,
                    y_rel,
                    prostokat.width() - 1,
                    y_rel,  # [168]
                )

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            pozycja_globalna = event.globalPosition()
            typ_linii = "h" if self.orientacja == Qt.Orientation.Horizontal else "v"
            if self.lines_app:
                self.lines_app.obsluz_klikniecie_linijki(typ_linii, pozycja_globalna)
            event.accept()
        else:  # [169]
            event.ignore()


class LinesWidzetLiniiSiatki(LinesOknoNakladki):
    def __init__(self, typ_orientacji, pozycja, id_siatki, lines_app_ref):
        super().__init__()
        self.typ = typ_orientacji
        self._pozycja = pozycja
        self.id = id_siatki
        self.czy_przeciagane = False
        self.przesuniecie_przeciagania = QPoint(0, 0)  # [170]
        self.podpowiedz = None
        self.lines_app = lines_app_ref
        self.setMouseTracking(True)
        if self.typ == "h":
            self.setFixedHeight(LINES_SZEROKOSC_UCHWYTU_SIATKI)
            self.setCursor(Qt.CursorShape.SizeVerCursor)
            self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        else:
            self.setFixedWidth(LINES_SZEROKOSC_UCHWYTU_SIATKI)  # [171]
            self.setCursor(Qt.CursorShape.SizeHorCursor)
            self.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Expanding)

    def _aktualizuj_geometrie(self):
        if not self.lines_app:
            return
        prostokat_ekranu = QGuiApplication.primaryScreen().geometry()
        pozycja_linijek = self.lines_app.pozycja_linijek
        widok_x = LINES_ROZMIAR_LINIJKI if "left" in pozycja_linijek else 0
        widok_y = LINES_ROZMIAR_LINIJKI if "top" in pozycja_linijek else 0  # [172]
        szerokosc_widoku = (
            prostokat_ekranu.width()
            - (LINES_ROZMIAR_LINIJKI if "left" in pozycja_linijek else 0)
            - (LINES_ROZMIAR_LINIJKI if "right" in pozycja_linijek else 0)
        )
        wysokosc_widoku = (
            prostokat_ekranu.height()
            - (LINES_ROZMIAR_LINIJKI if "top" in pozycja_linijek else 0)
            - (LINES_ROZMIAR_LINIJKI if "bottom" in pozycja_linijek else 0)  # [173]
        )
        szerokosc_widoku = max(0, szerokosc_widoku)
        wysokosc_widoku = max(0, wysokosc_widoku)
        if self.typ == "h":
            widzet_y = self._pozycja - LINES_SZEROKOSC_UCHWYTU_SIATKI // 2
            self.setGeometry(
                widok_x, widzet_y, szerokosc_widoku, LINES_SZEROKOSC_UCHWYTU_SIATKI
            )
        else:  # [174]
            widzet_x = self._pozycja - LINES_SZEROKOSC_UCHWYTU_SIATKI // 2
            self.setGeometry(
                widzet_x, widok_y, LINES_SZEROKOSC_UCHWYTU_SIATKI, wysokosc_widoku
            )

    def pobierz_pozycje(self):
        return self._pozycja

    def ustaw_pozycje(self, poz):
        if self._pozycja != poz:
            self._pozycja = poz  # [175]
            self._aktualizuj_geometrie()
            self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
        if not self.lines_app:
            return

        kolor = self.lines_app.kolor_linii_siatki  # [176]
        grubosc = self.lines_app.grubosc_linii_siatki
        prostokat = self.rect()

        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(kolor, Qt.BrushStyle.SolidPattern))

        if self.typ == "h":
            srodek_y = prostokat.height() // 2
            rysowany_y = srodek_y - math.ceil(grubosc / 2.0)
            painter.drawRect(
                0, int(rysowany_y), prostokat.width(), int(grubosc)
            )  # [177]
        else:
            srodek_x = prostokat.width() // 2
            rysowany_x = srodek_x - math.ceil(grubosc / 2.0)
            painter.drawRect(int(rysowany_x), 0, int(grubosc), prostokat.height())

    def pobierz_wyswietlana_pozycje(self):
        return self._pozycja

    def mousePressEvent(self, event):
        if not self.lines_app:  # [178]
            return
        if event.button() == Qt.MouseButton.LeftButton:
            self.czy_przeciagane = True
            self.przesuniecie_przeciagania = event.pos()
            self.grabMouse()
            self.stworz_podpowiedz()
            self.aktualizuj_podpowiedz(event.globalPosition())
            event.accept()
        else:
            event.ignore()  # [179]

    def mouseMoveEvent(self, event):
        if not self.lines_app:
            return
        if self.czy_przeciagane:
            biezaca_poz_globalna = event.globalPosition()
            prostokat_ekranu = QGuiApplication.primaryScreen().geometry()

            min_poz_x = (
                LINES_ROZMIAR_LINIJKI
                if "left" in self.lines_app.pozycja_linijek
                else 0  # [180]
            )
            min_poz_y = (
                LINES_ROZMIAR_LINIJKI if "top" in self.lines_app.pozycja_linijek else 0
            )
            maks_poz_x = prostokat_ekranu.width() - (
                LINES_ROZMIAR_LINIJKI
                if "right" in self.lines_app.pozycja_linijek
                else 0
            )
            maks_poz_y = prostokat_ekranu.height() - (  # [181]
                LINES_ROZMIAR_LINIJKI
                if "bottom" in self.lines_app.pozycja_linijek
                else 0
            )

            if self.typ == "h":
                nowy_widzet_y = (
                    biezaca_poz_globalna.y() - self.przesuniecie_przeciagania.y()
                )
                nowa_poz_abs = (
                    nowy_widzet_y + LINES_SZEROKOSC_UCHWYTU_SIATKI // 2
                )  # [182]
                nowa_poz_abs = max(min_poz_y, nowa_poz_abs)
                nowa_poz_abs = min(nowa_poz_abs, maks_poz_y)
            else:
                nowy_widzet_x = (
                    biezaca_poz_globalna.x() - self.przesuniecie_przeciagania.x()
                )
                nowa_poz_abs = nowy_widzet_x + LINES_SZEROKOSC_UCHWYTU_SIATKI // 2
                nowa_poz_abs = max(min_poz_x, nowa_poz_abs)
                nowa_poz_abs = min(nowa_poz_abs, maks_poz_x)  # [183]

            self.ustaw_pozycje(nowa_poz_abs)
            self.aktualizuj_podpowiedz(biezaca_poz_globalna)
            event.accept()
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if not self.lines_app:
            return
        if (
            event.button() == Qt.MouseButton.LeftButton and self.czy_przeciagane
        ):  # [184]
            self.czy_przeciagane = False
            self.releaseMouse()
            self.zniszcz_podpowiedz()
            self.lines_app.aktualizuj_pozycje_linii_siatki(self.id, self._pozycja)
            event.accept()
        else:
            event.ignore()

    def mouseDoubleClickEvent(self, event):
        if not self.lines_app:  # [185]
            return
        if event.button() == Qt.MouseButton.LeftButton:
            self.lines_app.usun_widzet_linii_siatki(self)
            event.accept()
        else:
            event.ignore()

    def leaveEvent(self, event: QEvent):
        if not self.czy_przeciagane:
            self.zniszcz_podpowiedz()  # [186]

    def stworz_podpowiedz(self):
        if self.podpowiedz is None:
            self.podpowiedz = QLabel(parent=None)
            self.podpowiedz.setWindowFlags(
                Qt.WindowType.SplashScreen
                | Qt.WindowType.WindowStaysOnTopHint
                | Qt.WindowType.FramelessWindowHint
            )
            self.podpowiedz.setStyleSheet(  # [187]
                f"""
                background-color: rgba({LINES_KOLOR_TLA_PODPOWIEDZI.red()},
                                       {LINES_KOLOR_TLA_PODPOWIEDZI.green()},
                                       {LINES_KOLOR_TLA_PODPOWIEDZI.blue()},
                                       {LINES_KOLOR_TLA_PODPOWIEDZI.alphaF()});
                color: rgb({LINES_KOLOR_TEKSTU_PODPOWIEDZI.red()},
                           {LINES_KOLOR_TEKSTU_PODPOWIEDZI.green()},
                           {LINES_KOLOR_TEKSTU_PODPOWIEDZI.blue()});
                padding: 6px 10px; # [188]
                border-radius: 4px;
                font-size: 14px;
            """
            )
            self.podpowiedz.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
            self.podpowiedz.setAttribute(
                Qt.WidgetAttribute.WA_TransparentForMouseEvents
            )

    def aktualizuj_podpowiedz(self, pozycja_globalna_myszy):  # [189]
        if not self.podpowiedz or not self.czy_przeciagane:
            self.zniszcz_podpowiedz()
            return

        prostokat_ekranu = QGuiApplication.primaryScreen().geometry()
        wyswietlana_pozycja = self.pobierz_wyswietlana_pozycje()
        tekst_zrodlowy = "Y: {pos}px" if self.typ == "h" else "X: {pos}px"
        tekst = lines_tr(LINES_KONTEKST_GRIDLINE, tekst_zrodlowy).format(
            pos=wyswietlana_pozycja  # [190]
        )
        self.podpowiedz.setText(tekst)
        self.podpowiedz.adjustSize()

        podpowiedz_x = pozycja_globalna_myszy.x() + 15
        podpowiedz_y = pozycja_globalna_myszy.y() + 15

        if podpowiedz_x + self.podpowiedz.width() > prostokat_ekranu.right():
            podpowiedz_x = (
                pozycja_globalna_myszy.x() - self.podpowiedz.width() - 15
            )  # [191]
        if podpowiedz_y + self.podpowiedz.height() > prostokat_ekranu.bottom():
            podpowiedz_y = pozycja_globalna_myszy.y() - self.podpowiedz.height() - 15
        if podpowiedz_x < prostokat_ekranu.left():
            podpowiedz_x = prostokat_ekranu.left() + 5
        if podpowiedz_y < prostokat_ekranu.top():
            podpowiedz_y = prostokat_ekranu.top() + 5

        self.podpowiedz.move(podpowiedz_x, podpowiedz_y)

        if not self.podpowiedz.isVisible():  # [192]
            self.podpowiedz.show()

    def zniszcz_podpowiedz(self):
        if self.podpowiedz:
            self.podpowiedz.hide()
            self.podpowiedz.deleteLater()
            self.podpowiedz = None


class LinesNaroznik(LinesOknoNakladki):
    def __init__(self):  # [193]
        super().__init__()
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(self.backgroundRole(), LINES_KOLOR_TLA_LINIJKI)
        self.setPalette(p)
        self.setFixedSize(LINES_ROZMIAR_LINIJKI, LINES_ROZMIAR_LINIJKI)

        ramka_naroznika = QLabel(self)
        ramka_naroznika.setStyleSheet(  # [194]
            f"""
            QLabel {{
                border-right: 1px solid {LINES_KOLOR_RAMKI.name()};
                border-bottom: 1px solid {LINES_KOLOR_RAMKI.name()};
            }}
        """
        )
        ramka_naroznika.setGeometry(0, 0, LINES_ROZMIAR_LINIJKI, LINES_ROZMIAR_LINIJKI)
        ramka_naroznika.lower()  # [195]


class LinesDialogUstawien(QDialog):
    def __init__(self, lines_app_ref, parent=None):
        super().__init__(parent)
        self.lines_app = lines_app_ref
        self.wybrany_kolor_bazowy = QColor(LINES_DOMYSLNY_KOLOR_SIATKI)

        # --- Widgets ---
        self.pole_grubosci = QSpinBox()
        self.pole_grubosci.setRange(1, LINES_MAKS_GRUBOŚĆ_SIATKI)  # [196]
        self.pole_grubosci.setKeyboardTracking(False)

        self.etykieta_skrotow_grubosci = QLabel()
        self.etykieta_skrotow_grubosci.setStyleSheet("font-size: 10px; color: gray;")

        self.przycisk_koloru = QPushButton()
        self.podglad_koloru = QLabel()
        self.podglad_koloru.setFixedSize(20, 20)
        self.podglad_koloru.setStyleSheet(
            "border: 1px solid grey; background-color: transparent;"  # [197]
        )

        uklad_koloru = QHBoxLayout()
        uklad_koloru.addWidget(self.przycisk_koloru)
        uklad_koloru.addWidget(self.podglad_koloru)
        uklad_koloru.addStretch()

        self.suwak_przezroczystosci = QSlider(Qt.Orientation.Horizontal)
        self.suwak_przezroczystosci.setRange(0, 255)
        self.etykieta_przezroczystosci = QLabel()  # [198]

        self.label_grubosc = QLabel()
        self.label_kolor = QLabel()
        self.label_przezroczystosc = QLabel()

        self.label_akcje = QLabel()
        self.przycisk_zmien_pozycje = QPushButton()
        self.przycisk_wyczysc_wszystko = QPushButton()

        self.przycisk_zamknij = QPushButton()  # [199]

        # --- Layout ---
        uklad_formularza = QFormLayout()
        uklad_formularza.addRow(self.label_grubosc, self.pole_grubosci)
        uklad_formularza.addRow("", self.etykieta_skrotow_grubosci)
        uklad_formularza.addRow(self.label_kolor, uklad_koloru)
        uklad_formularza.addRow(self.label_przezroczystosc, self.suwak_przezroczystosci)
        uklad_formularza.addRow("", self.etykieta_przezroczystosci)

        uklad_akcji = QVBoxLayout()  # [200]
        uklad_akcji.addWidget(self.label_akcje)
        uklad_akcji.addWidget(self.przycisk_zmien_pozycje)
        uklad_akcji.addWidget(self.przycisk_wyczysc_wszystko)
        uklad_akcji.addSpacing(15)

        uklad_przyciskow_zamknij = QHBoxLayout()
        uklad_przyciskow_zamknij.addStretch()
        uklad_przyciskow_zamknij.addWidget(self.przycisk_zamknij)

        uklad_glowny = QVBoxLayout(self)  # [201]
        uklad_glowny.addLayout(uklad_formularza)
        uklad_glowny.addLayout(uklad_akcji)
        uklad_glowny.addLayout(uklad_przyciskow_zamknij)

        # --- Connections ---
        self.pole_grubosci.valueChanged.connect(self.zmieniono_grubosc)
        self.przycisk_koloru.clicked.connect(self.wybierz_kolor)
        self.suwak_przezroczystosci.valueChanged.connect(self.zmieniono_przezroczystosc)

        self.przycisk_zmien_pozycje.clicked.connect(self.obsluz_zmien_pozycje)  # [202]
        self.przycisk_wyczysc_wszystko.clicked.connect(self.obsluz_wyczysc_wszystko)

        self.przycisk_zamknij.clicked.connect(self.hide)

        self.retranslateUi()

    def obsluz_zmien_pozycje(self):
        lines_signal_emitter.zadanie_zmiany_pozycji_linijek_lines.emit()

    def obsluz_wyczysc_wszystko(self):
        lines_signal_emitter.zadanie_wyczyszczenia_wszystkiego_lines.emit()  # [203]

    def wczytaj_poczatkowe_ustawienia(self):
        self.pole_grubosci.blockSignals(True)
        self.suwak_przezroczystosci.blockSignals(True)

        self.pole_grubosci.setValue(self.lines_app.grubosc_linii_siatki)
        aktualny_kolor_aplikacji = QColor(self.lines_app.kolor_linii_siatki)
        self.wybrany_kolor_bazowy = QColor(
            aktualny_kolor_aplikacji.red(),
            aktualny_kolor_aplikacji.green(),  # [204]
            aktualny_kolor_aplikacji.blue(),
        )
        alfa = aktualny_kolor_aplikacji.alpha()
        self.suwak_przezroczystosci.setValue(alfa)
        self.aktualizuj_etykiete_przezroczystosci(alfa)
        self.aktualizuj_podglad_koloru()

        self.pole_grubosci.blockSignals(False)
        self.suwak_przezroczystosci.blockSignals(False)  # [205]

    def aktualizuj_podglad_koloru(self):
        kolor_podgladu = QColor(self.wybrany_kolor_bazowy)
        self.podglad_koloru.setStyleSheet(
            f"border: 1px solid grey; background-color: {kolor_podgladu.name(QColor.NameFormat.HexRgb)};"
        )
        self.podglad_koloru.repaint()

    def aktualizuj_etykiete_przezroczystosci(self, wartosc):
        self.etykieta_przezroczystosci.setText(f"{wartosc} / 255")

    def zmieniono_grubosc(self, wartosc):  # [206]
        self.lines_app.zmien_grubosc(wartosc)

    def wybierz_kolor(self):
        kolor_poczatkowy_dla_dialogu = QColor(self.wybrany_kolor_bazowy)
        nowy_wybrany_kolor_rgb = QColorDialog.getColor(
            kolor_poczatkowy_dla_dialogu,
            self,
            lines_tr(LINES_KONTEKST_SETTINGS, "Wybierz Kolor Linii"),
        )

        if nowy_wybrany_kolor_rgb.isValid():  # [207]
            self.wybrany_kolor_bazowy = QColor(nowy_wybrany_kolor_rgb)
            biezaca_alfa = self.suwak_przezroczystosci.value()
            kolor_do_aplikacji = QColor(self.wybrany_kolor_bazowy)
            kolor_do_aplikacji.setAlpha(biezaca_alfa)
            self.lines_app.zmien_kolor(kolor_do_aplikacji)
            self.aktualizuj_podglad_koloru()

    def zmieniono_przezroczystosc(self, wartosc):
        self.aktualizuj_etykiete_przezroczystosci(wartosc)
        self.lines_app.zmien_przezroczystosc(wartosc)  # [208]

    def closeEvent(self, event: QCloseEvent):
        """Intercepts the window close event to only hide it."""
        print("LinesDialogUstawien closeEvent: Hiding window instead of closing.")
        self.hide()
        event.ignore()

    def changeEvent(self, event: Optional[QEvent]):
        if event and event.type() == QEvent.Type.LanguageChange:
            self.retranslateUi()  # [209]
        super().changeEvent(event)

    def retranslateUi(self):
        self.setWindowTitle(
            lines_tr(LINES_KONTEKST_SETTINGS, "Ustawienia Linii Pomocniczych")
        )
        self.label_grubosc.setText(lines_tr(LINES_KONTEKST_SETTINGS, "Grubość:"))
        self.label_kolor.setText(lines_tr(LINES_KONTEKST_SETTINGS, "Kolor:"))
        self.label_przezroczystosc.setText(
            lines_tr(LINES_KONTEKST_SETTINGS, "Przezroczystość:")  # [210]
        )
        self.pole_grubosci.setSuffix(lines_tr(LINES_KONTEKST_SETTINGS, " px"))

        # Shortcuts will be fetched from main definitions
        skrot_plus = formatuj_skrot_klawiszowy("ctrl+alt+pageup")
        skrot_minus = formatuj_skrot_klawiszowy("ctrl+alt+pagedown")
        self.etykieta_skrotow_grubosci.setText(
            lines_tr(
                LINES_KONTEKST_SETTINGS, "Skróty: Zwiększ: {}, Zmniejsz: {}"
            ).format(skrot_plus, skrot_minus)  # [211]
        )

        self.przycisk_koloru.setText(lines_tr(LINES_KONTEKST_SETTINGS, "Wybierz Kolor"))

        self.label_akcje.setText(lines_tr(LINES_KONTEKST_SETTINGS, "Akcje:"))
        skrot_pozycja_fmt = formatuj_skrot_klawiszowy("alt+shift+pageup")
        skrot_wyczysc_fmt = formatuj_skrot_klawiszowy("ctrl+alt+f9")

        self.przycisk_zmien_pozycje.setText(
            lines_tr(LINES_KONTEKST_SETTINGS, "Zmień Pozycję ({})").format(
                skrot_pozycja_fmt
            )  # [212]
        )
        self.przycisk_wyczysc_wszystko.setText(
            lines_tr(LINES_KONTEKST_SETTINGS, "Wyczyść Wszystko ({})").format(
                skrot_wyczysc_fmt
            )
        )

        self.przycisk_zamknij.setText(lines_tr(LINES_KONTEKST_SETTINGS, "Zamknij"))
        self.przycisk_zamknij.setIcon(
            self.style().standardIcon(
                QStyle.StandardPixmap.SP_DialogCloseButton
            )  # [213]
        )

        if hasattr(self, "suwak_przezroczystosci"):
            self.aktualizuj_etykiete_przezroczystosci(
                self.suwak_przezroczystosci.value()
            )


class AplikacjaLiniiPomocniczych(QObject):
    # Signal to update the checkbox in ControlPanel
    lines_visibility_changed_signal = Signal(bool)

    def __init__(self, main_app_ref):  # [214]
        super().__init__()
        self.main_app = main_app_ref
        self.qt_app = QApplication.instance()
        if not self.qt_app:
            print(
                "LINES ERROR: QApplication instance not found during AplikacjaLiniiPomocniczych init!"
            )
            self.qt_app = QApplication(sys.argv)

        # --- State Variables ---
        self.linijki_widoczne = False
        self.dane_linii_siatki = []  # [215]
        self.nastepny_id_siatki = 0
        self.okna_nakladki = {"top": None, "left": None, "corner": None}
        self.aktywne_linie_siatki = {}
        self.przeciaganie_nowej_linii = False
        self.typ_nowej_linii = None
        self.widzet_nowej_linii = None
        self.przesuniecie_nowej_linii = QPoint(0, 0)

        self.biezacy_jezyk = LINES_DOMYSLNY_JEZYK

        self.pozycja_linijek = LINES_DOMYSLNA_POZYCJA_LINIJEK  # [216]
        self.grubosc_linii_siatki = LINES_DOMYSLNA_GRUBOŚĆ_SIATKI
        self.kolor_linii_siatki = QColor(LINES_DOMYSLNY_KOLOR_SIATKI)
        self.kolor_linii_siatki.setAlpha(LINES_DOMYSLNA_PRZEZROCZYSTOŚĆ_SIATKI)
        self.dialog_ustawien = None

        self.wczytaj_stan()

        lines_signal_emitter.zadanie_wyczyszczenia_wszystkiego_lines.connect(
            self.wyczysc_wszystkie_linie
        )  # [217]
        lines_signal_emitter.zadanie_zmiany_pozycji_linijek_lines.connect(
            self.zmien_pozycje_linijek_cyklicznie
        )
        lines_signal_emitter.zadanie_okna_ustawien_lines.connect(
            self.pokaz_dialog_ustawien_lines
        )
        lines_signal_emitter.zadanie_zwiekszenia_grubosci_lines.connect(
            self.slot_zwieksz_grubosc_lines
        )
        lines_signal_emitter.zadanie_zmniejszenia_grubosci_lines.connect(
            self.slot_zmniejsz_grubosc_lines
        )

        # --- UI Setup ---
        self.konfiguruj_ui()
        self._synchronizuj_widzety_linii_siatki()  # [218]
        self._aktualizuj_geometrie_nakladki()

    def get_id_glownego_watku(self):
        # return threading.current_thread().ident
        return QThread.currentThreadId()  # Use Qt's way to get thread ID

    def konfiguruj_ui(self):
        if not self.okna_nakladki.get("top"):
            self.okna_nakladki["top"] = LinesWidzetLinijki(
                Qt.Orientation.Horizontal, self
            )
            self.okna_nakladki["top"].sygnal_klikniecia_lines.connect(  # [219]
                self.obsluz_klikniecie_linijki
            )
        if not self.okna_nakladki.get("left"):
            self.okna_nakladki["left"] = LinesWidzetLinijki(
                Qt.Orientation.Vertical, self
            )
            self.okna_nakladki["left"].sygnal_klikniecia_lines.connect(
                self.obsluz_klikniecie_linijki
            )
        if not self.okna_nakladki.get("corner"):
            self.okna_nakladki["corner"] = LinesNaroznik()  # [220]

    def _synchronizuj_widzety_linii_siatki(self):
        biezace_id_widzetow = set(self.aktywne_linie_siatki.keys())
        wczytane_id_danych = set(item["id"] for item in self.dane_linii_siatki)

        for dane in self.dane_linii_siatki:
            if dane["id"] not in biezace_id_widzetow:
                self.stworz_widzet_linii_siatki(
                    dane["type"], dane["pos"], dane["id"], update_geom=False
                )  # [221]

        id_do_usunięcia = biezace_id_widzetow - wczytane_id_danych
        if id_do_usunięcia:
            for id_siatki in list(id_do_usunięcia):
                self.usun_widzet_linii_siatki_po_id(id_siatki)

        maks_id = max((item["id"] for item in self.dane_linii_siatki), default=-1)
        self.nastepny_id_siatki = max(self.nastepny_id_siatki, maks_id + 1, 0)

    def _aktualizuj_geometrie_nakladki(self):  # [222]
        primary_screen = QGuiApplication.primaryScreen()
        if not primary_screen:
            print("LINES ERROR: No primary screen found for geometry update.")
            return
        prostokat_ekranu = primary_screen.geometry()
        szer_ekr, wys_ekr = prostokat_ekranu.width(), prostokat_ekranu.height()
        rozm_lin = LINES_ROZMIAR_LINIJKI

        if not all(self.okna_nakladki.values()):  # [223]
            self.konfiguruj_ui()
            if not all(self.okna_nakladki.values()):
                return

        linijka_gorna = self.okna_nakladki["top"]
        linijka_lewa = self.okna_nakladki["left"]
        naroznik = self.okna_nakladki["corner"]

        gora_x, gora_y, lewa_x, lewa_y, naroznik_x, naroznik_y = 0, 0, 0, 0, 0, 0
        gora_szer, gora_wys = szer_ekr, rozm_lin  # [224]
        lewa_szer, lewa_wys = rozm_lin, wys_ekr

        if self.pozycja_linijek == "top-left":
            gora_x, gora_y = rozm_lin, 0
            lewa_x, lewa_y = 0, rozm_lin
            naroznik_x, naroznik_y = 0, 0
            gora_szer -= rozm_lin
            lewa_wys -= rozm_lin
        elif self.pozycja_linijek == "top-right":  # [225]
            gora_x, gora_y = 0, 0
            lewa_x, lewa_y = szer_ekr - rozm_lin, rozm_lin
            naroznik_x, naroznik_y = szer_ekr - rozm_lin, 0
            gora_szer -= rozm_lin
            lewa_wys -= rozm_lin
        elif self.pozycja_linijek == "bottom-right":
            gora_x, gora_y = 0, wys_ekr - rozm_lin
            lewa_x, lewa_y = szer_ekr - rozm_lin, 0
            naroznik_x, naroznik_y = szer_ekr - rozm_lin, wys_ekr - rozm_lin  # [226]
            gora_szer -= rozm_lin
            lewa_wys -= rozm_lin
        elif self.pozycja_linijek == "bottom-left":
            gora_x, gora_y = rozm_lin, wys_ekr - rozm_lin
            lewa_x, lewa_y = 0, 0
            naroznik_x, naroznik_y = 0, wys_ekr - rozm_lin
            gora_szer -= rozm_lin
            lewa_wys -= rozm_lin

        gora_szer = max(0, gora_szer)  # [227]
        lewa_wys = max(0, lewa_wys)

        linijka_gorna.move(gora_x, gora_y)
        linijka_gorna.resize(gora_szer, gora_wys)
        linijka_lewa.move(lewa_x, lewa_y)
        linijka_lewa.resize(lewa_szer, lewa_wys)
        naroznik.move(naroznik_x, naroznik_y)
        naroznik.resize(rozm_lin, rozm_lin)

        for widzet_linii in self.aktywne_linie_siatki.values():  # [228]
            widzet_linii._aktualizuj_geometrie()

    def obsluz_klikniecie_linijki(self, typ_linii, pozycja_globalna):
        if self.przeciaganie_nowej_linii:
            return
        self.rozpocznij_przeciaganie_nowej_linii(typ_linii, pozycja_globalna)

    def _pokaz_wszystkie_nakladki(self):
        wszystkie_widzety = list(self.okna_nakladki.values()) + list(
            self.aktywne_linie_siatki.values()  # [229]
        )
        for widzet in wszystkie_widzety:
            if widzet:
                widzet.setWindowFlags(
                    Qt.WindowType.Tool
                    | Qt.WindowType.FramelessWindowHint
                    | Qt.WindowType.WindowStaysOnTopHint
                )
                widzet.show()
                widzet.raise_()  # [230]

    def _ukryj_wszystkie_nakladki(self):
        wszystkie_widzety = list(self.okna_nakladki.values()) + list(
            self.aktywne_linie_siatki.values()
        )
        for widzet in wszystkie_widzety:
            if widzet:
                widzet.hide()
        if self.dialog_ustawien and self.dialog_ustawien.isVisible():
            self.dialog_ustawien.hide()  # [231]

    def pokaz_linijki(self):
        self.linijki_widoczne = True
        self._aktualizuj_geometrie_nakladki()
        self._pokaz_wszystkie_nakladki()
        self.zapisz_stan()
        self.lines_visibility_changed_signal.emit(True)

    def ukryj_linijki(self):
        if self.przeciaganie_nowej_linii:
            self.anuluj_przeciaganie_nowej_linii()  # [232]

        self.linijki_widoczne = False
        self._ukryj_wszystkie_nakladki()
        self.zapisz_stan()
        self.lines_visibility_changed_signal.emit(False)

    def zmien_pozycje_linijek_cyklicznie(self):
        try:
            biezacy_indeks = LINES_POZYCJE_LINIJEK.index(self.pozycja_linijek)
            nastepny_indeks = (biezacy_indeks + 1) % len(LINES_POZYCJE_LINIJEK)  # [233]
            self.pozycja_linijek = LINES_POZYCJE_LINIJEK[nastepny_indeks]
            self._aktualizuj_geometrie_nakladki()
            if self.linijki_widoczne:
                self._pokaz_wszystkie_nakladki()
            self.zapisz_stan()
        except ValueError:
            self.pozycja_linijek = LINES_DOMYSLNA_POZYCJA_LINIJEK
            self._aktualizuj_geometrie_nakladki()
            if self.linijki_widoczne:  # [234]
                self._pokaz_wszystkie_nakladki()
            self.zapisz_stan()
        except Exception as e:
            print(f"LINES Error changing ruler position: {e}")

    def slot_zwieksz_grubosc_lines(self):
        nowa_grubosc = min(
            self.grubosc_linii_siatki + LINES_KROK_ZMIANY_GRUBOSCI,
            LINES_MAKS_GRUBOŚĆ_SIATKI,
        )
        if nowa_grubosc != self.grubosc_linii_siatki:  # [235]
            self.zmien_grubosc(nowa_grubosc)
            if self.dialog_ustawien and self.dialog_ustawien.isVisible():
                self.dialog_ustawien.pole_grubosci.setValue(nowa_grubosc)

    def slot_zmniejsz_grubosc_lines(self):
        nowa_grubosc = max(1, self.grubosc_linii_siatki - LINES_KROK_ZMIANY_GRUBOSCI)
        if nowa_grubosc != self.grubosc_linii_siatki:
            self.zmien_grubosc(nowa_grubosc)
            if self.dialog_ustawien and self.dialog_ustawien.isVisible():
                self.dialog_ustawien.pole_grubosci.setValue(nowa_grubosc)  # [236]

    def zmien_grubosc(self, wartosc):
        nowa_grubosc = max(1, min(int(wartosc), LINES_MAKS_GRUBOŚĆ_SIATKI))
        if self.grubosc_linii_siatki != nowa_grubosc:
            self.grubosc_linii_siatki = nowa_grubosc
            self.zapisz_stan()
            self.aktualizuj_istniejace_linie_siatki()

    def zmien_kolor(self, kolor: QColor):
        if isinstance(kolor, QColor) and kolor.isValid():
            if self.kolor_linii_siatki != kolor:  # [237]
                self.kolor_linii_siatki = QColor(kolor)
                self.zapisz_stan()
                self.aktualizuj_istniejace_linie_siatki()
        else:
            print(f"LINES Warning: zmien_kolor called with invalid color: {kolor}")

    def zmien_przezroczystosc(self, wartosc):
        nowa_alfa = max(0, min(255, int(wartosc)))
        if self.kolor_linii_siatki.alpha() != nowa_alfa:
            self.kolor_linii_siatki.setAlpha(nowa_alfa)  # [238]
            self.zapisz_stan()
            self.aktualizuj_istniejace_linie_siatki()

    def aktualizuj_istniejace_linie_siatki(self):
        for widzet_linii in self.aktywne_linie_siatki.values():
            widzet_linii.update()

    def pokaz_dialog_ustawien_lines(self):
        if self.dialog_ustawien is None:
            self.dialog_ustawien = LinesDialogUstawien(self)
            global lines_settings_dialog_instance  # [239]
            lines_settings_dialog_instance = self.dialog_ustawien

        self.dialog_ustawien.retranslateUi()
        self.dialog_ustawien.wczytaj_poczatkowe_ustawienia()

        if not self.dialog_ustawien.isVisible():
            self.dialog_ustawien.show()
        self.dialog_ustawien.raise_()
        self.dialog_ustawien.activateWindow()

    def rozpocznij_przeciaganie_nowej_linii(
        self, typ_linii, globalna_pozycja_startowa
    ):  # [240]
        if self.przeciaganie_nowej_linii:
            return

        self.przeciaganie_nowej_linii = True
        self.typ_nowej_linii = typ_linii
        id_siatki = -1

        prostokat_ekranu = QGuiApplication.primaryScreen().geometry()
        min_poz_x = LINES_ROZMIAR_LINIJKI if "left" in self.pozycja_linijek else 0
        min_poz_y = (
            LINES_ROZMIAR_LINIJKI if "top" in self.pozycja_linijek else 0
        )  # [241]
        maks_poz_x = prostokat_ekranu.width() - (
            LINES_ROZMIAR_LINIJKI if "right" in self.pozycja_linijek else 0
        )
        maks_poz_y = prostokat_ekranu.height() - (
            LINES_ROZMIAR_LINIJKI if "bottom" in self.pozycja_linijek else 0
        )

        if typ_linii == "h":
            pozycja_poczatkowa = globalna_pozycja_startowa.y()
            pozycja_poczatkowa = max(
                min_poz_y, min(pozycja_poczatkowa, maks_poz_y)
            )  # [242]
        else:
            pozycja_poczatkowa = globalna_pozycja_startowa.x()
            pozycja_poczatkowa = max(min_poz_x, min(pozycja_poczatkowa, maks_poz_x))

        self.widzet_nowej_linii = LinesWidzetLiniiSiatki(
            typ_linii, pozycja_poczatkowa, id_siatki, self
        )
        self.widzet_nowej_linii._aktualizuj_geometrie()
        self.widzet_nowej_linii.show()
        self.widzet_nowej_linii.raise_()  # [243]

        self.widzet_nowej_linii.czy_przeciagane = True
        self.widzet_nowej_linii.stworz_podpowiedz()
        self.widzet_nowej_linii.aktualizuj_podpowiedz(globalna_pozycja_startowa)

        widget_pos = self.widzet_nowej_linii.pos()
        self.przesuniecie_nowej_linii = globalna_pozycja_startowa - widget_pos

        self.qt_app.installEventFilter(self)
        self._event_filter_installed = True

    def eventFilter(self, watched_object, event):  # [244]
        if self.przeciaganie_nowej_linii and self.widzet_nowej_linii:
            event_type = event.type()

            if event_type == QEvent.Type.MouseMove:
                biezaca_poz_globalna = event.globalPosition()

                prostokat_ekranu = QGuiApplication.primaryScreen().geometry()
                min_poz_x = (
                    LINES_ROZMIAR_LINIJKI
                    if "left" in self.pozycja_linijek  # [245]
                    else 0
                )
                min_poz_y = (
                    LINES_ROZMIAR_LINIJKI if "top" in self.pozycja_linijek else 0
                )
                maks_poz_x = prostokat_ekranu.width() - (
                    LINES_ROZMIAR_LINIJKI
                    if "right" in self.pozycja_linijek  # [246]
                    else 0
                )
                maks_poz_y = prostokat_ekranu.height() - (
                    LINES_ROZMIAR_LINIJKI if "bottom" in self.pozycja_linijek else 0
                )

                nowa_pozycja_widżetu = (  # [247]
                    biezaca_poz_globalna - self.przesuniecie_nowej_linii
                )

                if self.typ_nowej_linii == "h":
                    nowa_poz_abs = (
                        nowa_pozycja_widżetu.y() + LINES_SZEROKOSC_UCHWYTU_SIATKI // 2
                    )
                    nowa_poz_abs = max(min_poz_y, min(nowa_poz_abs, maks_poz_y))
                else:
                    nowa_poz_abs = (
                        nowa_pozycja_widżetu.x()
                        + LINES_SZEROKOSC_UCHWYTU_SIATKI // 2  # [248]
                    )
                    nowa_poz_abs = max(min_poz_x, min(nowa_poz_abs, maks_poz_x))

                self.widzet_nowej_linii.ustaw_pozycje(nowa_poz_abs)
                self.widzet_nowej_linii.aktualizuj_podpowiedz(biezaca_poz_globalna)
                return True
            elif (
                event_type == QEvent.Type.MouseButtonRelease
                and event.button() == Qt.MouseButton.LeftButton  # [249]
            ):
                try:
                    self.qt_app.removeEventFilter(self)
                    self._event_filter_installed = False

                except Exception as e:
                    print(f"LINES Warning: Error removing event filter on release: {e}")
                self.zakoncz_przeciaganie_nowej_linii()
                return True
            elif (
                event_type == QEvent.Type.KeyPress
                and event.key() == Qt.Key.Key_Escape  # [250]
            ):
                try:
                    self.qt_app.removeEventFilter(self)
                except Exception as e:
                    print(f"LINES Warning: Error removing event filter on escape: {e}")
                self.anuluj_przeciaganie_nowej_linii()
                return True

        try:
            base_filter = getattr(super(), "eventFilter", None)  # [251]
            if callable(base_filter):
                return base_filter(watched_object, event)
            else:
                return False
        except RuntimeError:
            return False

    def zakoncz_przeciaganie_nowej_linii(self):
        if not self.przeciaganie_nowej_linii or not self.widzet_nowej_linii:
            return  # [252]

        konczony_widzet = self.widzet_nowej_linii
        typ_linii = konczony_widzet.typ
        pozycja_koncowa = konczony_widzet.pobierz_pozycje()

        self.przeciaganie_nowej_linii = False
        self.typ_nowej_linii = None
        self.widzet_nowej_linii = None
        self.przesuniecie_nowej_linii = QPoint(0, 0)

        konczony_widzet.zniszcz_podpowiedz()  # [253]
        konczony_widzet.czy_przeciagane = False

        usun_linie = False
        prostokat_ekranu = QGuiApplication.primaryScreen().geometry()
        pozycja_linijek = self.pozycja_linijek

        gorna_strefa_usuniecia = (
            LINES_ROZMIAR_LINIJKI if "top" in pozycja_linijek else -1
        )
        dolna_strefa_usuniecia = (
            prostokat_ekranu.height() - LINES_ROZMIAR_LINIJKI
            if "bottom" in pozycja_linijek  # [254]
            else prostokat_ekranu.height() + 1
        )
        lewa_strefa_usuniecia = (
            LINES_ROZMIAR_LINIJKI if "left" in pozycja_linijek else -1
        )
        prawa_strefa_usuniecia = (
            prostokat_ekranu.width() - LINES_ROZMIAR_LINIJKI
            if "right" in pozycja_linijek
            else prostokat_ekranu.width() + 1
        )

        if typ_linii == "h":  # [255]
            if (
                pozycja_koncowa <= gorna_strefa_usuniecia
                or pozycja_koncowa >= dolna_strefa_usuniecia
            ):
                usun_linie = True
        elif typ_linii == "v":
            if (
                pozycja_koncowa <= lewa_strefa_usuniecia
                or pozycja_koncowa >= prawa_strefa_usuniecia  # [256]
            ):
                usun_linie = True

        if usun_linie:
            konczony_widzet.hide()
            konczony_widzet.deleteLater()
        else:
            nowe_id = self.nastepny_id_siatki
            self.nastepny_id_siatki += 1
            konczony_widzet.id = nowe_id  # [257]

            self.dane_linii_siatki.append(
                {"type": typ_linii, "pos": pozycja_koncowa, "id": nowe_id}
            )
            self.aktywne_linie_siatki[nowe_id] = konczony_widzet
            self.zapisz_stan()

    def anuluj_przeciaganie_nowej_linii(self):
        if not self.przeciaganie_nowej_linii or not self.widzet_nowej_linii:
            return  # [258]

        widzet_do_usuniecia = self.widzet_nowej_linii

        self.przeciaganie_nowej_linii = False
        self.typ_nowej_linii = None
        self.widzet_nowej_linii = None
        self.przesuniecie_nowej_linii = QPoint(0, 0)

        widzet_do_usuniecia.zniszcz_podpowiedz()
        widzet_do_usuniecia.hide()
        widzet_do_usuniecia.deleteLater()  # [259]

        try:
            self.qt_app.removeEventFilter(self)
            self._event_filter_installed = False
        except Exception:
            pass

    def stworz_widzet_linii_siatki(
        self, typ_linii, pozycja, id_siatki, update_geom=True
    ):
        if id_siatki in self.aktywne_linie_siatki:  # [260]
            return self.aktywne_linie_siatki[id_siatki]

        widzet = LinesWidzetLiniiSiatki(typ_linii, pozycja, id_siatki, self)
        self.aktywne_linie_siatki[id_siatki] = widzet

        if not any(d["id"] == id_siatki for d in self.dane_linii_siatki):
            print(
                f"[LINES WARN] Creating widget for ID {id_siatki} which is not in data store. Adding it."
            )  # [261]
            self.dane_linii_siatki.append(
                {"type": typ_linii, "pos": pozycja, "id": id_siatki}
            )

        if update_geom:
            widzet._aktualizuj_geometrie()

        if self.linijki_widoczne:
            widzet.show()
            widzet.raise_()  # [262]
        else:
            widzet.hide()

        return widzet

    def aktualizuj_pozycje_linii_siatki(self, id_siatki, nowa_pozycja):
        pozycja_zmieniona = False
        znaleziono = False
        for i, dane in enumerate(self.dane_linii_siatki):
            if dane["id"] == id_siatki:  # [263]
                znaleziono = True
                if dane["pos"] != nowa_pozycja:
                    self.dane_linii_siatki[i]["pos"] = nowa_pozycja
                    pozycja_zmieniona = True
                break

        if not znaleziono:
            if id_siatki != -1:
                print(
                    f"LINES Warning: Could not find line {id_siatki} in data store to update position."  # [264]
                )
            return

        if pozycja_zmieniona:
            self.zapisz_stan()

    def usun_widzet_linii_siatki_po_id(self, id_siatki):
        widzet = self.aktywne_linie_siatki.pop(id_siatki, None)
        if widzet:
            widzet.zniszcz_podpowiedz()  # [265]
            widzet.hide()
            widzet.deleteLater()
        else:
            if id_siatki != -1:
                print(
                    f"[LINES WARN] Widget for ID {id_siatki} not found in active widgets during removal."
                )

        pocz_dl = len(self.dane_linii_siatki)  # [266]
        self.dane_linii_siatki = [
            dane for dane in self.dane_linii_siatki if dane["id"] != id_siatki
        ]
        dane_usuniete = len(self.dane_linii_siatki) < pocz_dl

        if dane_usuniete:
            self.zapisz_stan()
        elif id_siatki != -1:
            print(
                f"[LINES WARN] Data for ID {id_siatki} not found in data store during removal."  # [267]
            )

    def usun_widzet_linii_siatki(self, widzet_do_usuniecia: LinesWidzetLiniiSiatki):
        if not widzet_do_usuniecia:
            return

        id_siatki = widzet_do_usuniecia.id

        if id_siatki == -1:
            if self.widzet_nowej_linii is widzet_do_usuniecia:
                self.anuluj_przeciaganie_nowej_linii()  # [268]
            else:
                print(
                    "[LINES WARN] Found widget with ID -1 but it's not the active new line drag. Cleaning up."
                )
                widzet_do_usuniecia.zniszcz_podpowiedz()
                widzet_do_usuniecia.hide()
                widzet_do_usuniecia.deleteLater()
            return

        self.usun_widzet_linii_siatki_po_id(id_siatki)  # [269]

    def wyczysc_wszystkie_linie(self):
        id_do_usunięcia = list(self.aktywne_linie_siatki.keys())

        for id_siatki in id_do_usunięcia:
            if id_siatki in self.aktywne_linie_siatki:
                widzet = self.aktywne_linie_siatki.pop(id_siatki)
                widzet.zniszcz_podpowiedz()
                widzet.hide()
                widzet.deleteLater()  # [270]

        self.dane_linii_siatki = []
        self.nastepny_id_siatki = 0
        self.zapisz_stan()

    def zapisz_stan(self):
        maks_id = max((item["id"] for item in self.dane_linii_siatki), default=-1)
        self.nastepny_id_siatki = max(0, maks_id + 1)

        stan = {  # [271]
            "linijki_widoczne": self.linijki_widoczne,
            "pozycja_linijek": self.pozycja_linijek,
            "wyglad_linii_siatki": {
                "grubosc": self.grubosc_linii_siatki,
                "kolor": self.kolor_linii_siatki.name(QColor.NameFormat.HexRgb),
                "przezroczystosc": self.kolor_linii_siatki.alpha(),
            },
            "linie_siatki": list(self.dane_linii_siatki),
            "nastepny_id_siatki": self.nastepny_id_siatki,  # [272]
        }
        try:
            with open(LINES_PLIK_STANU, "w", encoding="utf-8") as f:
                json.dump(stan, f, indent=4, ensure_ascii=False)
        except IOError as e:
            print(f"LINES Error saving state to {LINES_PLIK_STANU}: {e}")
        except Exception as e:
            print(f"LINES Unexpected error saving state: {e}")

    def wczytaj_stan(self):  # [273]
        stan = {}
        try:
            if os.path.exists(LINES_PLIK_STANU):
                with open(LINES_PLIK_STANU, "r", encoding="utf-8") as f:
                    stan = json.load(f)
            else:
                pass
        except (IOError, json.JSONDecodeError) as e:
            print(  # [274]
                f"LINES Error reading or parsing state file ({LINES_PLIK_STANU}): {e}. Using default values."
            )
            stan = {}
        except Exception as e:
            print(f"LINES Unexpected error loading state: {e}. Using defaults.")
            stan = {}

        self.linijki_widoczne = stan.get("linijki_widoczne", False)
        self.pozycja_linijek = stan.get(
            "pozycja_linijek", LINES_DOMYSLNA_POZYCJA_LINIJEK
        )
        if self.pozycja_linijek not in LINES_POZYCJE_LINIJEK:  # [275]
            self.pozycja_linijek = LINES_DOMYSLNA_POZYCJA_LINIJEK

        wyglad = stan.get("wyglad_linii_siatki", {})
        self.grubosc_linii_siatki = wyglad.get("grubosc", LINES_DOMYSLNA_GRUBOŚĆ_SIATKI)
        self.grubosc_linii_siatki = max(
            1, min(int(self.grubosc_linii_siatki), LINES_MAKS_GRUBOŚĆ_SIATKI)
        )

        kolor_hex = wyglad.get("kolor", LINES_DOMYSLNY_KOLOR_SIATKI)
        przezroczystosc = wyglad.get(
            "przezroczystosc", LINES_DOMYSLNA_PRZEZROCZYSTOŚĆ_SIATKI
        )  # [276]
        przezroczystosc = max(0, min(int(przezroczystosc), 255))

        temp_kolor = QColor(kolor_hex)
        if not temp_kolor.isValid():
            temp_kolor = QColor(LINES_DOMYSLNY_KOLOR_SIATKI)
        temp_kolor.setAlpha(przezroczystosc)
        self.kolor_linii_siatki = temp_kolor

        wczytane_linie = stan.get("linie_siatki", [])
        if isinstance(wczytane_linie, list):  # [277]
            self.dane_linii_siatki = [
                item
                for item in wczytane_linie
                if isinstance(item, dict)
                and "id" in item
                and "type" in item
                and "pos" in item
            ]
            if len(self.dane_linii_siatki) != len(wczytane_linie):  # [278]
                print(
                    "[LINES WARN] Some loaded gridline entries were invalid and ignored."
                )
        else:
            print("[LINES WARN] Loaded 'linie_siatki' is not a list. Ignoring.")
            self.dane_linii_siatki = []

        wczytany_nastepny_id = stan.get("nastepny_id_siatki", 0)
        maks_id_wczytany = max(
            (item["id"] for item in self.dane_linii_siatki), default=-1
        )  # [279]
        self.nastepny_id_siatki = max(
            int(wczytany_nastepny_id), maks_id_wczytany + 1, 0
        )

    def get_active_guide_lines(self) -> List[Tuple[str, int]]:
        """Returns a list of active guide lines (orientation 'h'/'v' and their position)."""
        if not self.linijki_widoczne:
            return []

        active_lines = []  # [280]
        for line_widget in self.aktywne_linie_siatki.values():
            if isinstance(line_widget, LinesWidzetLiniiSiatki):
                active_lines.append((line_widget.typ, line_widget.pobierz_pozycje()))
        return active_lines

    def uruchom_lines_ui(self):
        if self.linijki_widoczne:
            self.pokaz_linijki()
        else:
            self.ukryj_linijki()  # [281]

    def toggle_lines_visibility(self):
        if self.linijki_widoczne:
            self.ukryj_linijki()
        else:
            self.pokaz_linijki()
        return self.linijki_widoczne

    def zamknij_aplikacje_lines(self):
        print(
            "LINES: Exit application request received. Saving state and cleaning up UI."
        )
        self.zapisz_stan()

        # Hide and prepare all UI widgets for deletion
        if self.dialog_ustawien:
            print("LINES: Closing settings dialog...")
            self.dialog_ustawien.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
            self.dialog_ustawien.close()  # Use close() instead of hide() to trigger closeEvent
            self.dialog_ustawien = None  # Remove reference

        for key in list(
            self.okna_nakladki.keys()
        ):  # Use list() to iterate over a copy of keys
            widget = self.okna_nakladki.pop(key, None)  # Safe removal from dictionary
            if widget:
                print(f"LINES: Closing overlay widget: {key}")
                widget.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
                widget.hide()  # Hide first
                widget.close()  # Trigger close, so Qt can destroy it

        for id_siatki in list(self.aktywne_linie_siatki.keys()):  # Use list()
            widget = self.aktywne_linie_siatki.pop(id_siatki, None)  # Safe removal
            if widget:
                print(f"LINES: Closing gridline widget: {id_siatki}")
                if widget.podpowiedz:  # Check if tooltip exists
                    widget.zniszcz_podpowiedz()
                widget.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
                widget.hide()  # Hide first
                widget.close()  # Trigger close

        # Remove event filter if it was installed by this class
        # Assuming eventFilter is installed in AplikacjaLiniiPomocniczych,
        # you need to add a flag e.g. self._event_filter_installed = True
        # during self.qt_app.installEventFilter(self)
        if hasattr(self, "_event_filter_installed") and self._event_filter_installed:
            try:
                self.qt_app.removeEventFilter(self)
                self._event_filter_installed = False  # Reset flag
                print("LINES: Successfully removed event filter during shutdown.")
            except Exception as e:
                print(f"LINES: Error removing event filter during shutdown: {e}")

        print("LINES: UI cleanup finished.")


def lines_get_base_path():
    if getattr(sys, "frozen", False):
        base_path = getattr(sys, "_MEIPASS", os.path.dirname(sys.executable))
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return base_path


# --- End of Integrated Lines_DesktopEN.py ---


# --- Continuation of DrawDesktop.py code --- # [282]


class GlobalHotkeyFilter(QAbstractNativeEventFilter):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
        self.last_hotkey_time = 0
        self.min_interval = 0.3

    def nativeEventFilter(self, event_type, message):
        if event_type == "windows_generic_MSG":  # [283]
            try:
                msg = ctypes.wintypes.MSG.from_address(message.__int__())
                if msg.message == 0x0312:
                    hotkey_id = msg.wParam
                    current_time = time.time()
                    toggle_hotkeys = [
                        HOTKEY_ID_DRAW,
                        HOTKEY_ID_EDIT,
                        HOTKEY_ID_BOARD,
                        HOTKEY_ID_TEMP,
                        HOTKEY_ID_LINES_TOGGLE,
                        HOTKEY_ID_GRID_TOGGLE,  # [284]
                        HOTKEY_ID_SNAP_LINES,
                        HOTKEY_ID_SNAP_GRID,
                        HOTKEY_ID_SNAP_ALL,  # New
                    ]
                    if hotkey_id in toggle_hotkeys:
                        if current_time - self.last_hotkey_time < self.min_interval:
                            return True, 0
                        self.last_hotkey_time = current_time

                    self.callback(hotkey_id)
                    return True, 0  # [285]
            except Exception as e:
                print(f"Error in nativeEventFilter: {e}")
                traceback.print_exc()
        return False, 0


_IS_WINDOWS = platform.system() == "Windows"
if _IS_WINDOWS:
    try:
        user32 = ctypes.windll.user32
        gdi32 = ctypes.windll.gdi32  # [286]
        RGN_OR = 2
        CreateRectRgn = gdi32.CreateRectRgn
        CombineRgn = gdi32.CombineRgn
        DeleteObject = gdi32.DeleteObject
        SetWindowRgn = user32.SetWindowRgn
        RegisterHotKey = user32.RegisterHotKey
        UnregisterHotKey = user32.UnregisterHotKey
        MOD_NOREPEAT = 0x4000
        MOD_ALT = 0x0001  # [287]
        MOD_CONTROL = 0x0002
        MOD_SHIFT = 0x0004
        MOD_WIN = 0x0008
        VK_OEM_5 = 0xDC
        VK_OEM_PERIOD = 0xBE
        VK_SNAPSHOT = 0x2C
        VK_DIVIDE = 0x6F
        VK_HOME = 0x24
        VK_F1 = 0x70  # [288]
        VK_F2 = 0x71
        VK_F3 = 0x72
        VK_F4 = 0x73  # New key for Snap Off
        VK_F9 = 0x78
        VK_F10 = 0x79
        VK_F11 = 0x7A
        VK_F12 = 0x7B
        VK_UP = 0x26
        VK_DOWN = 0x28  # [289]
        VK_LEFT = 0x25
        VK_RIGHT = 0x27
        VK_PRIOR = 0x21
        VK_NEXT = 0x22
        VK_OEM_COMMA = 0xBC
        VK_OEM_4 = 0xDB
        VK_OEM_6 = 0xDD
        print("WinAPI libraries loaded successfully")
    except OSError as e:  # [290]
        print(
            f"Error loading WinAPI libraries: {e}. Window regions and global hotkeys may not work."
        )
        user32 = gdi32 = None
        CreateRectRgn = CombineRgn = DeleteObject = SetWindowRgn = lambda *args: None
        RegisterHotKey = UnregisterHotKey = lambda *args: None
        MOD_ALT = MOD_CONTROL = MOD_SHIFT = MOD_WIN = VK_OEM_5 = VK_SNAPSHOT = (
            VK_DIVIDE
        ) = VK_OEM_PERIOD = 0
        VK_HOME = VK_F1 = VK_F2 = VK_F3 = VK_F9 = VK_F10 = VK_F11 = VK_F12 = VK_UP = (
            VK_DOWN
        ) = VK_LEFT = VK_RIGHT = VK_PRIOR = VK_NEXT = 0
        VK_F4 = 0  # Added for consistency, although _IS_WINDOWS will be False
        VK_OEM_COMMA = VK_OEM_4 = VK_OEM_6 = 0
else:  # [291]
    user32 = gdi32 = None
    CreateRectRgn = CombineRgn = DeleteObject = SetWindowRgn = lambda *args: None
    RegisterHotKey = UnregisterHotKey = lambda *args: None
    MOD_ALT = MOD_CONTROL = MOD_SHIFT = MOD_WIN = VK_OEM_5 = VK_SNAPSHOT = VK_DIVIDE = (
        VK_OEM_PERIOD
    ) = 0
    VK_HOME = VK_F1 = VK_F2 = VK_F3 = VK_F9 = VK_F10 = VK_F11 = VK_F12 = VK_UP = (
        VK_DOWN
    ) = VK_LEFT = VK_RIGHT = VK_PRIOR = VK_NEXT = 0
    VK_F4 = 0  # Added for consistency
    VK_OEM_COMMA = VK_OEM_4 = VK_OEM_6 = 0
    print(
        "Non-Windows system detected. Window region and global hotkey functionality unavailable."
    )

# --- Global Hotkey IDs --- # [292]
HOTKEY_ID_DRAW = 1
HOTKEY_ID_EDIT = 2
HOTKEY_ID_BOARD = 3
HOTKEY_ID_SHIFT_PRINTSCREEN = 4
HOTKEY_ID_TEMP = 5

# New IDs for Lines
HOTKEY_ID_LINES_TOGGLE = 10
HOTKEY_ID_LINES_POS = 11
HOTKEY_ID_LINES_CLEAR = 12  # [293]
HOTKEY_ID_LINES_INC_THICK = 13
HOTKEY_ID_LINES_DEC_THICK = 14

# New IDs for Grid
HOTKEY_ID_GRID_TOGGLE = 20
HOTKEY_ID_GRID_INC_COLS = 21
HOTKEY_ID_GRID_DEC_COLS = 22
HOTKEY_ID_GRID_INC_ROWS = 23
HOTKEY_ID_GRID_DEC_ROWS = 24
HOTKEY_ID_GRID_DEC_X_OFFSET = 25  # [294]
HOTKEY_ID_GRID_INC_X_OFFSET = 26
HOTKEY_ID_GRID_DEC_Y_OFFSET = 27
HOTKEY_ID_GRID_INC_Y_OFFSET = 28
HOTKEY_ID_GRID_RESET_OFFSET = 29
HOTKEY_ID_GRID_TOGGLE_DOTS = 30

# New IDs for Snap
HOTKEY_ID_SNAP_LINES = 31
HOTKEY_ID_SNAP_GRID = 32
HOTKEY_ID_SNAP_ALL = 33  # [295]
HOTKEY_ID_SNAP_OFF = 34  # New ID for turning Snap off


class Shape:
    def __init__(
        self,
        shape_type,
        geometry,
        color,
        filled=True,
        alpha=255,
        line_thickness=2,
        line_style=Qt.PenStyle.SolidLine,
        rotation=0,
        text_properties=None,
        arrow_head_size=None,
        line_pattern=None,
        gradient_properties=None,
        group_id=None,
        is_label=False,
        is_mpoint_marker=False,
        visible=True,
        mpoint_properties=None,
        double_headed=False,
        is_dimension_part=False,
        dimension_type=None,
        animation_tag=None,
        hatch_properties=None,
        line_point_arrow_style=None,
        **kwargs,
    ):
        self.type = shape_type
        self.geometry = geometry
        self.color = QColor(color) if not isinstance(color, QColor) else color
        self.filled = filled if shape_type != "spline" else False
        self.alpha = alpha
        self.line_thickness = max(1, line_thickness)  # [296]
        self.line_style = line_style
        self.line_pattern = (
            line_pattern if line_style == Qt.PenStyle.CustomDashLine else None
        )
        self.rotation = rotation
        self.text_properties = (
            deepcopy(text_properties) if shape_type == "text" else None
        )
        if self.type == "text" and self.text_properties is not None:
            self.text_properties.setdefault("curve_angle", 0)
            self.text_properties.setdefault("is_angle_display", False)

        self.arrow_head_size = (
            arrow_head_size if shape_type in ["arrow", "line_point", "spline"] else None
        )  # [297]
        self.double_headed = double_headed if shape_type == "arrow" else False
        self.gradient_properties = (
            deepcopy(gradient_properties) if gradient_properties else None
        )
        self.hatch_properties = deepcopy(hatch_properties) if hatch_properties else None
        self.group_id = group_id
        self.is_label = is_label
        self.is_mpoint_marker = is_mpoint_marker
        self.visible = visible
        self.is_dimension_part = is_dimension_part
        self.dimension_type = dimension_type  # [298]
        self.animation_tag = animation_tag
        self.line_point_arrow_style = (
            line_point_arrow_style if shape_type in ["line_point", "spline"] else None
        )

        self.startAngle = kwargs.get("startAngle", 0) if shape_type == "arc" else 0
        self.spanAngle = kwargs.get("spanAngle", 180) if shape_type == "arc" else 0
        self.rounded = kwargs.get("rounded", False) if shape_type == "rect" else False
        self.corner_radius = (
            kwargs.get("corner_radius", 5) if shape_type == "rect" else 5
        )
        self.num_sides = (
            kwargs.get("num_sides", 5) if shape_type == "regular_polygon" else 5
        )
        self.mpoint_size = (
            kwargs.get("mpoint_size", 10) if is_mpoint_marker else None
        )  # [299]

    def get_geometry_for_region(self):
        if not _IS_WINDOWS:
            return None
        thickness_buffer = math.ceil(max(self.line_thickness, 1) / 2.0) + 2
        if self.is_mpoint_marker:
            thickness_buffer += self.mpoint_size if self.mpoint_size else 10
        if self.is_dimension_part:
            thickness_buffer += 5  # [300]

        if self.type in [
            "rect",
            "ellipse",
            "text",
            "arc",
            "trapeze",
            "regular_polygon",
        ] and isinstance(self.geometry, QRectF):
            if not self.geometry.isValid():
                return None
            if self.rotation != 0:
                center = self.geometry.center()
                transform = (
                    QTransform()
                    .translate(center.x(), center.y())
                    .rotate(self.rotation)
                    .translate(-center.x(), -center.y())
                )
                poly = transform.mapToPolygon(self.geometry.toRect())
                bounding_rect = poly.boundingRect()  # [301]
            else:
                bounding_rect = self.geometry.toRect()
            if bounding_rect.width() < 1:
                bounding_rect.setWidth(1)
            if bounding_rect.height() < 1:
                bounding_rect.setHeight(1)
            return bounding_rect.adjusted(
                -thickness_buffer, -thickness_buffer, thickness_buffer, thickness_buffer
            )

        elif self.is_mpoint_marker and isinstance(self.geometry, QPointF):
            size = self.mpoint_size if self.mpoint_size else 10
            half_size = size / 2.0  # [302]
            bounding_rect = QRectF(
                self.geometry.x() - half_size, self.geometry.y() - half_size, size, size
            ).toRect()
            if self.rotation != 0:
                center = self.geometry
                transform = (
                    QTransform()
                    .translate(center.x(), center.y())
                    .rotate(self.rotation)
                    .translate(-center.x(), -center.y())
                )
                poly = transform.mapToPolygon(bounding_rect)
                bounding_rect = poly.boundingRect()
            if bounding_rect.width() < 1:
                bounding_rect.setWidth(1)
            if bounding_rect.height() < 1:
                bounding_rect.setHeight(1)
            return bounding_rect.adjusted(
                -thickness_buffer, -thickness_buffer, thickness_buffer, thickness_buffer
            )  # [303]

        elif self.type in [
            "triangle",
            "polygon",
            "brush",
            "line",
            "line_point",
            "arrow",
            "trapeze",
            "regular_polygon",
            "angle_marker",
            "spline",
        ] and isinstance(self.geometry, list):
            valid_points = [p for p in self.geometry if isinstance(p, QPointF)]
            if not valid_points:
                return None

            if self.type in ["line", "arrow"] and len(valid_points) != 2:
                return None
            if self.type == "angle_marker" and len(valid_points) != 3:
                return None
            if self.type == "spline" and len(valid_points) < 2:
                return None  # [304]
            if self.type in ["triangle"] and len(valid_points) < 3:
                return None
            if self.type in ["trapeze"] and len(valid_points) < 4:
                return None
            if self.type in ["polygon", "regular_polygon"] and len(valid_points) < 3:
                return None
            if self.type in ["brush", "line_point"] and len(valid_points) < 1:
                return None

            points_to_bound = valid_points
            if self.rotation != 0:
                center = QPointF()
                if (
                    self.type in ["line", "arrow", "angle_marker"]
                    and len(valid_points) > 0
                ):  # [305]
                    center = valid_points[0]
                    if self.type == "angle_marker" and len(valid_points) == 3:
                        center = valid_points[1]
                else:
                    if len(valid_points) > 0:
                        center = QPointF(
                            sum(p.x() for p in valid_points) / len(valid_points),
                            sum(p.y() for p in valid_points) / len(valid_points),
                        )

                if not center.isNull():  # [306]
                    transform = (
                        QTransform()
                        .translate(center.x(), center.y())
                        .rotate(self.rotation)
                        .translate(-center.x(), -center.y())
                    )
                    points_to_bound = [transform.map(p) for p in valid_points]

            if not points_to_bound:
                return None
            xs = [p.x() for p in points_to_bound]
            ys = [p.y() for p in points_to_bound]
            min_x, max_x = min(xs), max(xs)
            min_y, max_y = min(ys), max(ys)
            bounding_rect = QRectF(
                min_x, min_y, max(1, max_x - min_x), max(1, max_y - min_y)
            ).toRect()  # [307]

            if (
                (
                    self.type == "arrow"
                    or (self.type == "line_point" and self.line_point_arrow_style)
                    or (self.type == "spline" and self.line_point_arrow_style)
                )
                and self.arrow_head_size
                and self.arrow_head_size > 0
            ):
                all_head_points = []
                arrow_size = self.arrow_head_size
                offset_px = 5.0  # [308]

                if self.type == "arrow" and len(points_to_bound) == 2:
                    p1, p2 = points_to_bound
                    delta = p2 - p1
                    length = math.sqrt(delta.x() ** 2 + delta.y() ** 2)
                    if length > 1e-6:
                        angle_rad = math.atan2(delta.y(), delta.x())
                        a1_rad = angle_rad + math.radians(150)
                        all_head_points.append(
                            p2
                            + QPointF(
                                math.cos(a1_rad) * arrow_size,
                                math.sin(a1_rad) * arrow_size,
                            )
                        )  # [309]
                        a2_rad = angle_rad - math.radians(150)
                        all_head_points.append(
                            p2
                            + QPointF(
                                math.cos(a2_rad) * arrow_size,
                                math.sin(a2_rad) * arrow_size,
                            )
                        )
                        all_head_points.append(p2)

                        if self.double_headed:
                            angle_rad_start = math.atan2(-delta.y(), -delta.x())
                            a1_rad_start = angle_rad_start + math.radians(150)
                            all_head_points.append(
                                p1
                                + QPointF(
                                    math.cos(a1_rad_start) * arrow_size,
                                    math.sin(a1_rad_start) * arrow_size,
                                )
                            )
                            a2_rad_start = angle_rad_start - math.radians(150)  # [310]
                            all_head_points.append(
                                p1
                                + QPointF(
                                    math.cos(a2_rad_start) * arrow_size,
                                    math.sin(a2_rad_start) * arrow_size,
                                )
                            )
                            all_head_points.append(p1)

                elif (self.type == "line_point" or self.type == "spline") and len(
                    points_to_bound
                ) >= 2:
                    if self.line_point_arrow_style in ["1a", "2a"]:
                        p_tip_original_end = points_to_bound[-1]
                        p_base_end = QPointF()
                        if self.type == "line_point":
                            p_base_end = points_to_bound[-2]  # [311]
                        elif (
                            self.type == "spline"
                            and len(points_to_bound) >= 4
                            and (len(points_to_bound) - 1) % 3 == 0
                        ):
                            p_base_end = points_to_bound[-2]
                        else:
                            p_base_end = points_to_bound[-2]

                        direction_outward_end = p_tip_original_end - p_base_end
                        len_outward_end = math.sqrt(
                            direction_outward_end.x() ** 2
                            + direction_outward_end.y() ** 2
                        )

                        p_tip_shifted_end = p_tip_original_end  # [312]
                        if len_outward_end > 1e-6:
                            norm_outward_end = direction_outward_end / len_outward_end
                            p_tip_shifted_end = (
                                p_tip_original_end + norm_outward_end * offset_px
                            )

                        direction_for_head_end = p_base_end - p_tip_shifted_end
                        angle_rad_end = math.atan2(
                            direction_for_head_end.y(), direction_for_head_end.x()
                        )
                        a1_rad_end = angle_rad_end + math.radians(150)
                        a2_rad_end = angle_rad_end - math.radians(150)
                        all_head_points.append(
                            p_tip_shifted_end
                            + QPointF(
                                math.cos(a1_rad_end) * arrow_size,
                                math.sin(a1_rad_end) * arrow_size,
                            )
                        )  # [313]
                        all_head_points.append(
                            p_tip_shifted_end
                            + QPointF(
                                math.cos(a2_rad_end) * arrow_size,
                                math.sin(a2_rad_end) * arrow_size,
                            )
                        )
                        all_head_points.append(p_tip_shifted_end)

                    if self.line_point_arrow_style == "2a":
                        p_tip_original_start = points_to_bound[0]
                        p_base_start = QPointF()
                        if self.type == "line_point":
                            p_base_start = points_to_bound[1]
                        elif (
                            self.type == "spline"
                            and len(points_to_bound) >= 4
                            and (len(points_to_bound) - 1) % 3 == 0
                        ):  # [314]
                            p_base_start = points_to_bound[1]
                        else:
                            p_base_start = points_to_bound[1]

                        direction_outward_start = p_tip_original_start - p_base_start
                        len_outward_start = math.sqrt(
                            direction_outward_start.x() ** 2
                            + direction_outward_start.y() ** 2
                        )

                        p_tip_shifted_start = p_tip_original_start
                        if len_outward_start > 1e-6:  # [315]
                            norm_outward_start = (
                                direction_outward_start / len_outward_start
                            )
                            p_tip_shifted_start = (
                                p_tip_original_start + norm_outward_start * offset_px
                            )

                        direction_for_head_start = p_base_start - p_tip_shifted_start
                        angle_rad_start = math.atan2(
                            direction_for_head_start.y(), direction_for_head_start.x()
                        )
                        a1_rad_start = angle_rad_start + math.radians(150)
                        a2_rad_start = angle_rad_start - math.radians(150)
                        all_head_points.append(
                            p_tip_shifted_start
                            + QPointF(
                                math.cos(a1_rad_start) * arrow_size,
                                math.sin(a1_rad_start) * arrow_size,
                            )
                        )
                        all_head_points.append(
                            p_tip_shifted_start
                            + QPointF(
                                math.cos(a2_rad_start) * arrow_size,
                                math.sin(a2_rad_start) * arrow_size,
                            )
                        )  # [316]
                        all_head_points.append(p_tip_shifted_start)

                if all_head_points:
                    head_xs = [p.x() for p in all_head_points]
                    head_ys = [p.y() for p in all_head_points]
                    min_x = min(min_x, min(head_xs))
                    max_x = max(max_x, max(head_xs))
                    min_y = min(min_y, min(head_ys))
                    max_y = max(max_y, max(head_ys))
                    bounding_rect = QRectF(
                        min_x, min_y, max(1, max_x - min_x), max(1, max_y - min_y)
                    ).toRect()

            return bounding_rect.adjusted(
                -thickness_buffer, -thickness_buffer, thickness_buffer, thickness_buffer
            )  # [317]

        return None

    def contains(self, point, invert_selection=False):
        if not self.geometry:
            return invert_selection

        transformed_point = point
        center = QPointF()
        geo = self.geometry  # [318]

        if (
            self.type in ["line", "arrow", "angle_marker"]
            and isinstance(geo, list)
            and len(geo) > 0
            and isinstance(geo[0], QPointF)
        ):
            center = geo[0]
            if self.type == "angle_marker" and len(geo) == 3:
                center = geo[1]
        elif isinstance(geo, QRectF) and geo.isValid():
            center = geo.center()
        elif isinstance(geo, QPointF):  # [319]
            center = geo
        elif isinstance(geo, list):
            valid_points = [p for p in geo if isinstance(p, QPointF)]
            if valid_points:
                center = QPointF(
                    sum(p.x() for p in valid_points) / len(valid_points),  # [320]
                    sum(p.y() for p in valid_points) / len(valid_points),
                )

        if self.rotation != 0 and not center.isNull():
            try:  # [321]
                transform = (
                    QTransform()
                    .translate(center.x(), center.y())
                    .rotate(-self.rotation)
                    .translate(-center.x(), -center.y())
                )
                transformed_point = transform.map(point)  # [322]
            except Exception as e:
                print(f"Error applying inverse transform: {e}")  # [323]
                return invert_selection  # [324]

        is_inside = False  # [325]
        if self.is_mpoint_marker and isinstance(geo, QPointF):
            size = self.mpoint_size if self.mpoint_size else 10  # [326]
            tolerance = max(size / 2.0, 1.0) + 2.0  # [327]
            dist_sq = (transformed_point.x() - geo.x()) ** 2 + (
                transformed_point.y() - geo.y()
            ) ** 2  # [328]
            is_inside = dist_sq <= tolerance**2  # [329]

        elif self.type in ["rect", "text"] and isinstance(geo, QRectF):  # [330]
            tolerance = (
                5.0
                if (self.is_dimension_part and self.dimension_type == "text")
                or (
                    self.text_properties
                    and self.text_properties.get("is_angle_display")
                )
                else 0.0
            )  # [331]
            is_inside = geo.adjusted(
                -tolerance, -tolerance, tolerance, tolerance
            ).contains(transformed_point)  # [332]

        elif self.type == "ellipse" and isinstance(geo, QRectF):  # [333]
            if not geo.isValid() or geo.width() <= 0 or geo.height() <= 0:
                is_inside = False  # [334]
            else:  # [335]
                center_ellipse = geo.center()  # [336]
                rx = geo.width() / 2.0  # [337]
                ry = geo.height() / 2.0  # [338]
                if abs(rx) < 1e-6 or abs(ry) < 1e-6:
                    is_inside = False  # [339]
                else:  # [340]
                    dx = (transformed_point.x() - center_ellipse.x()) / rx  # [341]
                    dy = (transformed_point.y() - center_ellipse.y()) / ry  # [342]
                    is_inside = (dx * dx + dy * dy) <= 1.0  # [343]

        elif self.type == "arc" and isinstance(geo, QRectF):  # [344]
            if not geo.isValid():
                is_inside = False  # [345]
            else:  # [346]
                center_arc = geo.center()  # [347]
                px = transformed_point.x() - center_arc.x()  # [348]
                py = transformed_point.y() - center_arc.y()  # [349]
                point_angle_rad = math.atan2(-py, px)  # [350]
                point_angle_deg = math.degrees(point_angle_rad) % 360  # [351]
                start_angle_deg = self.startAngle % 360  # [352]
                span_angle_deg = self.spanAngle  # [353]
                end_angle_deg = (start_angle_deg + span_angle_deg) % 360  # [354]

                angle_within_span = False  # [355]
                if span_angle_deg >= 360:
                    angle_within_span = True  # [356]
                elif start_angle_deg <= end_angle_deg:
                    angle_within_span = (
                        start_angle_deg <= point_angle_deg <= end_angle_deg
                    )  # [357]
                else:
                    angle_within_span = (start_angle_deg <= point_angle_deg < 360) or (
                        0 <= point_angle_deg <= end_angle_deg
                    )  # [358]

                if not angle_within_span:
                    is_inside = False  # [359]
                else:  # [360]
                    if self.hatch_properties or self.filled:  # [361]
                        rx = geo.width() / 2.0
                        ry = geo.height() / 2.0  # [362]
                        if abs(rx) < 1e-6 or abs(ry) < 1e-6:
                            is_inside = False  # [363]
                        else:  # [364]
                            norm_dist_sq = (px / rx) ** 2 + (py / ry) ** 2  # [365]
                            is_inside = norm_dist_sq <= 1.0  # [366]
                    else:  # [367]
                        tolerance = max(self.line_thickness / 2.0, 1.0) + 5.0  # [368]
                        rx = geo.width() / 2.0
                        ry = geo.height() / 2.0  # [369]
                        if abs(rx) < 1e-6 or abs(ry) < 1e-6:
                            is_inside = False  # [370]
                        else:  # [371]
                            norm_dist_sq = (px / rx) ** 2 + (py / ry) ** 2  # [372]
                            lower_bound = (
                                (1.0 - tolerance / max(rx, ry)) ** 2
                                if max(rx, ry) > tolerance
                                else 0
                            )  # [373]
                            upper_bound = (
                                (1.0 + tolerance / max(rx, ry)) ** 2
                                if max(rx, ry) > 0
                                else float("inf")
                            )  # [374]
                            is_inside = (
                                lower_bound <= norm_dist_sq <= upper_bound
                            )  # [375]

        elif self.type in [
            "triangle",
            "polygon",
            "trapeze",
            "regular_polygon",
        ] and isinstance(geo, list):  # [376]
            valid_geo = [p for p in geo if isinstance(p, QPointF)]  # [377]
            if len(valid_geo) < 3:
                is_inside = False  # [378]
            else:  # [379]
                inside_poly = False  # [380]
                j = len(valid_geo) - 1  # [381]
                for i in range(len(valid_geo)):  # [382]
                    xi, yi = valid_geo[i].x(), valid_geo[i].y()  # [383]
                    xj, yj = valid_geo[j].x(), valid_geo[j].y()  # [384]
                    intersect = (
                        (yi > transformed_point.y()) != (yj > transformed_point.y())
                    ) and (
                        transformed_point.x()
                        < (xj - xi) * (transformed_point.y() - yi) / (yj - yi + 1e-10)
                        + xi
                    )  # [385]
                    if intersect:  # [386]
                        inside_poly = not inside_poly  # [387]
                    j = i  # [388]
                is_inside = inside_poly  # [389]
        elif self.type in ["brush", "line_point", "spline"] and isinstance(
            geo, list
        ):  # [390]
            valid_geo = [p for p in geo if isinstance(p, QPointF)]  # [391]
            if not valid_geo:
                is_inside = False  # [392]
            else:  # [393]
                tolerance = max(self.line_thickness / 2.0, 1.0) + 3.0  # [394]
                if len(valid_geo) == 1:  # [395]
                    dist_sq = (transformed_point.x() - valid_geo[0].x()) ** 2 + (
                        transformed_point.y() - valid_geo[0].y()
                    ) ** 2  # [396]
                    is_inside = dist_sq <= tolerance**2  # [397]
                else:  # [398]
                    segment_hit = False  # [399]
                    if (
                        self.type == "spline"
                        and len(valid_geo) >= 4
                        and (len(valid_geo) - 1) % 3 == 0
                    ):  # [400]
                        path = QPainterPath(valid_geo[0])  # [401]
                        for i in range(1, len(valid_geo) - 1, 3):  # [402]
                            if i + 2 < len(valid_geo):  # [403]
                                path.cubicTo(
                                    valid_geo[i], valid_geo[i + 1], valid_geo[i + 2]
                                )  # [404]
                        main_spline_points = [valid_geo[0]]  # [405]
                        for k in range(3, len(valid_geo), 3):  # [406]
                            main_spline_points.append(valid_geo[k])  # [407]

                        for k in range(len(main_spline_points) - 1):  # [408]
                            p_start_idx = k * 3  # [409]
                            if p_start_idx + 3 < len(valid_geo):  # [410]
                                p_start = valid_geo[p_start_idx]  # [411]
                                c1 = valid_geo[p_start_idx + 1]  # [412]
                                c2 = valid_geo[p_start_idx + 2]  # [413]
                                p_end = valid_geo[p_start_idx + 3]  # [414]

                                segment_path = QPainterPath(p_start)  # [415]
                                segment_path.cubicTo(c1, c2, p_end)  # [416]

                                sub_segments = [
                                    (p_start, c1),
                                    (c1, c2),
                                    (c2, p_end),
                                ]  # [417]
                                for s_p1, s_p2 in sub_segments:  # [418]
                                    dist_sq = self._point_segment_distance_sq(
                                        transformed_point, s_p1, s_p2
                                    )  # [419]
                                    if dist_sq <= tolerance**2:  # [420]
                                        segment_hit = True  # [421]
                                        break  # [422]
                                if segment_hit:  # [423]
                                    break  # [424]
                    else:  # [425]
                        for i in range(len(valid_geo) - 1):  # [426]
                            p1 = valid_geo[i]  # [427]
                            p2 = valid_geo[i + 1]  # [428]
                            dist_sq = self._point_segment_distance_sq(
                                transformed_point, p1, p2
                            )  # [429]
                            if dist_sq <= tolerance**2:  # [430]
                                segment_hit = True  # [431]
                                break  # [432]
                    is_inside = segment_hit  # [433]
        elif self.type in ["line", "arrow", "angle_marker"] and isinstance(
            geo, list
        ):  # [434]
            if self.type == "angle_marker":  # [435]
                if len(geo) != 3:
                    is_inside = False  # [436]
                else:  # [437]
                    pA, pO, pB = geo  # [438]
                    dist_sq_AO = self._point_segment_distance_sq(
                        transformed_point, pA, pO
                    )  # [439]
                    dist_sq_OB = self._point_segment_distance_sq(
                        transformed_point, pO, pB
                    )  # [440]
                    tolerance = max(self.line_thickness / 2.0, 1.0) + 5.0  # [441]
                    is_inside = (
                        dist_sq_AO <= tolerance**2 or dist_sq_OB <= tolerance**2
                    )  # [442]
            elif len(geo) == 2:  # [443]
                p1, p2 = geo  # [444]
                if not isinstance(p1, QPointF) or not isinstance(p2, QPointF):
                    is_inside = False  # [445]
                else:  # [446]
                    dist_sq = self._point_segment_distance_sq(
                        transformed_point, p1, p2
                    )  # [447]
                    tolerance = max(self.line_thickness / 2.0, 1.0) + (
                        8.0 if self.is_dimension_part else 5.0
                    )  # [448]
                    is_inside = dist_sq <= tolerance**2  # [449]
            else:
                is_inside = False  # [450]
        else:  # [451]
            is_inside = False  # [452]

        return is_inside if not invert_selection else not is_inside  # [453]

    def _point_segment_distance_sq(self, p, a, b):  # [454]
        """Calculates the square of the distance from point p to line segment ab."""  # [455]
        ab = b - a  # [456]
        ap = p - a  # [457]
        ab_len_sq = QPointF.dotProduct(ab, ab)  # [458]

        if ab_len_sq < 1e-10:  # [459]
            return QPointF.dotProduct(ap, ap)  # [460]

        t = QPointF.dotProduct(ap, ab) / ab_len_sq  # [461]
        t = max(0, min(1, t))  # [462]

        closest_point = a + t * ab  # [463]
        d = p - closest_point  # [464]
        return QPointF.dotProduct(d, d)  # [465]

    def to_dict(self):  # [466]
        """Serializes the Shape object to a dictionary."""  # [467]
        geo_data = None  # [468]
        if isinstance(self.geometry, QRectF):  # [469]
            if self.geometry.isValid():  # [470]
                geo_data = (
                    self.geometry.x(),
                    self.geometry.y(),
                    self.geometry.width(),
                    self.geometry.height(),
                )  # [471]
            else:  # [472]
                geo_data = None  # [473]
        elif isinstance(self.geometry, QPointF):  # [474]
            geo_data = (self.geometry.x(), self.geometry.y())  # [475]
        elif isinstance(self.geometry, list):  # [476]
            valid_points = [p for p in self.geometry if isinstance(p, QPointF)]  # [477]
            if len(valid_points) == len(self.geometry):  # [478]
                geo_data = [(p.x(), p.y()) for p in valid_points]  # [479]
            else:  # [480]
                if not self.geometry:  # [481]
                    geo_data = []  # [482]
                else:  # [483]
                    print(
                        f"Warning: Geometry list contains non-QPointF elements for shape {self.type}. Saving geometry as None."
                    )  # [484]
                    geo_data = None  # [485]

        line_style_int = Qt.PenStyle.SolidLine.value  # [486]
        if self.line_style is not None:  # [487]
            try:  # [488]
                line_style_int = self.line_style.value  # [489]
            except AttributeError:  # [490]
                print(
                    f"Warning: Could not get .value from line_style '{self.line_style}'. Assuming it's already an int."
                )  # [491]
                if isinstance(self.line_style, int):  # [492]
                    line_style_int = self.line_style  # [493]
                else:  # [494]
                    print(
                        f"Error: Unknown type for self.line_style: {type(self.line_style)}. Defaulting to SolidLine value."
                    )  # [495]
                    line_style_int = Qt.PenStyle.SolidLine.value  # [496]

        color_name = (
            self.color.name(QColor.NameFormat.HexArgb)
            if self.color and self.color.isValid()
            else QColor(Qt.GlobalColor.red).name(QColor.NameFormat.HexArgb)
        )  # [497]

        gradient_data = None  # [498]
        if self.gradient_properties:  # [499]
            gradient_data = deepcopy(self.gradient_properties)  # [500]
            if "color_stops" in gradient_data and isinstance(
                gradient_data["color_stops"], list
            ):  # [501]
                try:  # [502]
                    gradient_data["color_stops"] = [  # [503]
                        (pos, color.name(QColor.NameFormat.HexArgb))  # [504]
                        for pos, color in gradient_data["color_stops"]
                        if isinstance(color, QColor)  # [505]
                    ]  # [506]
                except Exception as e:  # [507]
                    print(
                        f"Warning: Error serializing gradient color stops: {e}. Gradient data might be incomplete."
                    )  # [508]
                    gradient_data = None  # [509]

        hatch_data = None  # [510]
        if self.hatch_properties:  # [511]
            hatch_data = deepcopy(self.hatch_properties)  # [512]
            if "color" in hatch_data and isinstance(
                hatch_data["color"], QColor
            ):  # [513]
                hatch_data["color"] = hatch_data["color"].name(
                    QColor.NameFormat.HexArgb
                )  # [514]

        text_props_data = None  # [515]
        if self.type == "text" and self.text_properties:  # [516]
            text_props_data = deepcopy(self.text_properties)  # [517]

        data = {  # [518]
            "type": self.type,  # [519]
            "geometry": geo_data,  # [520]
            "color": color_name,  # [521]
            "filled": self.filled,  # [522]
            "alpha": self.alpha,  # [523]
            "line_thickness": self.line_thickness,  # [524]
            "line_style": line_style_int,  # [525]
            "line_pattern": self.line_pattern,  # [526]
            "rotation": self.rotation,  # [527]
            "text_properties": text_props_data,  # [528]
            "arrow_head_size": self.arrow_head_size
            if self.type in ["arrow", "line_point", "spline"]
            else None,  # [529]
            "double_headed": self.double_headed
            if self.type == "arrow"
            else None,  # [530]
            "gradient_properties": gradient_data,  # [531]
            "hatch_properties": hatch_data,  # [532]
            "group_id": self.group_id,  # [533]
            "is_label": self.is_label,  # [534]
            "is_mpoint_marker": self.is_mpoint_marker,  # [535]
            "visible": self.visible,  # [536]
            "is_dimension_part": self.is_dimension_part,  # [537]
            "dimension_type": self.dimension_type,  # [538]
            "animation_tag": self.animation_tag,  # [539]
            "line_point_arrow_style": self.line_point_arrow_style
            if self.type in ["line_point", "spline"]
            else None,  # [540]
            "startAngle": self.startAngle if self.type == "arc" else None,  # [541]
            "spanAngle": self.spanAngle if self.type == "arc" else None,  # [542]
            "rounded": self.rounded if self.type == "rect" else None,  # [543]
            "corner_radius": self.corner_radius
            if self.type == "rect"
            else None,  # [544]
            "num_sides": self.num_sides
            if self.type == "regular_polygon"
            else None,  # [545]
            "mpoint_size": self.mpoint_size if self.is_mpoint_marker else None,  # [546]
        }  # [547]

        return {
            k: v
            for k, v in data.items()
            if v is not None
            or k
            in [
                "group_id",
                "dimension_type",
                "animation_tag",
                "hatch_properties",
                "line_point_arrow_style",
            ]
        }  # [548]

    @staticmethod  # [549]
    def from_dict(data):  # [550]
        """Deserializes a dictionary to a Shape object."""  # [551]
        st = data.get("type")  # [552]
        gd = data.get("geometry")  # [553]
        cs = data.get("color")  # [554]
        default_color = QColor(255, 0, 0, 255)  # [555]
        c = default_color  # [556]
        if cs:  # [557]
            temp_c = QColor(cs)  # [558]
            if temp_c.isValid():  # [559]
                c = temp_c  # [560]
            else:  # [561]
                print(
                    f"Warning: Invalid color string '{cs}' in data. Using default red."
                )  # [562]
        else:  # [563]
            print("Warning: Missing color in data. Using default red.")  # [564]

        fd = data.get("filled", True)  # [565]
        al = data.get("alpha", 255)  # [566]
        if c.isValid():  # [567]
            al = c.alpha()  # [568]
        if c.isValid():  # [569]
            c.setAlpha(al)  # [570]

        lt = data.get("line_thickness", 1)  # [571]
        ls_int = data.get("line_style", Qt.PenStyle.SolidLine.value)  # [572]
        ls = Qt.PenStyle.SolidLine  # [573]
        try:  # [574]
            ls = Qt.PenStyle(ls_int)  # [575]
        except ValueError:  # [576]
            print(
                f"Warning: Invalid line style int: {ls_int}. Using SolidLine."
            )  # [577]
            ls = Qt.PenStyle.SolidLine  # [578]

        pattern = data.get("line_pattern", None)  # [579]

        rt = data.get("rotation", 0)  # [580]
        tp = (
            deepcopy(data.get("text_properties", None)) if st == "text" else None
        )  # [581]
        if st == "text" and tp:  # [582]
            tp.setdefault("curve_angle", 0)  # [583]
            tp.setdefault("is_angle_display", False)  # [584]

        ahs = data.get(
            "arrow_head_size", 10 if st in ["arrow", "line_point", "spline"] else None
        )  # [585]
        dh = data.get("double_headed", False) if st == "arrow" else False  # [586]

        gp_data = data.get("gradient_properties")  # [587]
        gp = None  # [588]
        if gp_data and isinstance(gp_data, dict):  # [589]
            gp = deepcopy(gp_data)  # [590]
            if "color_stops" in gp and isinstance(gp["color_stops"], list):  # [591]
                stops = []  # [592]
                valid_stops = True  # [593]
                for item in gp["color_stops"]:  # [594]
                    if isinstance(item, (list, tuple)) and len(item) == 2:  # [595]
                        pos, color_str = item  # [596]
                        if isinstance(pos, (int, float)):  # [597]
                            color = QColor(color_str)  # [598]
                            if color.isValid():  # [599]
                                stops.append((float(pos), color))  # [600]
                            else:  # [601]
                                print(
                                    f"Warning: Invalid color string '{color_str}' in gradient stop. Skipping stop."
                                )  # [602]
                        else:  # [603]
                            print(
                                f"Warning: Invalid position type '{type(pos)}' in gradient stop: {item}. Skipping stop."
                            )  # [604]
                    else:  # [605]
                        print(
                            f"Warning: Invalid format for gradient stop: {item}. Skipping stop."
                        )  # [606]
                if valid_stops:  # [607]
                    gp["color_stops"] = stops  # [608]
                else:  # [609]
                    gp = None  # [610]
            else:  # [611]
                gp = None  # [612]
                print(
                    "Warning: Gradient properties missing or invalid 'color_stops'."
                )  # [613]

        hp_data = data.get("hatch_properties")  # [614]
        hp = None  # [615]
        if hp_data and isinstance(hp_data, dict):  # [616]
            hp = deepcopy(hp_data)  # [617]
            if "color" in hp and isinstance(hp["color"], str):  # [618]
                hatch_color = QColor(hp["color"])  # [619]
                if hatch_color.isValid():  # [620]
                    hp["color"] = hatch_color  # [621]
                else:  # [622]
                    print(
                        f"Warning: Invalid hatch color string '{hp['color']}'. Setting hatch color to None."
                    )  # [623]
                    hp["color"] = None  # [624]
            if "style" not in hp or not isinstance(hp["style"], list):  # [625]
                hp["style"] = []  # [626]
            if "thickness" not in hp or not isinstance(hp["thickness"], int):  # [627]
                hp["thickness"] = 1  # [628]

        group_id = data.get("group_id", None)  # [629]
        is_label = data.get("is_label", False)  # [630]
        is_mpoint_marker = data.get("is_mpoint_marker", False)  # [631]
        visible = data.get("visible", True)  # [632]
        is_dim_part = data.get("is_dimension_part", False)  # [633]
        dim_type = data.get("dimension_type", None)  # [634]
        animation_tag = data.get("animation_tag", None)  # [635]
        lpas = data.get("line_point_arrow_style", None)  # [636]

        start_angle = data.get("startAngle", 0)  # [637]
        span_angle = data.get("spanAngle", 180)  # [638]
        rounded = data.get("rounded", False)  # [639]
        corner_radius = data.get("corner_radius", 5)  # [640]
        num_sides = data.get("num_sides", 5)  # [641]
        mpoint_size = data.get("mpoint_size", 10)  # [642]

        if not st:  # [643]
            print(f"Warning: Missing 'type' in shape data: {data}")  # [644]
            return None  # [645]

        g = None  # [646]
        if gd is not None:  # [647]
            if (
                st in ["rect", "ellipse", "text", "arc", "trapeze", "regular_polygon"]
                and isinstance(gd, (list, tuple))
                and len(gd) == 4
            ):  # [648]
                try:  # [649]
                    g = QRectF(
                        float(gd[0]), float(gd[1]), float(gd[2]), float(gd[3])
                    )  # [650]
                    if not g.isValid():  # [651]
                        print(
                            f"Warning: Reconstructed QRectF is invalid: {gd}. Setting geometry to None."
                        )  # [652]
                        g = None  # [653]
                except (ValueError, TypeError) as e:  # [654]
                    print(
                        f"Warning: Error converting QRectF geometry: {e}, data: {gd}"
                    )  # [655]
                    g = None  # [656]
            elif (
                is_mpoint_marker and isinstance(gd, (list, tuple)) and len(gd) == 2
            ):  # [657]
                try:  # [658]
                    g = QPointF(float(gd[0]), float(gd[1]))  # [659]
                except (ValueError, TypeError) as e:  # [660]
                    print(
                        f"Warning: Error converting QPointF geometry for MPoint: {e}, data: {gd}"
                    )  # [661]
                    g = None  # [662]
            elif st in [
                "triangle",
                "polygon",
                "line",
                "line_point",
                "arrow",
                "brush",
                "trapeze",
                "regular_polygon",
                "angle_marker",
                "spline",
            ] and isinstance(gd, list):  # [663]
                try:  # [664]
                    points = [
                        QPointF(float(p[0]), float(p[1]))
                        for p in gd
                        if isinstance(p, (list, tuple)) and len(p) == 2
                    ]  # [665]
                    if len(points) == len(gd):  # [666]
                        g = points  # [667]
                    elif not gd:  # [668]
                        g = []  # [669]
                    else:  # [670]
                        print(
                            f"Warning: Invalid point format or mix in List[QPointF] geometry: {gd}. Setting geometry to None."
                        )  # [671]
                        g = None  # [672]
                except (ValueError, TypeError, IndexError) as e:  # [673]
                    print(
                        f"Warning: Error converting List[QPointF] geometry: {e}, data: {gd}"
                    )  # [674]
                    g = None  # [675]
            else:  # [676]
                print(
                    f"Warning: Unsupported geometry type or data format for shape type '{st}': data={gd}"
                )  # [677]

        try:  # [678]
            shape_alpha = al  # [679]

            kwargs = {}  # [680]
            if st == "arc":  # [681]
                kwargs["startAngle"] = start_angle  # [682]
                kwargs["spanAngle"] = span_angle  # [683]
            if st == "rect":  # [684]
                kwargs["rounded"] = rounded  # [685]
                kwargs["corner_radius"] = corner_radius  # [686]
            if st == "regular_polygon":  # [687]
                kwargs["num_sides"] = num_sides  # [688]
            if is_mpoint_marker:  # [689]
                kwargs["mpoint_size"] = mpoint_size  # [690]

            shape = Shape(
                st,
                g,
                c,
                fd,
                shape_alpha,
                lt,
                ls,
                rt,
                tp,
                ahs,
                pattern,
                gp,
                group_id,
                is_label,
                is_mpoint_marker,
                visible,
                double_headed=dh,
                is_dimension_part=is_dim_part,
                dimension_type=dim_type,
                animation_tag=animation_tag,
                hatch_properties=hp,
                line_point_arrow_style=lpas,
                **kwargs,
            )  # [691]
            return shape  # [692]
        except Exception as e:  # [693]
            print(
                f"Warning: General error creating Shape instance from dict: {e}, data: {data}"
            )  # [694]
            traceback.print_exc()  # [695]
            return None  # [696]


class DesktopOverlayRgn(QWidget):  # [697]
    drawing_mode_changed = Signal(bool)  # [698]
    edit_mode_changed = Signal(bool)  # [699]
    board_mode_changed = Signal(bool)  # [700]
    temp_mode_changed = Signal(bool)  # [701]
    color_changed = Signal(QColor)  # [702]
    board_pen_color_changed = Signal(QColor)  # [703]
    edit_pen_color_changed = Signal(QColor)  # [704]
    board_background_color_changed = Signal(QColor)  # [705]
    temp_color_changed = Signal(QColor)  # [706]
    defaults_changed = Signal()  # [707]
    shapes_visibility_changed = Signal(bool)  # [708]
    dimension_preview_color_changed = Signal(QColor)  # [709]
    angle_tool_config_changed = Signal(dict)  # [710]
    show_center_point_changed = Signal(bool)  # [711]
    line_point_arrow_style_changed = Signal(str)  # [712]
    divide_enabled_changed = Signal(bool)  # [713]
    number_of_divisions_changed = Signal(int)  # [714]
    division_point_color_changed = Signal(QColor)  # [715]
    division_point_size_changed = Signal(float)  # [716]
    # Snapping signals # [717]
    snap_mode_changed = Signal(str)  # Emits "lines", "grid", "all", or "none" # [718]
    snap_sensitivity_changed = Signal(int)  # [719]
    # Snapping feedback attributes # [720]
    snapped_point_preview: Optional[QPointF] = None  # For point snapping # [721]
    snapped_line_preview: Optional[Tuple[str, int]] = (
        None  # For line snapping ('h' or 'v', coord) # [722]
    )

    def _register_global_hotkey(self):  # [723]
        """Registers global hotkeys using WinAPI."""  # [724]
        if not _IS_WINDOWS or not VK_OEM_5:  # [725]
            print(
                "Skipping global hotkey registration (Not Windows or VK_OEM_5 undefined)"
            )  # [726]
            return False  # [727]
        if not self.hwnd:  # [728]
            self.hwnd = self.winId()  # [729]
        if not self.hwnd:  # [730]
            print("Cannot register global hotkey (HWND not available yet)")  # [731]
            QTimer.singleShot(200, self._register_global_hotkey)  # [732]
            return False  # [733]

        registered_count = 0  # [734]
        failed_keys = []  # [735]

        hotkeys_to_register = [  # [736]
            {
                "id": HOTKEY_ID_DRAW,
                "vk": VK_OEM_5,
                "mod": MOD_CONTROL,
                "name": "Ctrl+\\",
            },  # [737]
            {
                "id": HOTKEY_ID_EDIT,
                "vk": VK_OEM_5,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+\\",
            },  # [738]
            {
                "id": HOTKEY_ID_BOARD,
                "vk": VK_OEM_5,
                "mod": MOD_ALT,
                "name": "Alt+\\",
            },  # [739]
            {
                "id": HOTKEY_ID_SHIFT_PRINTSCREEN,
                "vk": VK_SNAPSHOT,
                "mod": MOD_SHIFT,
                "name": "Shift+PrintScreen",
            },  # [740]
            {
                "id": HOTKEY_ID_TEMP,
                "vk": VK_OEM_5,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+\\",
            },  # [741]
            # Lines hotkeys # [742]
            {
                "id": HOTKEY_ID_LINES_TOGGLE,
                "vk": VK_HOME,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+Home (Lines Toggle)",
            },  # [743]
            {
                "id": HOTKEY_ID_LINES_POS,
                "vk": VK_PRIOR,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+PageUp (Lines Pos)",
            },  # [744]
            {
                "id": HOTKEY_ID_LINES_CLEAR,
                "vk": VK_F9,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+F9 (Lines Clear)",
            },  # [745]
            {
                "id": HOTKEY_ID_LINES_INC_THICK,
                "vk": VK_PRIOR,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+PageUp (Lines Inc Thick)",
            },  # [746]
            {
                "id": HOTKEY_ID_LINES_DEC_THICK,
                "vk": VK_NEXT,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+PageDown (Lines Dec Thick)",
            },  # [747]
            # Grid hotkeys # [748]
            {
                "id": HOTKEY_ID_GRID_TOGGLE,
                "vk": VK_F10,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+F10 (Grid Toggle)",
            },  # [749]
            {
                "id": HOTKEY_ID_GRID_INC_COLS,
                "vk": VK_UP,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+Up (Grid Inc Cols)",
            },  # [750]
            {
                "id": HOTKEY_ID_GRID_DEC_COLS,
                "vk": VK_DOWN,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+Down (Grid Dec Cols)",
            },  # [751]
            {
                "id": HOTKEY_ID_GRID_INC_ROWS,
                "vk": VK_RIGHT,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+Right (Grid Inc Rows)",
            },  # [752]
            {
                "id": HOTKEY_ID_GRID_DEC_ROWS,
                "vk": VK_LEFT,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+Left (Grid Dec Rows)",
            },  # [753]
            {
                "id": HOTKEY_ID_GRID_DEC_X_OFFSET,
                "vk": VK_OEM_PERIOD,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+. (Grid Dec X)",
            },  # [754]
            {
                "id": HOTKEY_ID_GRID_INC_X_OFFSET,
                "vk": VK_OEM_COMMA,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+, (Grid Inc X)",
            },  # [755]
            {
                "id": HOTKEY_ID_GRID_DEC_Y_OFFSET,
                "vk": VK_OEM_4,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+[ (Grid Dec Y)",
            },  # [756]
            {
                "id": HOTKEY_ID_GRID_INC_Y_OFFSET,
                "vk": VK_OEM_6,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+] (Grid Inc Y)",
            },  # [757]
            {
                "id": HOTKEY_ID_GRID_RESET_OFFSET,
                "vk": VK_F11,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+F11 (Grid Reset Offset)",
            },  # [758]
            {
                "id": HOTKEY_ID_GRID_TOGGLE_DOTS,
                "vk": VK_F12,
                "mod": MOD_CONTROL | MOD_ALT,
                "name": "Ctrl+Alt+F12 (Grid Toggle Dots)",
            },  # [759]
            # Snap Hotkeys # [760]
            {
                "id": HOTKEY_ID_SNAP_LINES,
                "vk": VK_F1,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+F1 (Snap to Lines)",
            },  # [761]
            {
                "id": HOTKEY_ID_SNAP_GRID,
                "vk": VK_F2,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+F2 (Snap to Grid)",
            },  # [762]
            {
                "id": HOTKEY_ID_SNAP_ALL,
                "vk": VK_F3,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+F3 (Snap to All)",
            },  # [763]
            {
                "id": HOTKEY_ID_SNAP_OFF,
                "vk": VK_F4,
                "mod": MOD_ALT | MOD_SHIFT,
                "name": "Alt+Shift+F4 (Snap Off)",
            },  # New hotkey # [764]
        ]  # [765]

        for hotkey in hotkeys_to_register:  # [766]
            hotkey_id = hotkey["id"]  # [767]
            vk_key = hotkey["vk"]  # [768]
            modifiers = hotkey["mod"]  # [769]
            key_name = hotkey["name"]  # [770]

            if RegisterHotKey(
                self.hwnd, hotkey_id, modifiers | MOD_NOREPEAT, vk_key
            ):  # [771]
                registered_count += 1  # [772]
            else:  # [773]
                err = ctypes.GetLastError()  # [774]
                print(
                    f"  Failed to register global hotkey {key_name}. Error code: {err}"
                )  # [775]
                if err == 1409:  # [776]
                    if not failed_keys:  # [777]
                        QMessageBox.warning(
                            self,
                            "Hotkey Error",
                            f"Could not register one or more hotkeys ({key_name}, potentially others).\nThey might be in use by another application.",
                        )  # [778]
                failed_keys.append(key_name)  # [779]

        if failed_keys:  # [780]
            print(
                f"Summary: Failed to register hotkeys: {', '.join(failed_keys)}"
            )  # [781]
        if registered_count > 0:  # [782]
            print(
                f"Summary: Successfully registered {registered_count} hotkeys."
            )  # [783]

        return registered_count > 0  # [784]

    def _unregister_global_hotkey(self):  # [785]
        """Unregisters global hotkeys using WinAPI."""  # [786]
        if _IS_WINDOWS and self.hwnd:  # [787]
            hotkey_ids_to_unregister = [  # [788]
                HOTKEY_ID_DRAW,
                HOTKEY_ID_EDIT,
                HOTKEY_ID_BOARD,
                HOTKEY_ID_SHIFT_PRINTSCREEN,
                HOTKEY_ID_TEMP,  # [789]
                HOTKEY_ID_LINES_TOGGLE,
                HOTKEY_ID_LINES_POS,
                HOTKEY_ID_LINES_CLEAR,
                HOTKEY_ID_LINES_INC_THICK,
                HOTKEY_ID_LINES_DEC_THICK,  # [790]
                HOTKEY_ID_GRID_TOGGLE,
                HOTKEY_ID_GRID_INC_COLS,
                HOTKEY_ID_GRID_DEC_COLS,
                HOTKEY_ID_GRID_INC_ROWS,
                HOTKEY_ID_GRID_DEC_ROWS,  # [791]
                HOTKEY_ID_GRID_DEC_X_OFFSET,
                HOTKEY_ID_GRID_INC_X_OFFSET,
                HOTKEY_ID_GRID_DEC_Y_OFFSET,
                HOTKEY_ID_GRID_INC_Y_OFFSET,  # [792]
                HOTKEY_ID_GRID_RESET_OFFSET,
                HOTKEY_ID_GRID_TOGGLE_DOTS,  # [793]
                HOTKEY_ID_SNAP_LINES,
                HOTKEY_ID_SNAP_GRID,
                HOTKEY_ID_SNAP_ALL,  # [794]
                HOTKEY_ID_SNAP_OFF,  # Added new ID # [795]
            ]  # [796]
            for hotkey_id in hotkey_ids_to_unregister:  # [797]
                if not UnregisterHotKey(self.hwnd, hotkey_id):  # [798]
                    err = ctypes.GetLastError()  # [799]
                    if err != 1413:  # [800]
                        print(
                            f"  Failed to unregister hotkey ID {hotkey_id}. Error code: {err}"
                        )  # [801]

    def __init__(self):  # [802]
        """Initializes the DesktopOverlayRgn widget."""  # [803]
        super().__init__()  # [804]
        self.hwnd = None  # [805]
        self.main_app_parent = None  # [806]
        self.drawing_mode = False  # [807]
        self.board_mode = False  # [808]
        self.edit_mode = False  # [809]
        self.temp_mode = False  # [810]
        self.shapes = []  # [811]
        self.undo_stack = []  # [812]
        self.redo_stack = []  # [813]
        self.current_drawing_shape = None  # [814]
        self.drag_start_pos = None  # [815]
        self.drag_start_geometries = {}  # [816]
        self.resize_handle = None  # [817]
        self.active_angle_shape_for_point_drag = None  # [818]
        self.polygon_points = []  # [819]
        self.angle_points = []  # [820]
        self.brush_points = []  # [821]
        self.spline_points = []  # [822]
        self.handle_size = 8  # [823]
        self.current_tool = "rect"  # [824]
        self.current_arc_span_angle = 180  # [825]
        self.control_panel_visible = True  # [826]
        self.pressed_keys = set()  # [827]
        self.control_panel = None  # [828]
        self.last_esc_press_time = 0  # [829]
        self.settings = QSettings("MyCompany", "DesktopOverlayRGN")  # [830]
        self.shapes_visible = True  # [831]
        self.mpoint_label_visible = True  # [832]
        self.mpoint_marker_visible = True  # [833]
        self.mpoint_settings = {  # [834]
            "style": "circle",  # [835]
            "size": 10,  # [836]
            "label_enabled": False,  # [837]
            "label_pos": "Up",  # [838]
            "label_start": "1",  # [839]
        }  # [840]
        self.next_mpoint_label = "1"  # [841]
        self._current_group_id_counter = 0  # [842]
        self.mpoint_label_text_properties = {  # [843]
            "font": "Arial",
            "size": 10,
            "bold": False,
            "italic": False,  # [844]
            "underline": False,
            "strikeout": False,
            "color": "#000000",  # [845]
            "background_color": None,
            "alignment": "center",
            "curve_angle": 0,  # [846]
        }  # [847]
        self.show_angle_offset = False  # [848]
        self.angle_offsets = {}  # [849]
        self.resizing = False  # [850]
        self.dragging = False  # [851]
        self.selected_shapes = []  # [852]
        self.clipboard_shapes = []  # [853]
        self.is_lasso_selecting = False  # [854]
        self.input_mode = None  # [855]
        self.current_snap_angle = None  # [856]
        self.snapped_line_point_preview_end = None  # [857]
        self.background_pixmap = None  # [858]
        self._indicator_state_before_image_load = None  # [859]
        self._entered_edit_via_loadimg = False  # [860]
        self.dimension_points = []  # [861]
        self.dimension_preview_shapes = {}  # [862]
        self.current_mouse_pos = QPointF()  # [863]
        self.dimension_default_text_properties = {  # [864]
            "text": "",
            "font": "Arial",
            "size": 10,
            "bold": False,
            "italic": False,  # [865]
            "underline": False,
            "strikeout": False,
            "color": "#000000",  # [866]
            "background_color": None,
            "alignment": "center",
            "curve_angle": 0,  # [867]
            "dimension_suffix": "",  # [868]
        }  # [869]
        self.dimension_preview_line_color = QColor(0, 255, 255, 100)  # [870]
        self.dimension_preview_color_explicitly_set = False  # [871]
        self.current_angle_tool_line_color = QColor(255, 165, 0)  # [872]
        self.current_angle_tool_text_size = 10  # [873]
        self.current_angle_tool_show_inner = True  # [874]
        self.current_angle_tool_show_outer = False  # [875]
        self.current_hatch_style = []  # [876]
        self.current_hatch_color = QColor(128, 128, 128)  # [877]
        self.current_hatch_thickness = 1  # [878]
        self.show_center_point = False  # [879]
        self.center_point_contrast_color = QColor(255, 255, 0, 200)  # [880]
        self.current_line_point_arrow_style = None  # [881]
        self.divide_enabled = False  # [882]
        self.number_of_divisions = 2  # [883]
        self.division_point_color = QColor(Qt.GlobalColor.yellow)  # [884]
        self.division_point_size = 5.0  # [885]
        self.current_pen_color = QColor(255, 0, 0)  # [886]
        self.current_alpha = 255  # [887]
        self.current_line_thickness = 2  # [888]
        self.current_line_style = Qt.PenStyle.SolidLine  # [889]
        self.current_line_pattern = None  # [890]
        self.current_arrow_head_size = 10  # [891]
        self.brush_size = 5  # [892]
        self.dim_background = True  # [893]
        self.show_tool_text = True  # [894]
        self.background_color_when_drawing = QColor(30, 30, 30, 100)  # [895]
        self.board_background_color = QColor(Qt.GlobalColor.white)  # [896]
        self.current_pen_color_edit = QColor(Qt.GlobalColor.black)  # [897]
        self.current_pen_color_board_only = QColor(Qt.GlobalColor.blue)  # [898]
        self.board_default_text_properties = {  # [899]
            "text": "",
            "font": "Arial",
            "size": 14,
            "bold": False,
            "italic": False,  # [900]
            "underline": False,
            "strikeout": False,
            "color": "#000000",  # [901]
            "background_color": None,
            "alignment": "left",  # [902]
            "curve_angle": 0,  # [903]
        }  # [904]
        self.show_indicators_in_board_mode = True  # [905]
        self.current_pen_color_temp = QColor(0, 0, 255)  # [906]
        self.temp_mode_shape_duration = 3.0  # [907]
        self.show_indicators_in_temp_mode = True  # [908]
        self.color_shortcuts = {  # [909]
            Qt.Key.Key_0: QColor("black"),
            Qt.Key.Key_1: QColor("white"),  # [910]
            Qt.Key.Key_2: QColor("cyan"),
            Qt.Key.Key_3: QColor("gray"),  # [911]
            Qt.Key.Key_4: QColor("red"),
            Qt.Key.Key_5: QColor("orange"),  # [912]
            Qt.Key.Key_6: QColor("yellow"),
            Qt.Key.Key_7: QColor("green"),  # [913]
            Qt.Key.Key_8: QColor("blue"),
            Qt.Key.Key_9: QColor("magenta"),  # [914]
        }  # [915]
        self.board_color_shortcuts = {  # [916]
            Qt.Key.Key_0: QColor("black"),
            Qt.Key.Key_1: QColor("white"),  # [917]
            Qt.Key.Key_2: QColor("cyan"),
            Qt.Key.Key_3: QColor("gray"),  # [918]
            Qt.Key.Key_4: QColor("red"),
            Qt.Key.Key_5: QColor("orange"),  # [919]
            Qt.Key.Key_6: QColor("yellow"),
            Qt.Key.Key_7: QColor("green"),  # [920]
            Qt.Key.Key_8: QColor("blue"),
            Qt.Key.Key_9: QColor("magenta"),  # [921]
        }  # [922]
        self.default_text_properties = {  # [923]
            "text": "",
            "font": "Arial",
            "size": 12,
            "bold": False,
            "italic": False,  # [924]
            "underline": False,
            "strikeout": False,
            "color": "#000000",  # [925]
            "background_color": None,
            "alignment": "left",  # [926]
            "curve_angle": 0,  # [927]
        }  # [928]
        # Snapping related attributes # [929]
        self.snap_mode = "none"  # "lines", "grid", "all", "none" # [930]
        self.snap_sensitivity = 5  # Default snapping sensitivity in pixels # [931]
        self.snapped_point_preview = None  # [932]
        self.snapped_line_preview = None  # [933]

        self.setup_window_properties()  # [934]
        self.load_board_settings()  # [935]
        self.load_mpoint_label_style()  # [936]
        self.load_dimension_text_defaults()  # [937]
        self.load_dimension_preview_line_color()  # [938]
        self.load_angle_tool_settings()  # [939]
        self.load_hatch_fill_settings()  # [940]
        self.load_division_point_settings()  # [941]
        self.load_snap_settings()  # [942]
        QTimer.singleShot(150, self._get_hwnd)  # [943]
        print("Overlay RGN initialized...")  # [944]

    def setup_window_properties(self):  # [945]
        """Sets the initial window flags and geometry."""  # [946]
        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.Tool
        )  # [947]
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)  # [948]
        self.setWindowFlag(Qt.WindowType.WindowTransparentForInput, True)  # [949]
        self.setMouseTracking(True)  # [950]
        try:  # [951]
            virtual_desktop_geometry = (
                QGuiApplication.primaryScreen().virtualGeometry()
            )  # [952]
            self.setGeometry(virtual_desktop_geometry)  # [953]
        except Exception as e:  # [954]
            print(f"Error setting virtual desktop geometry: {e}")  # [955]
            try:  # [956]
                screen_geometry = QGuiApplication.primaryScreen().geometry()  # [957]
                self.setGeometry(screen_geometry)  # [958]
            except Exception as e2:  # [959]
                print(f"Error setting primary screen geometry: {e2}")  # [960]
                self.setGeometry(0, 0, 1024, 768)  # [961]
                print("Overlay geometry set to fallback 1024x768")  # [962]

    def _get_hwnd(self):  # [963]
        """Attempts to get the window handle (HWND) on Windows."""  # [964]
        if not _IS_WINDOWS:  # [965]
            self.drawing_mode = False  # [966]
            self._configure_mode()  # [967]
            self.show()  # [968]
            return  # [969]
        try:  # [970]
            if not self.testAttribute(Qt.WidgetAttribute.WA_WState_Created):  # [971]
                self.create()  # [972]

            self.hwnd = self.winId()  # [973]
            if not self.hwnd:  # [974]
                print(
                    "Failed to get HWND immediately, will try again after show()."
                )  # [975]
                QTimer.singleShot(100, self._get_hwnd)  # [976]
                if not self.isVisible():
                    self.show()  # [977]
                return  # [978]

            self._register_global_hotkey()  # [979]
            self._configure_mode()  # [980]
            if not self.isVisible():
                self.show()  # [981]

        except Exception as e:  # [982]
            print(f"Error getting HWND or showing window: {e}")  # [983]
            traceback.print_exc()  # [984]
            if not self.isVisible():
                self.show()  # [985]

    def get_fixed_size_params(self, tool_name):  # [986]
        """Gets fixed size parameters from ControlPanel for the current tool."""  # [987]
        if tool_name in ["MPoint", "dimension", "angle_marker", "spline"]:  # [988]
            return None  # [989]

        if (
            not self.control_panel
            or tool_name not in self.control_panel.fixed_size_widgets
        ):  # [990]
            return None  # [991]

        params = {}  # [992]
        widgets = self.control_panel.fixed_size_widgets[tool_name]  # [993]
        has_non_zero = False  # [994]

        for name, widget in widgets.items():  # [995]
            if isinstance(widget, (QSpinBox, QDoubleSpinBox)):  # [996]
                val = widget.value()  # [997]
                params[name] = val  # [998]
                if tool_name == "rect" and name == "Radius" and val > 0:  # [999]
                    if params.get("W", 0) > 0 and params.get("H", 0) > 0:  # [1000]
                        pass  # [1001]
                    else:
                        val = 0  # [1002]
                if tool_name == "regular_polygon" and name == "Sides":  # [1003]
                    pass  # [1004]
                elif tool_name == "arc" and name == "Span":  # [1005]
                    pass  # [1006]

                if val != 0 and not (tool_name == "arc" and name == "Span"):  # [1007]
                    has_non_zero = True  # [1008]

            elif isinstance(widget, QCheckBox):  # [1009]
                params[name] = widget.isChecked()  # [1010]

        if tool_name == "triangle":  # [1011]
            eq_side = params.get("EqSide", 0)  # [1012]
            leg_a = params.get("LegA", 0)  # [1013]
            leg_b = params.get("LegB", 0)  # [1014]
            if eq_side > 0 or (leg_a > 0 and leg_b > 0):  # [1015]
                has_non_zero = True  # [1016]
            else:  # [1017]
                has_non_zero = False  # [1018]

        if tool_name == "arc":  # [1019]
            if params.get("W", 0) > 0 and params.get("H", 0) > 0:  # [1020]
                has_non_zero = True  # [1021]
            else:  # [1022]
                has_non_zero = False  # [1023]

        return params if has_non_zero else None  # [1024]

    def _get_arc_visual_center(self, shape: Shape) -> QPointF:  # [1025]
        """Calculates the visual center of an arc as the midpoint of its 'height'."""  # [1026]
        if (
            not shape
            or shape.type != "arc"
            or not isinstance(shape.geometry, QRectF)
            or not shape.geometry.isValid()
        ):  # [1027]
            return (
                shape.geometry.center()
                if isinstance(shape.geometry, QRectF)
                else QPointF()
            )  # [1028]

        geo_rect = shape.geometry  # [1029]
        rx = geo_rect.width() / 2.0  # [1030]
        ry = geo_rect.height() / 2.0  # [1031]
        original_center = geo_rect.center()  # [1032]

        if rx < 1e-6 or ry < 1e-6:  # [1033]
            return original_center  # [1034]

        start_angle_rad = math.radians(shape.startAngle)  # [1035]
        end_angle_rad = math.radians(shape.startAngle + shape.spanAngle)  # [1036]
        mid_angle_rad = math.radians(shape.startAngle + shape.spanAngle / 2.0)  # [1037]

        p_start = original_center + QPointF(
            rx * math.cos(start_angle_rad), -ry * math.sin(start_angle_rad)
        )  # [1038]
        p_end = original_center + QPointF(
            rx * math.cos(end_angle_rad), -ry * math.sin(end_angle_rad)
        )  # [1039]

        vertex_arc = original_center + QPointF(
            rx * math.cos(mid_angle_rad), -ry * math.sin(mid_angle_rad)
        )  # [1040]

        mid_chord = (p_start + p_end) / 2.0  # [1041]

        visual_center = (mid_chord + vertex_arc) / 2.0  # [1042]

        return visual_center  # [1043]

    def create_fixed_shape(
        self,
        center_pos,
        tool,
        params,
        color,
        alpha,
        thickness,
        style,
        pattern,
        fill,
        kwargs,
    ):  # [1044]
        """Creates a Shape object with fixed parameters centered at pos."""  # [1045]
        geo = None  # [1046]
        final_kwargs = kwargs.copy()  # [1047]
        fillable = False  # [1048]

        if tool == "rect":  # [1049]
            w = params.get("W", 100)
            h = params.get("H", 100)  # [1050]
            geo = QRectF(center_pos.x() - w / 2, center_pos.y() - h / 2, w, h)  # [1051]
            final_kwargs["rounded"] = params.get("Rounded", False)  # [1052]
            final_kwargs["corner_radius"] = params.get("Radius", 5)  # [1053]
            fillable = True  # [1054]
        elif tool == "ellipse":  # [1055]
            w = params.get("W", 100)
            h = params.get("H", 100)  # [1056]
            geo = QRectF(center_pos.x() - w / 2, center_pos.y() - h / 2, w, h)  # [1057]
            fillable = True  # [1058]
        elif tool == "arc":  # [1059]
            w = params.get("W", 100)  # [1060]
            h = params.get("H", 100)  # [1061]
            geo = QRectF(center_pos.x() - w / 2, center_pos.y() - h / 2, w, h)  # [1062]
            final_kwargs["startAngle"] = 0  # [1063]
            final_kwargs["spanAngle"] = params.get("Span", 180)  # [1064]
            fillable = True  # [1065]

        elif tool == "triangle":  # [1066]
            eq_side = params.get("EqSide", 0)  # [1067]
            leg_a = params.get("LegA", 0)  # [1068]
            leg_b = params.get("LegB", 0)  # [1069]

            if eq_side > 0:  # [1070]
                h_tri = eq_side * math.sqrt(3) / 2.0  # [1071]
                p1 = center_pos + QPointF(0, -h_tri * 2.0 / 3.0)  # [1072]
                p2 = center_pos + QPointF(-eq_side / 2.0, h_tri / 3.0)  # [1073]
                p3 = center_pos + QPointF(eq_side / 2.0, h_tri / 3.0)  # [1074]
                geo = [p1, p2, p3]  # [1075]
                fillable = True  # [1076]
                print(f"Creating fixed equilateral triangle, side={eq_side}")  # [1077]
            elif leg_a > 0 and leg_b > 0:  # [1078]
                p1 = center_pos + QPointF(-leg_a / 2.0, leg_b / 2.0)  # [1079]
                p2 = center_pos + QPointF(leg_a / 2.0, leg_b / 2.0)  # [1080]
                p3 = center_pos + QPointF(-leg_a / 2.0, -leg_b / 2.0)  # [1081]
                geo = [p1, p2, p3]  # [1082]
                fillable = True  # [1083]
                print(
                    f"Creating fixed right-angled triangle, legs={leg_a}, {leg_b}"
                )  # [1084]
            else:  # [1085]
                print(
                    "Warning: No valid parameters provided for fixed triangle (EqSide > 0 or (LegA > 0 and LegB > 0) required)."
                )  # [1086]
                return None  # [1087]
        elif tool == "line" or tool == "arrow":  # [1088]
            length = params.get("L", 100)  # [1089]
            p1 = center_pos - QPointF(length / 2, 0)  # [1090]
            p2 = center_pos + QPointF(length / 2, 0)  # [1091]
            geo = [p1, p2]  # [1092]
            fillable = False  # [1093]
            if tool == "arrow":  # [1094]
                final_kwargs["arrow_head_size"] = self.current_arrow_head_size  # [1095]
                final_kwargs["double_headed"] = params.get(
                    "DoubleHeaded", False
                )  # [1096]
        elif tool == "trapeze":  # [1097]
            b1 = params.get("Base1", 100)
            b2 = params.get("Base2", 50)
            h = params.get("H", 50)  # [1098]
            half_b1 = b1 / 2.0
            half_b2 = b2 / 2.0  # [1099]
            p1 = center_pos + QPointF(-half_b1, h / 2.0)  # [1100]
            p2 = center_pos + QPointF(half_b1, h / 2.0)  # [1101]
            p3 = center_pos + QPointF(half_b2, -h / 2.0)  # [1102]
            p4 = center_pos + QPointF(-half_b2, -h / 2.0)  # [1103]
            geo = [p1, p2, p3, p4]  # [1104]
            fillable = True  # [1105]
        elif tool == "regular_polygon":  # [1106]
            sides = params.get("Sides", 5)
            radius = params.get("Radius", 50)  # [1107]
            if sides < 3:
                sides = 3  # [1108]
            points = []  # [1109]
            for i in range(sides):  # [1110]
                angle = (math.pi * 2 * i / sides) - (math.pi / 2)  # [1111]
                x = center_pos.x() + radius * math.cos(angle)  # [1112]
                y = center_pos.y() + radius * math.sin(angle)  # [1113]
                points.append(QPointF(x, y))  # [1114]
            geo = points  # [1115]
            final_kwargs["num_sides"] = sides  # [1116]
            fillable = True  # [1117]
        else:  # [1118]
            print(
                f"Warning: Fixed size creation not implemented for tool {tool}"
            )  # [1119]
            return None  # [1120]

        if geo is None:  # [1121]
            print(
                f"Error: Geometry calculation failed for fixed shape tool {tool}"
            )  # [1122]
            return None  # [1123]

        actual_fill = fill if fillable else False  # [1124]

        hatch_props = None  # [1125]
        if self.control_panel and self.control_panel.hatch_fill_enabled():  # [1126]
            hatch_props = {  # [1127]
                "style": self.control_panel.get_hatch_style(),  # [1128]
                "color": self.current_hatch_color,  # [1129]
                "thickness": self.current_hatch_thickness,  # [1130]
            }  # [1131]

        return Shape(  # [1132]
            shape_type=tool,  # [1133]
            geometry=geo,  # [1134]
            color=color,  # [1135]
            filled=actual_fill,  # [1136]
            alpha=alpha,  # [1137]
            line_thickness=thickness,  # [1138]
            line_style=style,  # [1139]
            line_pattern=pattern,  # [1140]
            rotation=0,  # [1141]
            gradient_properties=None,  # [1142]
            hatch_properties=hatch_props,  # [1143]
            **final_kwargs,  # [1144]
        )  # [1145]

    def paintEvent(self, event):  # [1146]
        """Handles painting the overlay, including shapes, background, and indicators."""  # [1147]
        try:  # [1148]
            painter = QPainter(self)  # [1149]
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)  # [1150]
            painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)  # [1151]

            if self.background_pixmap and not self.background_pixmap.isNull():  # [1152]
                win_width = self.width()
                win_height = self.height()  # [1153]
                pm_width = self.background_pixmap.width()
                pm_height = self.background_pixmap.height()  # [1154]
                if pm_width < win_width or pm_height < win_height:  # [1155]
                    painter.fillRect(self.rect(), Qt.GlobalColor.black)  # [1156]
                    x = (win_width - pm_width) / 2
                    y = (win_height - pm_height) / 2  # [1157]
                    painter.drawPixmap(int(x), int(y), self.background_pixmap)  # [1158]
                else:  # [1159]
                    painter.drawPixmap(0, 0, self.background_pixmap)  # [1160]
                if self.drawing_mode and self.dim_background:  # [1161]
                    painter.fillRect(
                        self.rect(), self.background_color_when_drawing
                    )  # [1162]
            else:  # [1163]
                if self.edit_mode:  # [1164]
                    painter.fillRect(self.rect(), QColor(0, 0, 0, 1))  # [1165]
                    if self.dim_background:  # [1166]
                        painter.fillRect(
                            self.rect(), self.background_color_when_drawing
                        )  # [1167]
                elif self.board_mode:  # [1168]
                    board_bg_color = self.board_background_color  # [1169]
                    if board_bg_color.alpha() < 5:
                        board_bg_color = QColor(Qt.GlobalColor.white)  # [1170]
                    painter.fillRect(self.rect(), board_bg_color)  # [1171]
                    if self.dim_background:  # [1172]
                        painter.fillRect(
                            self.rect(), self.background_color_when_drawing
                        )  # [1173]
                elif self.temp_mode:  # [1174]
                    painter.fillRect(self.rect(), QColor(0, 0, 0, 1))  # [1175]
                    if self.dim_background:  # [1176]
                        painter.fillRect(
                            self.rect(), self.background_color_when_drawing
                        )  # [1177]
                elif self.drawing_mode:  # [1178]
                    if self.dim_background:  # [1179]
                        painter.fillRect(
                            self.rect(), self.background_color_when_drawing
                        )  # [1180]
                    else:  # [1181]
                        painter.fillRect(self.rect(), QColor(0, 0, 0, 1))  # [1182]
                else:  # [1183]
                    painter.fillRect(self.rect(), Qt.GlobalColor.transparent)  # [1184]

            if self.drawing_mode:  # [1185]
                show_any_indicator = False  # [1186]
                mode_name = ""  # [1187]
                indicator_color = Qt.GlobalColor.black  # [1188]
                tool_text = self.current_tool.upper()  # [1189]
                if self.current_tool == "dimension":  # [1190]
                    tool_text = "DIMENSION"  # [1191]
                elif self.current_tool == "angle_marker":  # [1192]
                    tool_text = "ANGLE"  # [1193]
                elif self.current_tool == "spline":  # [1194]
                    tool_text = "SPLINE"  # [1195]
                elif (
                    self.current_tool == "line_point"
                    and (Qt.Key.Key_Control in self.pressed_keys)
                    and self.snapped_line_point_preview_end
                ):  # [1196]
                    if self.current_snap_angle is not None:  # [1197]
                        tool_text = (
                            f"LINE PT ({self.current_snap_angle:.0f}°)"  # [1198]
                        )
                    else:  # [1199]
                        tool_text = "LINE PT (SNAP)"  # [1200]

                fill_text = ""  # [1201]
                if (
                    self.control_panel
                    and self.control_panel.fill_check.isChecked()
                    and self.current_tool
                    in [
                        "rect",
                        "ellipse",
                        "triangle",
                        "polygon",
                        "trapeze",
                        "regular_polygon",
                        "arc",
                        "MPoint",
                    ]
                ):  # [1202]
                    fill_text = " Fill:ON"  # [1203]
                elif self.control_panel:  # [1204] # Check if control_panel exists
                    fill_text = " Fill:OFF"  # [1205]

                hatch_text = ""  # [1206]
                if (
                    self.control_panel and self.control_panel.hatch_fill_enabled()
                ):  # [1207]
                    active_styles_map = {  # [1208]
                        "forward_slash": "/",  # [1209]
                        "backward_slash": "\\",  # [1210]
                        "horizontal": "-",  # [1211]
                        "vertical": "|",  # [1212]
                    }  # [1213]
                    hatch_symbols = [
                        active_styles_map.get(s, "")
                        for s in self.control_panel.get_hatch_style()
                    ]  # [1214]
                    if hatch_symbols:  # [1215]
                        hatch_text = f" Hatch:{''.join(hatch_symbols)}"  # [1216]

                snap_text = f" Snap:{self.snap_mode.upper()}"  # [1217]

                param_text = ""  # [1218]
                style_text = ""  # [1219]
                alpha_text = ""  # [1220]
                rect_extra_text = ""  # [1221]
                line_point_extra_text = ""  # [1222]
                arrow_extra_text = ""  # [1223]
                spline_extra_text = ""  # [1224]
                angle_extra_text = ""  # [1225]
                mpoint_extra_text = ""  # [1226]

                if (
                    self.control_panel
                ):  # Check if control_panel exists before using it # [1227]
                    if self.current_tool == "rect":  # [1228]
                        is_rnd = self.control_panel.fixed_size_widgets["rect"][
                            "Rounded"
                        ].isChecked()  # [1229]
                        radius = self.control_panel.fixed_size_widgets["rect"][
                            "Radius"
                        ].value()  # [1230]
                        rect_extra_text = f" Rnd:{'ON' if is_rnd else 'OFF'}"  # [1231]
                        if is_rnd:  # [1232]
                            rect_extra_text += f" Rad:{radius}"  # [1233]
                    elif self.current_tool == "line_point":  # [1234]
                        is_inv = (
                            self.control_panel.line_point_invert_check.isChecked()
                        )  # [1235]
                        arrow_mode = ""  # [1236]
                        if self.control_panel.line_point_no_arrow_radio.isChecked():
                            arrow_mode = "0A"  # [1237]
                        elif self.control_panel.line_point_1a_radio.isChecked():
                            arrow_mode = "1A"  # [1238]
                        elif self.control_panel.line_point_2a_radio.isChecked():
                            arrow_mode = "2A"  # [1239]
                        line_point_extra_text = f" Inv:{'ON' if is_inv else 'OFF'} Mode:{arrow_mode}"  # [1240]
                    elif self.current_tool == "arrow":  # [1241]
                        is_2x = self.control_panel.fixed_size_widgets["arrow"][
                            "DoubleHeaded"
                        ].isChecked()  # [1242]
                        arrow_extra_text = f" 2x:{'ON' if is_2x else 'OFF'}"  # [1243]
                    elif self.current_tool == "spline":  # [1244]
                        arrow_mode_spline = ""  # [1245]
                        if self.control_panel.line_point_no_arrow_radio_spline.isChecked():
                            arrow_mode_spline = "0AH"  # [1246]
                        elif self.control_panel.line_point_1a_radio_spline.isChecked():
                            arrow_mode_spline = "1AH"  # [1247]
                        elif self.control_panel.line_point_2a_radio_spline.isChecked():
                            arrow_mode_spline = "2AH"  # [1248]
                        spline_extra_text = f" Mode:{arrow_mode_spline}"  # [1249]
                    elif self.current_tool == "angle_marker":  # [1250]
                        show_in_angle = (
                            self.control_panel.angle_tool_inner_check.isChecked()
                        )  # [1251]
                        show_out_angle = (
                            self.control_panel.angle_tool_outer_check.isChecked()
                        )  # [1252]
                        angle_extra_text = f" IN:{'ON' if show_in_angle else 'OFF'} OUT:{'ON' if show_out_angle else 'OFF'}"  # [1253]
                    elif self.current_tool == "MPoint":  # [1254]
                        mp_mode = (
                            "O"
                            if self.control_panel.mpoint_circle_radio.isChecked()
                            else "SQ"
                        )  # [1255]
                        txt_on = (
                            self.control_panel.mpoint_label_check.isChecked()
                        )  # [1256]
                        start_lbl = (
                            self.control_panel.mpoint_label_start_edit.text()
                        )  # [1257]
                        mpoint_extra_text = (
                            f" Mode:{mp_mode} Txt:{'ON' if txt_on else 'OFF'}"  # [1258]
                        )
                        if txt_on:  # [1259]
                            mpoint_extra_text += f" Lbl:'{start_lbl}'"  # [1260]

                if self.edit_mode:  # [1261]
                    show_any_indicator = self.show_indicators_in_board_mode  # [1262]
                    mode_name = "EDIT"  # [1263]
                    indicator_color = self.current_pen_color_edit  # [1264]
                elif self.board_mode:  # [1265]
                    show_any_indicator = self.show_indicators_in_board_mode  # [1266]
                    mode_name = "BOARD"  # [1267]
                    indicator_color = self.current_pen_color_board_only  # [1268]
                elif self.temp_mode:  # [1269]
                    show_any_indicator = self.show_indicators_in_temp_mode  # [1270]
                    mode_name = "TEMP"  # [1271]
                    indicator_color = self.current_pen_color_temp  # [1272]
                else:  # [1273]
                    show_any_indicator = self.show_tool_text  # [1274]
                    mode_name = "DRAW"  # [1275]
                    indicator_color = self.current_pen_color  # [1276]

                if show_any_indicator:  # [1277]
                    if self.current_tool not in ["dimension", "angle_marker"]:  # [1278]
                        if self.current_tool == "brush":  # [1279]
                            param_text += f" B{self.brush_size}"  # [1280]
                        elif self.current_tool == "arrow":  # [1281]
                            param_text += f" A{self.current_arrow_head_size}"  # [1282]
                        elif (
                            self.current_tool in ["line_point", "spline"]
                            and self.current_line_point_arrow_style
                        ):  # [1283]
                            param_text += f" A{self.current_arrow_head_size}"  # [1284]
                        else:  # [1285]
                            param_text += f" T{self.current_line_thickness}"  # [1286]

                    if self.control_panel:  # [1287]
                        style_name = (
                            self.control_panel.style_combo.currentText()
                        )  # [1288]
                        if len(style_name) > 10:
                            style_name = style_name[:9] + "."  # [1289]
                        style_text = f" S:{style_name}"  # [1290]

                    alpha_percent = round(self.current_alpha / 2.55)  # [1291]
                    alpha_text = f" Op:{alpha_percent}%"  # [1292]

                    full_tool_display_text = f"{tool_text}{param_text}{style_text}{fill_text}{hatch_text}{rect_extra_text}{line_point_extra_text}{arrow_extra_text}{spline_extra_text}{angle_extra_text}{mpoint_extra_text}{alpha_text}{snap_text}"  # [1293]

                    font = QFont("Arial", 12)  # [1294]
                    painter.setFont(font)  # [1295]
                    metrics = QFontMetrics(font)  # [1296]

                    indicator_bg_color = QColor(0, 0, 0, 180)  # [1297]
                    indicator_text_color = QColor(255, 255, 0, 200)  # [1298]
                    mode_text_color = QColor(
                        255, 255, 0, 200
                    )  # Color changed to yellow # [1299]
                    color_indicator_border_color = QColor(
                        Qt.GlobalColor.white
                    )  # [1300]

                    tool_info_rect = metrics.boundingRect(
                        QRect(0, 0, 2000, 100),
                        Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
                        full_tool_display_text,
                    )  # [1301]
                    tool_info_height = tool_info_rect.height()  # [1302]
                    color_indicator_size = tool_info_height  # [1303]
                    color_indicator_spacing = 4  # [1304]
                    indicator_x_start = (
                        5 + color_indicator_size + color_indicator_spacing
                    )  # [1305]

                    tool_info_pos = QPointF(
                        indicator_x_start, 5 + metrics.ascent()
                    )  # [1306]
                    tool_info_bg_rect = QRectF(  # [1307]
                        QPointF(indicator_x_start - 4, 5),  # [1308]
                        QSizeF(
                            tool_info_rect.width() + 8, tool_info_height + 6
                        ),  # [1309]
                    )  # [1310]

                    painter.save()  # [1311]
                    painter.setPen(Qt.PenStyle.NoPen)
                    painter.setBrush(indicator_bg_color)
                    painter.drawRoundedRect(tool_info_bg_rect, 3, 3)  # [1312]
                    painter.setPen(indicator_text_color)
                    painter.drawText(tool_info_pos, full_tool_display_text)  # [1313]
                    painter.restore()  # [1314]

                    painter.save()  # [1315]
                    indicator_rect = QRectF(
                        5, 5 + 3, color_indicator_size, color_indicator_size
                    )  # [1316]
                    painter.setBrush(indicator_color)
                    painter.setPen(QPen(color_indicator_border_color, 1))
                    painter.drawRect(indicator_rect)  # [1317]
                    painter.restore()  # [1318]

                    if mode_name:  # [1319]
                        mode_rect = metrics.boundingRect(
                            QRect(0, 0, 500, 100),
                            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter,
                            mode_name,
                        )  # [1320]
                        mode_bg_width = mode_rect.width() + 8  # [1321]
                        mode_bg_height = mode_rect.height() + 6  # [1322]
                        mode_bg_x = self.width() - mode_bg_width - 5  # [1323]
                        mode_bg_y = 5  # [1324]
                        mode_pos = QPointF(
                            mode_bg_x + 4, mode_bg_y + metrics.ascent()
                        )  # [1325]
                        mode_bg_rect = QRectF(
                            mode_bg_x, mode_bg_y, mode_bg_width, mode_bg_height
                        )  # [1326]

                        painter.save()  # [1327]
                        painter.setPen(Qt.PenStyle.NoPen)
                        painter.setBrush(indicator_bg_color)
                        painter.drawRoundedRect(mode_bg_rect, 3, 3)  # [1328]
                        painter.setPen(mode_text_color)
                        painter.drawText(mode_pos, mode_name)  # [1329]
                        painter.restore()  # [1330]

            for shape in self.shapes:  # [1331]
                if shape and shape.geometry:  # [1332]
                    is_selected = shape in self.selected_shapes  # [1333]
                    self.draw_shape(
                        painter,
                        shape,
                        is_selected,
                        is_preview=False,
                        show_angle_offset=self.show_angle_offset,
                    )  # [1334]

            if self.drawing_mode and self.current_drawing_shape:  # [1335]
                self.draw_shape(
                    painter,
                    self.current_drawing_shape,
                    is_preview=True,
                    show_angle_offset=False,
                )  # [1336]
                if (
                    self.current_snap_angle is not None
                    and self.current_drawing_shape.type in ["line", "arrow"]
                ):  # [1337]
                    painter.save()  # [1338]
                    snap_font = QFont("Arial", 16)  # [1339]
                    painter.setFont(snap_font)  # [1340]
                    snap_metrics = QFontMetrics(snap_font)  # [1341]
                    angle_text = f"{self.current_snap_angle:.0f}°"  # [1342]
                    text_rect = snap_metrics.boundingRect(angle_text)  # [1343]

                    if (
                        isinstance(self.current_drawing_shape.geometry, list)
                        and len(self.current_drawing_shape.geometry) == 2
                    ):  # [1344]
                        end_point = self.current_drawing_shape.geometry[1]  # [1345]
                        text_pos = end_point + QPointF(
                            10, -10 - text_rect.height() / 2
                        )  # [1346]

                        screen_rect = self.rect().adjusted(10, 10, -10, -10)  # [1347]
                        if (
                            text_pos.x() + text_rect.width() > screen_rect.right()
                        ):  # [1348]
                            text_pos.setX(
                                screen_rect.right() - text_rect.width()
                            )  # [1349]
                        if text_pos.x() < screen_rect.left():  # [1350]
                            text_pos.setX(screen_rect.left())  # [1351]
                        if (
                            text_pos.y() - snap_metrics.ascent() < screen_rect.top()
                        ):  # [1352]
                            text_pos.setY(
                                screen_rect.top() + snap_metrics.ascent()
                            )  # [1353]
                        if (
                            text_pos.y() + snap_metrics.descent() > screen_rect.bottom()
                        ):  # [1354]
                            text_pos.setY(
                                screen_rect.bottom() - snap_metrics.descent()
                            )  # [1355]

                        bg_rect = QRectF(
                            text_pos - QPointF(0, snap_metrics.ascent()),
                            QSizeF(text_rect.width(), text_rect.height()),
                        ).adjusted(-3, -2, 3, 2)  # [1356]
                        painter.setPen(Qt.PenStyle.NoPen)  # [1357]
                        painter.setBrush(QColor(0, 0, 0, 180))  # [1358]
                        painter.drawRoundedRect(bg_rect, 3, 3)  # [1359]
                        painter.setPen(QColor(255, 255, 0))  # [1360]
                        painter.drawText(text_pos, angle_text)  # [1361]

                    painter.restore()  # [1362]
            elif (
                self.drawing_mode
                and self.current_tool == "angle_marker"
                and len(self.angle_points) > 0
            ):  # [1363]
                self.draw_angle_tool_preview(painter)  # [1364]
            elif (
                self.drawing_mode
                and self.current_tool == "spline"
                and len(self.spline_points) > 0
            ):  # [1365]
                self.draw_spline_tool_preview(painter)  # [1366]

            if (
                self.drawing_mode
                and self.current_tool in ["polygon", "line_point"]
                and self.polygon_points
            ):  # [1367]
                line_color = QColor(0, 255, 255, 150)  # [1368]
                line_style = Qt.PenStyle.DashLine  # [1369]
                if self.is_lasso_selecting:  # [1370]
                    line_color = QColor(255, 0, 0, 150)  # [1371]
                    line_style = Qt.PenStyle.SolidLine  # [1372]

                pen = QPen(line_color, 1, line_style)  # [1373]
                painter.setPen(pen)  # [1374]
                painter.setBrush(Qt.BrushStyle.NoBrush)  # [1375]
                if len(self.polygon_points) > 1:  # [1376]
                    painter.drawPolyline(QPolygonF(self.polygon_points))  # [1377]

                painter.setBrush(line_color.lighter(120))  # [1378]
                for point in self.polygon_points:  # [1379]
                    painter.drawEllipse(point, 3, 3)  # [1380]
                if len(self.polygon_points) >= 1:  # [1381]
                    current_pos = self.mapFromGlobal(QCursor.pos())  # [1382]
                    preview_end_pos = current_pos  # [1383]
                    if (
                        self.current_tool == "line_point"
                        and (Qt.Key.Key_Control in self.pressed_keys)
                        and self.snapped_line_point_preview_end
                    ):  # [1384]
                        preview_end_pos = self.snapped_line_point_preview_end  # [1385]
                    painter.drawLine(self.polygon_points[-1], preview_end_pos)  # [1386]

            if self.drawing_mode and self.current_tool == "dimension":  # [1387]
                if hasattr(self, "draw_dimension_preview"):  # [1388]
                    self.draw_dimension_preview(painter)  # [1389]
                else:  # [1390]
                    print("Error: draw_dimension_preview method not found!")  # [1391]

            if self.drawing_mode and self.selected_shapes:  # [1392]
                if self.show_angle_offset:  # [1393]
                    painter.save()  # [1394]
                    angle_font = QFont("Arial", 18)  # [1395]
                    painter.setFont(angle_font)  # [1396]
                    metrics = QFontMetrics(angle_font)  # [1397]
                    bg_color = QColor(0, 0, 0, 255)  # [1398]
                    text_color = QColor(255, 255, 0)  # [1399]

                    for shape in self.selected_shapes:  # [1400]
                        if shape in self.angle_offsets:  # [1401]
                            angle = self.angle_offsets[shape]  # [1402]
                            angle_text = f"{angle:.1f}°"  # [1403]

                            center = self._get_shape_center(shape)  # [1404]

                            if not center.isNull():  # [1405]
                                text_rect = metrics.boundingRect(
                                    QRect(0, 0, 300, 100),
                                    Qt.AlignmentFlag.AlignCenter,
                                    angle_text,
                                )  # [1406]
                                text_width = text_rect.width()  # [1407]
                                text_height = text_rect.height()  # [1408]

                                bg_rect = QRectF(
                                    center.x() - text_width / 2.0 - 4,  # [1409]
                                    center.y() - text_height / 2.0 - 3,  # [1410]
                                    text_width + 8,  # [1411]
                                    text_height + 6,
                                )  # [1412]

                                text_pos = QPointF(
                                    center.x() - text_width / 2.0,  # [1413]
                                    center.y() - text_height / 2.0 + metrics.ascent(),
                                )  # [1414]

                                painter.setPen(Qt.PenStyle.NoPen)  # [1415]
                                painter.setBrush(bg_color)  # [1416]
                                painter.drawRoundedRect(bg_rect, 4, 4)  # [1417]

                                painter.setPen(text_color)  # [1418]
                                painter.drawText(text_pos, angle_text)  # [1419]
                    painter.restore()  # [1420]
                else:  # [1421]
                    is_rotating = (
                        Qt.Key.Key_Left in self.pressed_keys
                        or Qt.Key.Key_Right in self.pressed_keys
                    ) and (
                        QGuiApplication.keyboardModifiers()
                        & Qt.KeyboardModifier.AltModifier
                    )  # [1422]

                    for shape in self.selected_shapes:  # [1423]
                        if shape and shape.geometry:  # [1424]
                            if not (
                                shape.is_dimension_part
                                and shape.dimension_type == "text"
                            ):  # [1425]
                                self.draw_resize_handles(painter, shape)  # [1426]

                            if is_rotating:  # [1427]
                                painter.save()  # [1428]
                                angle_font = QFont("Arial", 20)  # [1429]
                                painter.setFont(angle_font)  # [1430]

                                center = self._get_shape_center(shape)  # [1431]

                                if not center.isNull():  # [1432]
                                    absolute_angle = shape.rotation % 360  # [1433]
                                    rotation_text = ""  # [1434]
                                    orient_angle_deg = 0.0  # [1435]
                                    geo = shape.geometry  # [1436]

                                    if (
                                        shape.type
                                        in ["line", "arrow", "angle_marker", "spline"]
                                        and isinstance(geo, list)
                                        and len(geo) >= 2
                                    ):  # [1437]
                                        p1 = geo[0]  # [1438]
                                        p2 = geo[1]  # [1439]
                                        if (
                                            shape.type == "angle_marker"
                                            and len(geo) == 3
                                        ):  # [1440]
                                            p1 = geo[1]  # [1441]
                                            p2 = geo[2]  # [1442]
                                        elif (
                                            shape.type == "spline" and len(geo) >= 4
                                        ):  # [1443]
                                            p2 = geo[3]  # [1444]
                                        elif (
                                            shape.type == "spline" and len(geo) >= 2
                                        ):  # [1445]
                                            p2 = geo[1]  # [1446]

                                        if isinstance(p1, QPointF) and isinstance(
                                            p2, QPointF
                                        ):  # [1447]
                                            delta = p2 - p1  # [1448]
                                            if delta.manhattanLength() > 1e-6:  # [1449]
                                                angle_rad = math.atan2(
                                                    delta.x(), -delta.y()
                                                )  # [1450]
                                                orient_angle_deg = (
                                                    math.degrees(angle_rad) % 360
                                                )  # [1451]
                                    elif shape.type == "arc":  # [1452]
                                        orient_angle_deg = shape.startAngle  # [1453]
                                    else:  # [1454]
                                        orient_angle_deg = 0.0  # [1455]

                                    sum_angle = (
                                        orient_angle_deg + absolute_angle
                                    ) % 360  # [1456]
                                    rotation_text = f"[{orient_angle_deg:.1f}, {absolute_angle:.1f}, {sum_angle:.1f}]"  # [1457]

                                    metrics = QFontMetrics(angle_font)  # [1458]
                                    text_rect = metrics.boundingRect(  # [1459]
                                        QRect(0, 0, 500, 500),  # [1460]
                                        int(Qt.AlignmentFlag.AlignLeft),  # [1461]
                                        rotation_text,  # [1462]
                                    )  # [1463]
                                    text_pos = center + QPointF(
                                        15, -15 - text_rect.height() / 2
                                    )  # [1464]

                                    screen_rect = self.rect().adjusted(
                                        10, 10, -10, -10
                                    )  # [1465]
                                    text_draw_rect = QRectF(  # [1466]
                                        text_pos
                                        - QPointF(0, metrics.ascent()),  # [1467]
                                        QSizeF(
                                            text_rect.width(), text_rect.height()
                                        ),  # [1468]
                                    ).adjusted(-4, -3, 4, 3)  # [1469]

                                    if (
                                        text_draw_rect.right() > screen_rect.right()
                                    ):  # [1470]
                                        text_pos.setX(
                                            screen_rect.right()
                                            - text_draw_rect.width()
                                            - 4
                                        )  # [1471]
                                    if (
                                        text_draw_rect.left() < screen_rect.left()
                                    ):  # [1472]
                                        text_pos.setX(screen_rect.left() + 4)  # [1473]
                                    if (
                                        text_draw_rect.top() < screen_rect.top()
                                    ):  # [1474]
                                        text_pos.setY(
                                            screen_rect.top() + metrics.ascent() + 3
                                        )  # [1475]
                                    if (
                                        text_draw_rect.bottom() > screen_rect.bottom()
                                    ):  # [1476]
                                        text_pos.setY(
                                            screen_rect.bottom()
                                            - (
                                                text_draw_rect.height()
                                                - metrics.ascent()
                                            )
                                        )  # [1477]

                                    bg_rect = QRectF(  # [1478]
                                        text_pos
                                        - QPointF(0, metrics.ascent()),  # [1479]
                                        QSizeF(
                                            text_rect.width(), text_rect.height()
                                        ),  # [1480]
                                    ).adjusted(-4, -3, 4, 3)  # [1481]

                                    painter.setPen(Qt.PenStyle.NoPen)  # [1482]
                                    painter.setBrush(QColor(0, 0, 0, 255))  # [1483]
                                    painter.drawRoundedRect(bg_rect, 5, 5)  # [1484]

                                    painter.setPen(QColor(255, 255, 0))  # [1485]
                                    painter.drawText(text_pos, rotation_text)  # [1486]

                                painter.restore()  # [1487]

            # Snapping visual feedback # [1488]
            if self.snapped_point_preview:  # [1489]
                painter.save()  # [1490]
                snap_point_color = QColor(Qt.GlobalColor.magenta)  # [1491]
                snap_point_color.setAlpha(200)  # [1492]
                painter.setPen(QPen(snap_point_color, 2))  # [1493]
                painter.setBrush(snap_point_color)  # [1494]
                painter.drawEllipse(self.snapped_point_preview, 4, 4)  # [1495]
                painter.restore()  # [1496]
            elif self.snapped_line_preview:  # [1497]
                painter.save()  # [1498]
                snap_line_color = QColor(Qt.GlobalColor.magenta)  # [1499]
                snap_line_color.setAlpha(150)  # [1500]
                snap_line_pen = QPen(snap_line_color, 3, Qt.PenStyle.DashLine)  # [1501]
                painter.setPen(snap_line_pen)  # [1502]
                line_type, coord = self.snapped_line_preview  # [1503]
                if line_type == "h":  # Horizontal snap line # [1504]
                    painter.drawLine(0, coord, self.width(), coord)  # [1505]
                elif line_type == "v":  # Vertical snap line # [1506]
                    painter.drawLine(coord, 0, coord, self.height())  # [1507]
                painter.restore()  # [1508]

        except Exception as e:  # [1509]
            print(f"Error in paintEvent: {e}")  # [1510]
            traceback.print_exc()  # [1511]
        finally:  # [1512]
            if "painter" in locals() and painter.isActive():  # [1513]
                painter.end()  # [1514]

    def draw_spline_tool_preview(self, painter):  # [1515]
        """Draws the preview of the Spline curve during its creation."""  # [1516]
        if not self.spline_points:
            return  # [1517]

        line_color = QColor(0, 255, 255, 150)  # [1518]
        line_style = Qt.PenStyle.DashLine  # [1519]
        pen = QPen(line_color, 1, line_style)  # [1520]
        painter.save()  # [1521]
        painter.setPen(pen)  # [1522]
        painter.setBrush(Qt.BrushStyle.NoBrush)  # [1523]

        points_for_preview = self.spline_points + [self.current_mouse_pos]  # [1524]

        if len(points_for_preview) >= 1:  # [1525]
            path = QPainterPath()  # [1526]
            path.moveTo(points_for_preview[0])  # [1527]

            num_segments = (len(points_for_preview) - 1) // 3  # [1528]
            last_drawn_idx = 0  # [1529]

            for i in range(num_segments):  # [1530]
                p_start_idx = i * 3  # [1531]
                c1_idx = p_start_idx + 1  # [1532]
                c2_idx = p_start_idx + 2  # [1533]
                p_end_idx = p_start_idx + 3  # [1534]
                if p_start_idx == 0:  # [1535]
                    path.cubicTo(
                        points_for_preview[c1_idx],
                        points_for_preview[c2_idx],
                        points_for_preview[p_end_idx],
                    )  # [1536]
                else:  # [1537]
                    path.moveTo(points_for_preview[p_start_idx])  # [1538]
                    path.cubicTo(
                        points_for_preview[c1_idx],
                        points_for_preview[c2_idx],
                        points_for_preview[p_end_idx],
                    )  # [1539]
                last_drawn_idx = p_end_idx  # [1540]

            remaining_start_idx = last_drawn_idx  # [1541]
            num_remaining_controls = (
                len(points_for_preview) - 1 - remaining_start_idx
            )  # [1542]

            if num_remaining_controls > 0:  # [1543]
                p_start_preview = points_for_preview[remaining_start_idx]  # [1544]
                path.moveTo(p_start_preview)  # [1545]

                if num_remaining_controls == 1:  # [1546]
                    path.lineTo(points_for_preview[remaining_start_idx + 1])  # [1547]
                elif num_remaining_controls == 2:  # [1548]
                    path.lineTo(points_for_preview[remaining_start_idx + 1])  # [1549]
                    path.lineTo(points_for_preview[remaining_start_idx + 2])  # [1550]

            painter.drawPath(path)  # [1551]

        painter.setBrush(line_color.lighter(120))  # [1552]
        for point in self.spline_points:  # [1553]
            painter.drawEllipse(point, 3, 3)  # [1554]

        painter.restore()  # [1555]

    def draw_shape(
        self,
        painter,
        shape,
        is_selected=False,
        is_preview=False,
        show_angle_offset=False,
    ):  # [1556]
        """# [1557]
        Draws a single shape on the painter. Checks shape visibility flags. # [1558]
        """  # [1559]
        if not shape or not shape.geometry or not shape.visible:  # [1560]
            return  # [1561]

        shape_alpha = shape.alpha if not is_preview else min(shape.alpha, 100)  # [1562]

        pen_color = QColor(shape.color)  # [1563]
        if not pen_color.isValid():
            pen_color = QColor(Qt.GlobalColor.red)  # [1564]

        if is_selected and not show_angle_offset and not self.temp_mode:  # [1565]
            pen_color.setAlpha(255 if not is_preview else 100)  # [1566]
        else:  # [1567]
            pen_color.setAlpha(shape_alpha)  # [1568]

        pen = QPen(pen_color, shape.line_thickness, shape.line_style)  # [1569]
        fillable_type = (
            shape.type
            in [
                "rect",
                "ellipse",
                "triangle",
                "polygon",
                "trapeze",
                "regular_polygon",
                "arc",
            ]
            or shape.is_mpoint_marker
        )  # [1570]
        if fillable_type:  # [1571]
            pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)  # [1572]
        else:  # [1573]
            pen.setCapStyle(Qt.PenCapStyle.RoundCap)  # [1574]
            pen.setJoinStyle(Qt.PenJoinStyle.RoundJoin)  # [1575]

        if shape.line_style == Qt.PenStyle.DotLine:  # [1576]
            dash_len = 1  # [1577]
            gap_len = max(2, shape.line_thickness * 1.5)  # [1578]
            pen.setDashPattern([dash_len, gap_len])  # [1579]
            pen.setCapStyle(Qt.PenCapStyle.RoundCap)  # [1580]
        elif (
            shape.line_style == Qt.PenStyle.CustomDashLine
            and hasattr(shape, "line_pattern")
            and shape.line_pattern
        ):  # [1581]
            pen.setDashPattern(shape.line_pattern)  # [1582]
            pen.setCapStyle(Qt.PenCapStyle.RoundCap)  # [1583]

        main_fill_brush = Qt.BrushStyle.NoBrush  # [1584]
        if shape.gradient_properties and fillable_type:  # [1585]
            try:  # [1586]
                props = shape.gradient_properties  # [1587]
                grad_type = props.get("type")  # [1588]
                stops = props.get("color_stops", [])  # [1589]
                geo_rect = QRectF()  # [1590]
                geo_grad = shape.geometry  # [1591]

                if isinstance(geo_grad, QRectF) and geo_grad.isValid():  # [1592]
                    geo_rect = geo_grad  # [1593]
                elif shape.is_mpoint_marker and isinstance(geo_grad, QPointF):  # [1594]
                    size = shape.mpoint_size if shape.mpoint_size else 10  # [1595]
                    geo_rect = QRectF(
                        geo_grad.x() - size / 2, geo_grad.y() - size / 2, size, size
                    )  # [1596]
                elif isinstance(geo_grad, list):  # [1597]
                    valid_pts = [
                        p for p in geo_grad if isinstance(p, QPointF)
                    ]  # [1598]
                    if valid_pts:  # [1599]
                        xs = [p.x() for p in valid_pts]
                        ys = [p.y() for p in valid_pts]  # [1600]
                        geo_rect = QRectF(
                            min(xs), min(ys), max(xs) - min(xs), max(ys) - min(ys)
                        )  # [1601]

                if geo_rect.isValid() and stops:  # [1602]
                    gradient = None  # [1603]
                    p1 = QPointF(
                        geo_rect.left() + geo_rect.width() * props.get("x1", 0.0),
                        geo_rect.top() + geo_rect.height() * props.get("y1", 0.0),
                    )  # [1604]
                    p2 = QPointF(
                        geo_rect.left() + geo_rect.width() * props.get("x2", 1.0),
                        geo_rect.top() + geo_rect.height() * props.get("y2", 0.0),
                    )  # [1605]
                    center_gradient = QPointF(
                        geo_rect.left() + geo_rect.width() * props.get("cx", 0.5),
                        geo_rect.top() + geo_rect.height() * props.get("cy", 0.5),
                    )  # [1606]
                    radius = max(geo_rect.width(), geo_rect.height()) * props.get(
                        "radius", 0.5
                    )  # [1607]
                    fx_rel = props.get("fx", 0.5)
                    fy_rel = props.get("fy", 0.5)  # [1608]
                    focal_point = QPointF(
                        center_gradient.x() + geo_rect.width() * (fx_rel - 0.5),
                        center_gradient.y() + geo_rect.height() * (fy_rel - 0.5),
                    )  # [1609]
                    angle_grad = props.get("angle", 0)  # [1610]

                    if grad_type == "linear":
                        gradient = QLinearGradient(p1, p2)  # [1611]
                    elif grad_type == "radial":
                        radius = max(1.0, radius)
                        gradient = QRadialGradient(
                            center_gradient, radius, focal_point
                        )  # [1612]
                    elif grad_type == "conical":
                        gradient = QConicalGradient(
                            center_gradient, angle_grad
                        )  # [1613]

                    if gradient:  # [1614]
                        for pos_stop, stop_color in stops:  # [1615]
                            final_stop_color = QColor(stop_color)  # [1616]
                            final_stop_color.setAlphaF(
                                final_stop_color.alphaF() * (shape_alpha / 255.0)
                            )  # [1617]
                            gradient.setColorAt(pos_stop, final_stop_color)  # [1618]
                        main_fill_brush = QBrush(gradient)  # [1619]
                    else:
                        print(
                            f"Warning: Unsupported gradient type '{grad_type}' or invalid geometry for shape {shape.type}."
                        )  # [1620]
                else:
                    print(
                        f"Warning: Invalid gradient properties or geometry for shape {shape.type}. Using solid color if enabled."
                    )  # [1621]
            except Exception as e_grad:
                print(f"Error creating gradient brush: {e_grad}")
                traceback.print_exc()  # [1622]
        elif shape.filled and fillable_type:  # [1623]
            brush_color = QColor(shape.color)  # [1624]
            if not brush_color.isValid():
                brush_color = QColor(Qt.GlobalColor.red)  # [1625]
            brush_color.setAlpha(shape_alpha)  # [1626]
            main_fill_brush = QBrush(brush_color)  # [1627]

        geo = shape.geometry  # [1628]

        painter.save()  # [1629]

        painter.setPen(pen)  # [1630]
        painter.setBrush(main_fill_brush)  # [1631]

        center_transform = QPointF()  # [1632]
        if shape.type == "arc":  # [1633]
            center_transform = self._get_arc_visual_center(shape)  # [1634]
        elif (
            shape.type in ["line", "arrow", "angle_marker"]
            and isinstance(geo, list)
            and len(geo) > 0
            and isinstance(geo[0], QPointF)
        ):  # [1635]
            center_transform = geo[0]  # [1636]
            if shape.type == "angle_marker" and len(geo) == 3:  # [1637]
                center_transform = geo[1]  # [1638]
        elif isinstance(geo, QRectF) and geo.isValid():  # [1639]
            center_transform = geo.center()  # [1640]
        elif isinstance(geo, QPointF):  # [1641]
            center_transform = geo  # [1642]
        elif isinstance(geo, list):  # [1643]
            valid_points = [p for p in geo if isinstance(p, QPointF)]  # [1644]
            if valid_points:  # [1645]
                center_transform = QPointF(
                    sum(p.x() for p in valid_points) / len(valid_points),  # [1646]
                    sum(p.y() for p in valid_points) / len(valid_points),
                )  # [1647]

        if shape.rotation != 0 and not center_transform.isNull():  # [1648]
            painter.translate(center_transform.x(), center_transform.y())  # [1649]
            painter.rotate(shape.rotation)  # [1650]
            painter.translate(-center_transform.x(), -center_transform.y())  # [1651]

        try:  # [1652]
            if shape.is_mpoint_marker and isinstance(geo, QPointF):  # [1653]
                size = shape.mpoint_size if shape.mpoint_size else 10  # [1654]
                half_size = size / 2.0  # [1655]
                if shape.type == "ellipse":
                    painter.drawEllipse(geo, half_size, half_size)  # [1656]
                elif shape.type == "rect":
                    painter.drawRect(
                        QRectF(geo.x() - half_size, geo.y() - half_size, size, size)
                    )  # [1657]
                if (
                    main_fill_brush == Qt.BrushStyle.NoBrush and shape.hatch_properties
                ):  # [1658]
                    painter.save()
                    painter.setBrush(Qt.BrushStyle.NoBrush)  # [1659]
                    if shape.type == "ellipse":
                        painter.drawEllipse(geo, half_size, half_size)  # [1660]
                    elif shape.type == "rect":
                        painter.drawRect(
                            QRectF(geo.x() - half_size, geo.y() - half_size, size, size)
                        )  # [1661]
                    painter.restore()  # [1662]

            elif shape.type in ["rect", "ellipse", "arc"] and isinstance(
                geo, QRectF
            ):  # [1663]
                if not geo.isValid():
                    return  # [1664]
                if shape.type == "rect":  # [1665]
                    if shape.rounded and shape.corner_radius > 0:  # [1666]
                        painter.drawRoundedRect(
                            geo, shape.corner_radius, shape.corner_radius
                        )  # [1667]
                    else:  # [1668]
                        painter.drawRect(geo)  # [1669]
                elif shape.type == "ellipse":  # [1670]
                    painter.drawEllipse(geo)  # [1671]
                elif shape.type == "arc":  # [1672]
                    start_angle_16 = int(round(shape.startAngle * 16))  # [1673]
                    span_angle_16 = int(round(shape.spanAngle * 16))  # [1674]
                    if main_fill_brush != Qt.BrushStyle.NoBrush:  # [1675]
                        painter.drawChord(geo, start_angle_16, span_angle_16)  # [1676]
                    else:  # [1677]
                        painter.setBrush(Qt.BrushStyle.NoBrush)  # [1678]
                        painter.drawArc(geo, start_angle_16, span_angle_16)  # [1679]

            elif shape.type in [
                "triangle",
                "polygon",
                "trapeze",
                "regular_polygon",
            ] and isinstance(geo, list):  # [1680]
                valid_geo = [p for p in geo if isinstance(p, QPointF)]  # [1681]
                min_points = 3  # [1682]
                if shape.type == "trapeze":
                    min_points = 4  # [1683]
                if len(valid_geo) >= min_points:  # [1684]
                    painter.drawPolygon(QPolygonF(valid_geo))  # [1685]
            elif shape.type in ["brush", "line_point", "spline"] and isinstance(
                geo, list
            ):  # [1686]
                valid_geo = [p for p in geo if isinstance(p, QPointF)]  # [1687]
                if len(valid_geo) >= 1:  # [1688]
                    painter.setBrush(Qt.BrushStyle.NoBrush)  # [1689]
                    painter.setPen(pen)  # [1690]

                    if shape.type == "spline":  # [1691]
                        if (
                            len(valid_geo) >= 4 and (len(valid_geo) - 1) % 3 == 0
                        ):  # [1692]
                            path = QPainterPath(valid_geo[0])  # [1693]
                            for i in range(1, len(valid_geo) - 1, 3):  # [1694]
                                if i + 2 < len(valid_geo):  # [1695]
                                    path.cubicTo(
                                        valid_geo[i], valid_geo[i + 1], valid_geo[i + 2]
                                    )  # [1696]
                            painter.drawPath(path)  # [1697]
                        elif len(valid_geo) >= 2:  # [1698]
                            painter.drawPolyline(QPolygonF(valid_geo))  # [1699]

                    elif len(valid_geo) > 1:  # [1700]
                        painter.drawPolyline(QPolygonF(valid_geo))  # [1701]
                    elif len(valid_geo) == 1:  # [1702]
                        radius = shape.line_thickness / 2.0  # [1703]
                        point_brush_color = QColor(pen.color())  # [1704]
                        painter.setBrush(point_brush_color)  # [1705]
                        painter.drawEllipse(valid_geo[0], radius, radius)  # [1706]

                    if (
                        shape.type in ["line_point", "spline"]
                        and shape.line_point_arrow_style
                        and len(valid_geo) >= 2
                    ):  # [1707]
                        arrow_size = (
                            shape.arrow_head_size
                            if shape.arrow_head_size
                            else self.current_arrow_head_size
                        )  # [1708]
                        pen_color_for_head = QColor(pen.color())  # [1709]
                        offset_px = 5.0  # [1710]

                        if shape.line_point_arrow_style in ["1a", "2a"]:  # [1711]
                            p_tip_original_end = valid_geo[-1]  # [1712]
                            p_base_end = QPointF()  # [1713]
                            if shape.type == "line_point":  # [1714]
                                p_base_end = valid_geo[-2]  # [1715]
                            elif (
                                shape.type == "spline"
                                and len(valid_geo) >= 4
                                and (len(valid_geo) - 1) % 3 == 0
                            ):  # [1716]
                                p_base_end = valid_geo[-2]  # [1717]
                            else:  # [1718]
                                p_base_end = (
                                    valid_geo[-2]
                                    if len(valid_geo) >= 2
                                    else p_tip_original_end
                                )  # [1719]

                            direction_outward_end = (
                                p_tip_original_end - p_base_end
                            )  # [1720]
                            len_outward_end = math.sqrt(
                                direction_outward_end.x() ** 2
                                + direction_outward_end.y() ** 2
                            )  # [1721]

                            p_tip_shifted_end = p_tip_original_end  # [1722]
                            if len_outward_end > 1e-6:  # [1723]
                                norm_outward_end = (
                                    direction_outward_end / len_outward_end
                                )  # [1724]
                                p_tip_shifted_end = (
                                    p_tip_original_end + norm_outward_end * offset_px
                                )  # [1725]

                            direction_for_head_end = (
                                p_base_end - p_tip_shifted_end
                            )  # [1726]
                            self._draw_arrow_head_at_point(
                                painter,
                                p_tip_shifted_end,
                                direction_for_head_end,
                                arrow_size,
                                pen_color_for_head,
                                shape_alpha,
                            )  # [1727]

                        if shape.line_point_arrow_style == "2a":  # [1728]
                            p_tip_original_start = valid_geo[0]  # [1729]
                            p_base_start = QPointF()  # [1730]
                            if shape.type == "line_point":  # [1731]
                                p_base_start = valid_geo[1]  # [1732]
                            elif (
                                shape.type == "spline"
                                and len(valid_geo) >= 4
                                and (len(valid_geo) - 1) % 3 == 0
                            ):  # [1733]
                                p_base_start = valid_geo[1]  # [1734]
                            else:  # [1735]
                                p_base_start = (
                                    valid_geo[1]
                                    if len(valid_geo) >= 2
                                    else p_tip_original_start
                                )  # [1736]

                            direction_outward_start = (
                                p_tip_original_start - p_base_start
                            )  # [1737]
                            len_outward_start = math.sqrt(
                                direction_outward_start.x() ** 2
                                + direction_outward_start.y() ** 2
                            )  # [1738]

                            p_tip_shifted_start = p_tip_original_start  # [1739]
                            if len_outward_start > 1e-6:  # [1740]
                                norm_outward_start = (
                                    direction_outward_start / len_outward_start
                                )  # [1741]
                                p_tip_shifted_start = (
                                    p_tip_original_start
                                    + norm_outward_start * offset_px
                                )  # [1742]

                            direction_for_head_start = (
                                p_base_start - p_tip_shifted_start
                            )  # [1743]
                            self._draw_arrow_head_at_point(
                                painter,
                                p_tip_shifted_start,
                                direction_for_head_start,
                                arrow_size,
                                pen_color_for_head,
                                shape_alpha,
                            )  # [1744]

            elif shape.type in ["line", "arrow", "angle_marker"] and isinstance(
                geo, list
            ):  # [1745]
                if shape.type == "angle_marker":  # [1746]
                    if len(geo) == 3:  # [1747]
                        pA, pO, pB = geo  # [1748]
                        if all(isinstance(p, QPointF) for p in [pA, pO, pB]):  # [1749]
                            painter.setBrush(Qt.BrushStyle.NoBrush)  # [1750]
                            painter.setPen(pen)  # [1751]
                            painter.drawLine(pA, pO)  # [1752]
                            painter.drawLine(pO, pB)  # [1753]
                elif len(geo) == 2:  # [1754]
                    p1, p2 = geo  # [1755]
                    if isinstance(p1, QPointF) and isinstance(p2, QPointF):  # [1756]
                        painter.setBrush(Qt.BrushStyle.NoBrush)  # [1757]
                        painter.setPen(pen)  # [1758]

                        delta = p2 - p1  # [1759]
                        length = math.sqrt(delta.x() ** 2 + delta.y() ** 2)  # [1760]
                        p1_line_start = p1  # [1761]
                        p2_line_end = p2  # [1762]

                        arrow_size = (
                            shape.arrow_head_size if shape.arrow_head_size else 0
                        )  # [1763]
                        shorten_dist = arrow_size * 0.5  # [1764]
                        shorten_amount = 0  # [1765]
                        if (
                            shape.type == "arrow" and arrow_size > 0 and length > 1e-6
                        ):  # [1766]
                            shorten_amount = min(
                                max(0, shorten_dist), length * 0.45
                            )  # [1767]

                        if shorten_amount > 0:  # [1768]
                            norm_delta = delta / length  # [1769]
                            p2_line_end = p2 - norm_delta * shorten_amount  # [1770]
                            if shape.double_headed:  # [1771]
                                p1_line_start = (
                                    p1 + norm_delta * shorten_amount
                                )  # [1772]

                        painter.drawLine(p1_line_start, p2_line_end)  # [1773]

                        if (
                            shape.type == "arrow" and arrow_size > 0 and length > 1e-6
                        ):  # [1774]
                            direction_from_tip_end = p1 - p2  # [1775]
                            self._draw_arrow_head_at_point(
                                painter,
                                p2,
                                direction_from_tip_end,
                                arrow_size,
                                QColor(pen.color()),
                                shape_alpha,
                            )  # [1776]

                            if shape.double_headed:  # [1777]
                                direction_from_tip_start = p2 - p1  # [1778]
                                self._draw_arrow_head_at_point(
                                    painter,
                                    p1,
                                    direction_from_tip_start,
                                    arrow_size,
                                    QColor(pen.color()),
                                    shape_alpha,
                                )  # [1779]

            elif (
                shape.type == "text"
                and isinstance(geo, QRectF)
                and shape.text_properties
            ):  # [1780]
                if not geo.isValid():
                    return  # [1781]

                props = shape.text_properties  # [1782]
                text = props.get("text", "")  # [1783]
                curve_angle = props.get("curve_angle", 0)  # [1784]

                if text:  # [1785]
                    painter.save()  # [1786]
                    try:  # [1787]
                        font = QFont(
                            props.get("font", "Arial"), props.get("size", 12)
                        )  # [1788]
                        font.setBold(props.get("bold", False))  # [1789]
                        font.setItalic(props.get("italic", False))  # [1790]
                        font.setUnderline(props.get("underline", False))  # [1791]
                        font.setStrikeOut(props.get("strikeout", False))  # [1792]
                        painter.setFont(font)  # [1793]
                        metrics = QFontMetrics(font)  # [1794]

                        text_color_str = props.get("color", "#000000")  # [1795]
                        text_color = QColor(text_color_str)  # [1796]
                        if not text_color.isValid():
                            text_color = Qt.GlobalColor.black  # [1797]
                        text_color.setAlpha(shape_alpha)  # [1798]
                        text_pen = QPen(text_color)  # [1799]

                        bg_color_str = props.get("background_color")  # [1800]
                        bg_color = None  # [1801]
                        if bg_color_str:  # [1802]
                            try:  # [1803]
                                temp_bg = QColor(bg_color_str)  # [1804]
                                if temp_bg.isValid() and temp_bg.alpha() > 0:  # [1805]
                                    final_bg_alpha_float = temp_bg.alphaF() * (
                                        shape_alpha / 255.0
                                    )  # [1806]
                                    bg_color = QColor(temp_bg)  # [1807]
                                    bg_color.setAlphaF(final_bg_alpha_float)  # [1808]
                            except Exception:
                                self.bg_color = None  # [1809]

                        draw_background = bg_color and bg_color.alpha() > 1  # [1810]
                        if draw_background:  # [1811]
                            painter.setBrush(QBrush(bg_color))  # [1812]
                            painter.setPen(Qt.PenStyle.NoPen)  # [1813]
                            if geo.width() > 0 and geo.height() > 0:  # [1814]
                                painter.drawRect(geo)  # [1815]
                            else:
                                print(
                                    f"Invalid geometry for background: {geo}"
                                )  # [1816]

                        painter.setPen(text_pen)  # [1817]
                        painter.setBrush(Qt.BrushStyle.NoBrush)  # [1818]

                        if abs(curve_angle) < 1e-6:  # [1819]
                            flags = Qt.TextFlag.TextWordWrap  # [1820]
                            align_str = props.get("alignment", "left")  # [1821]
                            align_map = {
                                "left": Qt.AlignmentFlag.AlignLeft,
                                "center": Qt.AlignmentFlag.AlignCenter,
                                "right": Qt.AlignmentFlag.AlignRight,
                                "justify": Qt.AlignmentFlag.AlignJustify,
                            }  # [1822]
                            flags |= align_map.get(
                                align_str, Qt.AlignmentFlag.AlignLeft
                            )  # [1823]
                            flags |= Qt.AlignmentFlag.AlignVCenter  # [1824]
                            painter.drawText(geo, flags, text)  # [1825]

                        else:  # [1826]
                            char_widths = [
                                metrics.horizontalAdvance(char) for char in text
                            ]  # [1827]
                            total_text_width = sum(char_widths)  # [1828]
                            if total_text_width < 1e-6:  # [1829]
                                painter.restore()
                                return  # [1830]

                            angle_range_rad = math.radians(abs(curve_angle))  # [1831]
                            if angle_range_rad < 1e-6:
                                angle_range_rad = 1e-6  # [1832]
                            radius = total_text_width / angle_range_rad  # [1833]

                            widget_center = geo.center()  # [1834]
                            font_height = metrics.height()  # [1835]
                            vertical_offset = font_height * 0.5  # [1836]

                            if curve_angle > 0:  # [1837]
                                center_arc_math_angle = math.pi / 2.0  # [1838]
                                start_arc_math_angle = (
                                    center_arc_math_angle + angle_range_rad / 2.0
                                )  # [1839]
                                angle_sign = -1.0  # [1840]
                                arc_center_y = (
                                    widget_center.y() + radius - vertical_offset
                                )  # [1841]
                            else:  # [1842]
                                center_arc_math_angle = -math.pi / 2.0  # [1843]
                                start_arc_math_angle = (
                                    center_arc_math_angle - angle_range_rad / 2.0
                                )  # [1844]
                                angle_sign = +1.0  # [1845]
                                arc_center_y = (
                                    widget_center.y() - radius + vertical_offset
                                )  # [1846]

                            arc_center = QPointF(
                                widget_center.x(), arc_center_y
                            )  # [1847]

                            cumulative_width = 0.0  # [1848]
                            for char, char_width in zip(text, char_widths):  # [1849]
                                if char_width <= 0:
                                    continue  # [1850]
                                half_char_width = char_width / 2.0  # [1851]

                                center_char_angle_offset_rad = (
                                    cumulative_width + half_char_width
                                ) / radius  # [1852]
                                center_char_math_angle_rad = (
                                    start_arc_math_angle
                                    + angle_sign * center_char_angle_offset_rad
                                )  # [1853]

                                char_x = arc_center.x() + radius * math.cos(
                                    center_char_math_angle_rad
                                )  # [1854]
                                char_y = arc_center.y() - radius * math.sin(
                                    center_char_math_angle_rad
                                )  # [1855]

                                qt_rotation_deg = 90.0 - math.degrees(
                                    center_char_math_angle_rad
                                )  # [1856]
                                if curve_angle < 0:  # [1857]
                                    qt_rotation_deg += 180.0  # [1858]

                                painter.save()  # [1859]
                                painter.translate(char_x, char_y)  # [1860]
                                painter.rotate(qt_rotation_deg)  # [1861]
                                painter.drawText(-half_char_width, 0.0, char)  # [1862]
                                painter.restore()  # [1863]

                                cumulative_width += char_width  # [1864]
                    except Exception as e:  # [1865]
                        print(f"Error drawing text content: {e}")  # [1866]
                        traceback.print_exc()  # [1867]
                    finally:  # [1868]
                        painter.restore()  # [1869]

            if shape.hatch_properties and fillable_type:  # [1870]
                self._draw_hatch_fill(painter, shape)  # [1871]

            if self.show_center_point and shape.visible and not is_preview:  # [1872]
                self._draw_center_point_for_shape(painter, shape)  # [1873]

            if (
                self.divide_enabled and self.number_of_divisions >= 2 and not is_preview
            ):  # [1874]
                self._draw_division_points(painter, shape)  # [1875]

        except Exception as e:  # [1876]
            print(f"Error drawing shape type {shape.type}: {e}")  # [1877]
            traceback.print_exc()  # [1878]

        finally:  # [1879]
            if (
                is_selected
                and not is_preview
                and not show_angle_offset
                and not self.temp_mode
            ):  # [1880]
                painter.save()  # [1881]

                painter.resetTransform()  # [1882]

                bounding_rect = None  # [1883]

                if (
                    shape.type == "text"
                    and isinstance(geo, QRectF)
                    and shape.text_properties
                ):  # [1884]
                    curve_angle = shape.text_properties.get("curve_angle", 0)  # [1885]
                    if curve_angle != 0:  # [1886]
                        props = shape.text_properties  # [1887]
                        text = props.get("text", "")  # [1888]
                        if text:  # [1889]
                            try:  # [1890]
                                font = QFont(
                                    props.get("font", "Arial"), props.get("size", 12)
                                )  # [1891]
                                font.setBold(props.get("bold", False))
                                font.setItalic(props.get("italic", False))  # [1892]
                                font.setUnderline(props.get("underline", False))
                                font.setStrikeOut(
                                    props.get("strikeout", False)
                                )  # [1893]
                                metrics = QFontMetrics(font)  # [1894]

                                char_widths = [
                                    metrics.horizontalAdvance(char) for char in text
                                ]  # [1895]
                                total_text_width = sum(char_widths)  # [1896]

                                if total_text_width < 1e-6:  # [1897]
                                    bounding_rect = QRectF(geo)  # [1898]
                                else:  # [1899]
                                    angle_rad = math.radians(curve_angle)  # [1900]
                                    if abs(angle_rad) < 1e-6:
                                        angle_rad = 1e-6  # [1901]
                                    radius = total_text_width / abs(angle_rad)  # [1902]

                                    widget_center = geo.center()  # [1903]
                                    font_height = metrics.height()  # [1904]
                                    vertical_offset = font_height * 0.5  # [1905]

                                    if curve_angle > 0:  # [1906]
                                        center_arc_math_angle = math.pi / 2.0  # [1907]
                                        start_arc_math_angle = (
                                            center_arc_math_angle + abs(angle_rad) / 2.0
                                        )  # [1908]
                                        angle_sign = -1.0  # [1909]
                                        arc_center_y = (
                                            widget_center.y() + radius - vertical_offset
                                        )  # [1910]
                                    else:  # [1911]
                                        center_arc_math_angle = -math.pi / 2.0  # [1912]
                                        start_arc_math_angle = (
                                            center_arc_math_angle - abs(angle_rad) / 2.0
                                        )  # [1913]
                                        angle_sign = 1.0  # [1914]
                                        arc_center_y = (
                                            widget_center.y() - radius + vertical_offset
                                        )  # [1915]
                                    arc_center = QPointF(
                                        widget_center.x(), arc_center_y
                                    )  # [1916]

                                    all_char_corners = []  # [1917]
                                    cumulative_width = 0.0  # [1918]

                                    for i, char in enumerate(text):  # [1919]
                                        char_width = char_widths[i]  # [1920]
                                        if radius < 1e-6 or char_width <= 0:
                                            continue  # [1921]

                                        half_char_width = char_width / 2.0  # [1922]
                                        center_char_angle_offset_rad = (
                                            cumulative_width + half_char_width
                                        ) / radius  # [1923]
                                        center_char_math_angle_rad = (
                                            start_arc_math_angle
                                            + angle_sign * center_char_angle_offset_rad
                                        )  # [1924]

                                        char_x = arc_center.x() + radius * math.cos(
                                            center_char_math_angle_rad
                                        )  # [1925]
                                        char_y = arc_center.y() - radius * math.sin(
                                            center_char_math_angle_rad
                                        )  # [1926]

                                        qt_rotation_deg = 90.0 - math.degrees(
                                            center_char_math_angle_rad
                                        )  # [1927]
                                        if curve_angle < 0:
                                            qt_rotation_deg += 180.0  # [1928]

                                        char_rect_local = metrics.boundingRect(
                                            char
                                        )  # [1929]
                                        char_rect_local.translate(
                                            -half_char_width, -metrics.ascent()
                                        )  # [1930]

                                        char_transform = QTransform()  # [1931]
                                        char_transform.translate(
                                            char_x, char_y
                                        )  # [1932]
                                        char_transform.rotate(qt_rotation_deg)  # [1933]

                                        corners_local = [
                                            char_rect_local.topLeft(),
                                            char_rect_local.topRight(),
                                            char_rect_local.bottomRight(),
                                            char_rect_local.bottomLeft(),
                                        ]  # [1934]
                                        all_char_corners.extend(
                                            [
                                                char_transform.map(p)
                                                for p in corners_local
                                            ]
                                        )  # [1935]

                                        cumulative_width += char_width  # [1936]

                                    if all_char_corners:  # [1937]
                                        xs = [p.x() for p in all_char_corners]
                                        ys = [p.y() for p in all_char_corners]  # [1938]
                                        min_x = min(xs)
                                        max_x = max(xs)
                                        min_y = min(ys)
                                        max_y = max(ys)  # [1939]
                                        bounding_rect = QRectF(
                                            min_x, min_y, max_x - min_x, max_y - min_y
                                        )  # [1940]
                                    else:  # [1941]
                                        bounding_rect = QRectF(geo)  # [1942]

                            except Exception as e_calc:  # [1943]
                                print(
                                    f"Error calculating curved text bounds for selection frame: {e_calc}"
                                )  # [1944]
                                bounding_rect = QRectF(geo)  # [1945]
                        else:  # [1946]
                            bounding_rect = QRectF(geo)  # [1947]
                    else:  # [1948]
                        if isinstance(geo, QRectF) and geo.isValid():  # [1949]
                            bounding_rect = QRectF(geo)  # [1950]

                elif shape.is_mpoint_marker and isinstance(geo, QPointF):  # [1951]
                    size = shape.mpoint_size if shape.mpoint_size else 10  # [1952]
                    bounding_rect = QRectF(
                        geo.x() - size / 2, geo.y() - size / 2, size, size
                    )  # [1953]

                elif isinstance(geo, list):  # [1954]
                    valid_points = [p for p in geo if isinstance(p, QPointF)]  # [1955]
                    if valid_points:  # [1956]
                        if shape.type in [
                            "line",
                            "arrow",
                            "angle_marker",
                            "spline",
                        ]:  # [1957]
                            if len(valid_points) >= 2:  # [1958]
                                points_to_consider = valid_points  # [1959]
                                if (
                                    shape.type == "angle_marker"
                                    and len(valid_points) == 3
                                ):  # [1960]
                                    points_to_consider = [
                                        valid_points[0],
                                        valid_points[1],
                                        valid_points[1],
                                        valid_points[2],
                                    ]  # [1961]
                                elif (
                                    shape.type == "spline" and len(valid_points) >= 4
                                ):  # [1962]
                                    control_polygon_points = []  # [1963]
                                    control_polygon_points.append(
                                        valid_points[0]
                                    )  # [1964]
                                    for i in range(
                                        1, len(valid_points) - 1, 3
                                    ):  # [1965]
                                        if i + 2 < len(valid_points):  # [1966]
                                            control_polygon_points.append(
                                                valid_points[i]
                                            )  # [1967]
                                            control_polygon_points.append(
                                                valid_points[i + 1]
                                            )  # [1968]
                                            control_polygon_points.append(
                                                valid_points[i + 2]
                                            )  # [1969]
                                    points_to_consider = (
                                        control_polygon_points  # [1970]
                                    )

                                rotated_points = []  # [1971]
                                rot_center_for_frame = QPointF()  # [1972]
                                if shape.type in ["line", "arrow"]:
                                    rot_center_for_frame = valid_points[0]  # [1973]
                                elif shape.type == "angle_marker":
                                    rot_center_for_frame = valid_points[1]  # [1974]
                                elif shape.type == "spline":  # [1975]
                                    if points_to_consider:
                                        rot_center_for_frame = QPointF(
                                            sum(p.x() for p in points_to_consider)
                                            / len(points_to_consider),
                                            sum(p.y() for p in points_to_consider)
                                            / len(points_to_consider),
                                        )  # [1976]

                                if (
                                    shape.rotation != 0
                                    and not rot_center_for_frame.isNull()
                                ):  # [1977]
                                    transform = (
                                        QTransform()
                                        .translate(
                                            rot_center_for_frame.x(),
                                            rot_center_for_frame.y(),
                                        )
                                        .rotate(shape.rotation)
                                        .translate(
                                            -rot_center_for_frame.x(),
                                            -rot_center_for_frame.y(),
                                        )
                                    )  # [1978]
                                    rotated_points = [
                                        transform.map(p) for p in points_to_consider
                                    ]  # [1979]
                                else:  # [1980]
                                    rotated_points = points_to_consider  # [1981]

                                if not rotated_points:  # [1982]
                                    bounding_rect = None  # [1983]
                                else:  # [1984]
                                    xs = [p.x() for p in rotated_points]  # [1985]
                                    ys = [p.y() for p in rotated_points]  # [1986]
                                    min_x = min(xs)
                                    max_x = max(xs)
                                    min_y = min(ys)
                                    max_y = max(ys)  # [1987]
                                    bounding_rect = QRectF(
                                        min_x,
                                        min_y,
                                        max(1, max_x - min_x),
                                        max(1, max_y - min_y),
                                    )  # [1988]
                        else:  # [1989]
                            xs = [p.x() for p in valid_points]
                            ys = [p.y() for p in valid_points]  # [1990]
                            min_x = min(xs)
                            max_x = max(xs)
                            min_y = min(ys)
                            max_y = max(ys)  # [1991]
                            bounding_rect = QRectF(
                                min_x,
                                min_y,
                                max(1, max_x - min_x),
                                max(1, max_y - min_y),
                            )  # [1992]
                elif isinstance(geo, QRectF) and geo.isValid():  # [1993]
                    if shape.type == "arc":  # [1994]
                        bounding_rect = QRectF(geo)  # [1995]
                    else:  # [1996]
                        bounding_rect = QRectF(geo)  # [1997]

                if bounding_rect and bounding_rect.isValid():  # [1998]
                    if shape.rotation != 0:  # [1999]
                        transform_center_for_frame = QPointF()  # [2000]
                        if shape.type == "arc":  # [2001]
                            transform_center_for_frame = self._get_arc_visual_center(
                                shape
                            )  # [2002]
                        elif (
                            shape.type in ["line", "arrow"]
                            and isinstance(geo, list)
                            and len(geo) > 0
                            and isinstance(geo[0], QPointF)
                        ):  # [2003]
                            transform_center_for_frame = geo[0]  # [2004]
                        elif (
                            shape.type == "angle_marker"
                            and isinstance(geo, list)
                            and len(geo) == 3
                        ):  # [2005]
                            transform_center_for_frame = geo[1]  # [2006]
                        elif (
                            shape.type == "spline" and isinstance(geo, list) and geo
                        ):  # [2007]
                            valid_points_spline_rot = [
                                p for p in geo if isinstance(p, QPointF)
                            ]  # [2008]
                            if valid_points_spline_rot:  # [2009]
                                transform_center_for_frame = QPointF(
                                    sum(p.x() for p in valid_points_spline_rot)
                                    / len(valid_points_spline_rot),
                                    sum(p.y() for p in valid_points_spline_rot)
                                    / len(valid_points_spline_rot),
                                )  # [2010]
                        elif isinstance(geo, QRectF):  # [2011]
                            transform_center_for_frame = geo.center()  # [2012]
                        elif isinstance(geo, QPointF):  # [2013]
                            transform_center_for_frame = geo  # [2014]
                        elif isinstance(geo, list):  # [2015]
                            valid_points_rot = [
                                p for p in geo if isinstance(p, QPointF)
                            ]  # [2016]
                            if valid_points_rot:  # [2017]
                                transform_center_for_frame = QPointF(
                                    sum(p.x() for p in valid_points_rot)
                                    / len(valid_points_rot),
                                    sum(p.y() for p in valid_points_rot)
                                    / len(valid_points_rot),
                                )  # [2018]

                        if not transform_center_for_frame.isNull():  # [2019]
                            transform = QTransform()  # [2020]
                            transform.translate(
                                transform_center_for_frame.x(),
                                transform_center_for_frame.y(),
                            )  # [2021]
                            transform.rotate(shape.rotation)  # [2022]
                            transform.translate(
                                -transform_center_for_frame.x(),
                                -transform_center_for_frame.y(),
                            )  # [2023]
                            bounding_rect = transform.mapRect(bounding_rect)  # [2024]

                    painter.setPen(
                        QPen(QColor("cyan"), 2, Qt.PenStyle.SolidLine)
                    )  # [2025]
                    painter.setBrush(Qt.BrushStyle.NoBrush)  # [2026]
                    painter.drawRect(bounding_rect)  # [2027]

                painter.restore()  # [2028]
            painter.restore()  # [2029]

    def _draw_division_points(self, painter: QPainter, shape: Shape):  # [2030]
        """Draws division points on the segments of the shape."""  # [2031]
        if not self.divide_enabled or self.number_of_divisions < 2:  # [2032]
            return  # [2033]

        division_points_to_draw = []  # [2034]
        geo = shape.geometry  # [2035]

        if (
            shape.type in ["line", "arrow", "line_point"]
            and isinstance(geo, list)
            and len(geo) >= 2
        ):  # [2036]
            for i in range(len(geo) - 1):  # [2037]
                p_start, p_end = geo[i], geo[i + 1]  # [2038]
                if isinstance(p_start, QPointF) and isinstance(
                    p_end, QPointF
                ):  # [2039]
                    segment_vector = p_end - p_start  # [2040]
                    segment_length = math.sqrt(
                        QPointF.dotProduct(segment_vector, segment_vector)
                    )  # [2041]
                    if segment_length < 1e-6:
                        continue  # [2042]
                    step_vector = segment_vector / self.number_of_divisions  # [2043]
                    for j in range(self.number_of_divisions + 1):  # [2044]
                        point = p_start + step_vector * j  # [2045]
                        division_points_to_draw.append(point)  # [2046]

        elif (
            shape.type == "rect" and isinstance(geo, QRectF) and geo.isValid()
        ):  # [2047]
            corners = [
                geo.topLeft(),
                geo.topRight(),
                geo.bottomRight(),
                geo.bottomLeft(),
            ]  # [2048]
            for i in range(4):  # [2049]
                p_start = corners[i]  # [2050]
                p_end = corners[(i + 1) % 4]  # [2051]
                segment_vector = p_end - p_start  # [2052]
                segment_length = math.sqrt(
                    QPointF.dotProduct(segment_vector, segment_vector)
                )  # [2053]
                if segment_length < 1e-6:
                    continue  # [2054]
                step_vector = segment_vector / self.number_of_divisions  # [2055]
                for j in range(self.number_of_divisions + 1):  # [2056]
                    point = p_start + step_vector * j  # [2057]
                    division_points_to_draw.append(point)  # [2058]

        elif (
            shape.type in ["triangle", "polygon", "trapeze", "regular_polygon"]
            and isinstance(geo, list)
            and len(geo) >= 3
        ):  # [2059]
            num_vertices = len(geo)  # [2060]
            for i in range(num_vertices):  # [2061]
                p_start = geo[i]  # [2062]
                p_end = geo[(i + 1) % num_vertices]  # [2063]
                if isinstance(p_start, QPointF) and isinstance(
                    p_end, QPointF
                ):  # [2064]
                    segment_vector = p_end - p_start  # [2065]
                    segment_length = math.sqrt(
                        QPointF.dotProduct(segment_vector, segment_vector)
                    )  # [2066]
                    if segment_length < 1e-6:
                        continue  # [2067]
                    step_vector = segment_vector / self.number_of_divisions  # [2068]
                    for j in range(self.number_of_divisions + 1):  # [2069]
                        point = p_start + step_vector * j  # [2070]
                        division_points_to_draw.append(point)  # [2071]

        elif (
            shape.type == "ellipse" and isinstance(geo, QRectF) and geo.isValid()
        ):  # [2072]
            corners = [
                geo.topLeft(),
                geo.topRight(),
                geo.bottomRight(),
                geo.bottomLeft(),
            ]  # [2073]
            for i in range(4):  # [2074]
                p_start = corners[i]  # [2075]
                p_end = corners[(i + 1) % 4]  # [2076]
                segment_vector = p_end - p_start  # [2077]
                segment_length = math.sqrt(
                    QPointF.dotProduct(segment_vector, segment_vector)
                )  # [2078]
                if segment_length < 1e-6:
                    continue  # [2079]
                step_vector = segment_vector / self.number_of_divisions  # [2080]
                for j in range(self.number_of_divisions + 1):  # [2081]
                    point = p_start + step_vector * j  # [2082]
                    division_points_to_draw.append(point)  # [2083]

        elif (
            shape.type == "arc" and isinstance(geo, QRectF) and geo.isValid()
        ):  # [2084]
            center_arc = geo.center()  # [2085]
            rx = geo.width() / 2.0  # [2086]
            ry = geo.height() / 2.0  # [2087]
            if rx < 1e-6 or ry < 1e-6:
                return  # [2088]

            start_angle_rad = math.radians(shape.startAngle)  # [2089]
            span_angle_rad = math.radians(shape.spanAngle)  # [2090]

            for i in range(self.number_of_divisions + 1):  # [2091]
                current_angle_rad = start_angle_rad + (
                    span_angle_rad * i / self.number_of_divisions
                )  # [2092]
                x = center_arc.x() + rx * math.cos(current_angle_rad)  # [2093]
                y = center_arc.y() - ry * math.sin(current_angle_rad)  # [2094]
                division_points_to_draw.append(QPointF(x, y))  # [2095]
        elif (
            shape.type == "spline"
            and isinstance(geo, list)
            and len(geo) >= 4
            and (len(geo) - 1) % 3 == 0
        ):  # [2096]
            path = QPainterPath(geo[0])  # [2097]
            for i in range(1, len(geo) - 1, 3):  # [2098]
                if i + 2 < len(geo):  # [2099]
                    p_start_segment = geo[i - 1] if i > 0 else geo[0]  # [2100]
                    c1 = geo[i]  # [2101]
                    c2 = geo[i + 1]  # [2102]
                    p_end_segment = geo[i + 2]  # [2103]

                    approx_len = (
                        (c1 - p_start_segment).manhattanLength()  # [2104]
                        + (c2 - c1).manhattanLength()
                        + (p_end_segment - c2).manhattanLength()
                    )  # [2105]
                    if approx_len < 1e-6:
                        continue  # [2106]

                    temp_path_segment = QPainterPath(p_start_segment)  # [2107]
                    temp_path_segment.cubicTo(c1, c2, p_end_segment)  # [2108]

                    for j in range(self.number_of_divisions + 1):  # [2109]
                        percent = float(j) / self.number_of_divisions  # [2110]
                        point_on_segment = temp_path_segment.pointAtPercent(
                            percent
                        )  # [2111]
                        division_points_to_draw.append(point_on_segment)  # [2112]

        if division_points_to_draw:  # [2113]
            painter.save()  # [2114]
            point_color_base = self.division_point_color  # [2115]
            point_radius = self.division_point_size / 2.0  # [2116]

            if point_color_base == QColor(Qt.GlobalColor.yellow):  # [2117]
                if shape.color.isValid() and shape.color.lightnessF() > 0.8:  # [2118]
                    contrasting_color = QColor(Qt.GlobalColor.black)  # [2119]
                else:  # [2120]
                    contrasting_color = QColor(Qt.GlobalColor.yellow)  # [2121]
                point_color_to_use = contrasting_color  # [2122]
            else:  # [2123]
                point_color_to_use = point_color_base  # [2124]

            final_point_color = QColor(point_color_to_use)  # [2125]
            final_point_color.setAlpha(220)  # [2126]

            painter.setPen(QPen(final_point_color, 0.5))  # [2127]
            painter.setBrush(QBrush(final_point_color))  # [2128]

            for point in division_points_to_draw:  # [2129]
                painter.drawEllipse(point, point_radius, point_radius)  # [2130]
            painter.restore()  # [2131]

    def _draw_hatch_fill(self, painter: QPainter, shape: Shape):  # [2132]
        if not shape.hatch_properties or not shape.geometry:  # [2133]
            return  # [2134]

        hatch_style_list = shape.hatch_properties.get("style", [])  # [2135]
        if not hatch_style_list:  # [2136]
            return  # [2137]

        hatch_color = QColor(
            shape.hatch_properties.get("color", Qt.GlobalColor.black)
        )  # [2138]
        if not hatch_color.isValid():  # [2139]
            hatch_color = QColor(Qt.GlobalColor.black)  # [2140]
        hatch_final_alpha = int(shape.alpha * (hatch_color.alpha() / 255.0))  # [2141]
        hatch_color.setAlpha(hatch_final_alpha)  # [2142]

        hatch_thickness = shape.hatch_properties.get("thickness", 1)  # [2143]
        hatch_pen = QPen(hatch_color, hatch_thickness, Qt.PenStyle.SolidLine)  # [2144]
        hatch_pen.setCapStyle(Qt.PenCapStyle.RoundCap)  # [2145]

        painter.save()  # [2146]
        painter.setPen(hatch_pen)  # [2147]
        painter.setBrush(Qt.BrushStyle.NoBrush)  # [2148]

        clip_path = QPainterPath()  # [2149]
        geo = shape.geometry  # [2150]
        if isinstance(geo, QRectF) and geo.isValid():  # [2151]
            if (
                shape.type == "rect" and shape.rounded and shape.corner_radius > 0
            ):  # [2152]
                clip_path.addRoundedRect(
                    geo, shape.corner_radius, shape.corner_radius
                )  # [2153]
            elif shape.type == "rect":  # [2154]
                clip_path.addRect(geo)  # [2155]
            elif shape.type == "ellipse":  # [2156]
                clip_path.addEllipse(geo)  # [2157]
            elif shape.type == "arc":  # [2158]
                clip_path.arcMoveTo(geo, shape.startAngle)  # [2159]
                clip_path.arcTo(geo, shape.startAngle, shape.spanAngle)  # [2160]
                if shape.filled or shape.gradient_properties:  # [2161]
                    center_point = geo.center()  # [2162]
                    clip_path.lineTo(center_point)  # [2163]
                    clip_path.closeSubpath()  # [2164]

        elif isinstance(geo, list):  # [2165]
            valid_points = [p for p in geo if isinstance(p, QPointF)]  # [2166]
            if len(valid_points) >= 3 and shape.type != "spline":  # [2167]
                poly = QPolygonF(valid_points)  # [2168]
                clip_path.addPolygon(poly)  # [2169]
            elif (
                shape.type == "spline"
                and len(valid_points) >= 4
                and (len(valid_points) - 1) % 3 == 0
            ):  # [2170]
                clip_path.moveTo(valid_points[0])  # [2171]
                for i in range(1, len(valid_points) - 1, 3):  # [2172]
                    if i + 2 < len(valid_points):  # [2173]
                        clip_path.cubicTo(
                            valid_points[i], valid_points[i + 1], valid_points[i + 2]
                        )  # [2174]

        elif shape.is_mpoint_marker and isinstance(geo, QPointF):  # [2175]
            size = shape.mpoint_size if shape.mpoint_size else 10  # [2176]
            half_size = size / 2.0  # [2177]
            marker_rect = QRectF(
                geo.x() - half_size, geo.y() - half_size, size, size
            )  # [2178]
            if shape.type == "ellipse":
                clip_path.addEllipse(marker_rect)  # [2179]
            elif shape.type == "rect":
                clip_path.addRect(marker_rect)  # [2180]

        if not clip_path.isEmpty():  # [2181]
            painter.setClipPath(clip_path)  # [2182]
            bounding_rect_for_hatch = clip_path.boundingRect()  # [2183]

            density_factor = hatch_thickness * 5  # [2184]
            if density_factor < 5:
                density_factor = 5  # [2185]

            for hatch_type in hatch_style_list:  # [2186]
                if hatch_type == "forward_slash":  # [2187]
                    for i in range(
                        int(
                            bounding_rect_for_hatch.left()
                            - bounding_rect_for_hatch.height()
                        ),
                        int(
                            bounding_rect_for_hatch.right()
                            + bounding_rect_for_hatch.height()
                        ),
                        int(density_factor),
                    ):  # [2188]
                        painter.drawLine(
                            QPointF(i, bounding_rect_for_hatch.bottom()),
                            QPointF(
                                i + bounding_rect_for_hatch.height(),
                                bounding_rect_for_hatch.top(),
                            ),
                        )  # [2189]
                elif hatch_type == "backward_slash":  # [2190]
                    for i in range(
                        int(
                            bounding_rect_for_hatch.left()
                            - bounding_rect_for_hatch.height()
                        ),
                        int(
                            bounding_rect_for_hatch.right()
                            + bounding_rect_for_hatch.height()
                        ),
                        int(density_factor),
                    ):  # [2191]
                        painter.drawLine(
                            QPointF(i, bounding_rect_for_hatch.top()),
                            QPointF(
                                i + bounding_rect_for_hatch.height(),
                                bounding_rect_for_hatch.bottom(),
                            ),
                        )  # [2192]
                elif hatch_type == "horizontal":  # [2193]
                    for y in range(
                        int(bounding_rect_for_hatch.top()),
                        int(bounding_rect_for_hatch.bottom()),
                        int(density_factor),
                    ):  # [2194]
                        painter.drawLine(
                            QPointF(bounding_rect_for_hatch.left(), y),
                            QPointF(bounding_rect_for_hatch.right(), y),
                        )  # [2195]
                elif hatch_type == "vertical":  # [2196]
                    for x in range(
                        int(bounding_rect_for_hatch.left()),
                        int(bounding_rect_for_hatch.right()),
                        int(density_factor),
                    ):  # [2197]
                        painter.drawLine(
                            QPointF(x, bounding_rect_for_hatch.top()),
                            QPointF(x, bounding_rect_for_hatch.bottom()),
                        )  # [2198]
        painter.restore()  # [2199]

    def _draw_center_point_for_shape(self, painter: QPainter, shape: Shape):  # [2200]
        """Draws the center point for the given shape if self.show_center_point is True."""  # [2201]
        if (
            not self.show_center_point
            or not shape
            or not shape.geometry
            or not shape.visible
        ):  # [2202]
            return  # [2203]

        geo = shape.geometry  # [2204]
        shape_color = QColor(shape.color)  # [2205]
        shape_thickness = shape.line_thickness  # [2206]
        is_shape_filled = (
            shape.filled or shape.gradient_properties or shape.hatch_properties
        )  # [2207]

        center_points_to_draw = []  # [2208]

        if (
            shape.type == "line_point" and isinstance(geo, list) and len(geo) > 1
        ):  # [2209]
            for i in range(len(geo) - 1):  # [2210]
                p1 = geo[i]  # [2211]
                p2 = geo[i + 1]  # [2212]
                if isinstance(p1, QPointF) and isinstance(p2, QPointF):  # [2213]
                    mid_point = (p1 + p2) / 2.0  # [2214]
                    center_points_to_draw.append(
                        (mid_point, shape_color, (shape_thickness + 4) / 2.0)
                    )  # [2215]
        elif shape.type == "line" and isinstance(geo, list) and len(geo) == 2:  # [2216]
            p1, p2 = geo  # [2217]
            if isinstance(p1, QPointF) and isinstance(p2, QPointF):  # [2218]
                center_points_to_draw.append(
                    ((p1 + p2) / 2.0, shape_color, (shape_thickness + 4) / 2.0)
                )  # [2219]
        elif (
            shape.type == "arrow" and isinstance(geo, list) and len(geo) == 2
        ):  # [2220]
            p1_orig, p2_orig = geo  # [2221]
            if isinstance(p1_orig, QPointF) and isinstance(p2_orig, QPointF):  # [2222]
                delta = p2_orig - p1_orig  # [2223]
                length_orig = math.sqrt(delta.x() ** 2 + delta.y() ** 2)  # [2224]
                p1_eff = QPointF(p1_orig)  # [2225]
                p2_eff = QPointF(p2_orig)  # [2226]

                arrow_size = (
                    shape.arrow_head_size if shape.arrow_head_size else 0
                )  # [2227]
                shorten_amount = 0  # [2228]
                if arrow_size > 0 and length_orig > 1e-6:  # [2229]
                    shorten_dist = arrow_size * 0.5  # [2230]
                    shorten_amount = min(
                        max(0, shorten_dist), length_orig * 0.45
                    )  # [2231]

                if shorten_amount > 0:  # [2232]
                    norm_delta = delta / length_orig  # [2233]
                    p2_eff = p2_orig - norm_delta * shorten_amount  # [2234]
                    if shape.double_headed:  # [2235]
                        p1_eff = p1_orig + norm_delta * shorten_amount  # [2236]

                center_points_to_draw.append(
                    ((p1_eff + p2_eff) / 2.0, shape_color, (shape_thickness + 4) / 2.0)
                )  # [2237]
        elif (
            shape.type
            in [
                "rect",
                "ellipse",
                "triangle",
                "trapeze",
                "polygon",
                "regular_polygon",
                "arc",
                "spline",
            ]
            or shape.is_mpoint_marker
        ):  # [2238]
            center = self._get_shape_center(shape)  # [2239]
            if not center.isNull():  # [2240]
                point_radius = 2.0  # [2241]
                point_color = QColor(shape_color)  # [2242]
                if is_shape_filled or shape.type == "spline":  # [2243]
                    if shape_color.lightnessF() > 0.5:  # [2244]
                        point_color = QColor(Qt.GlobalColor.black)  # [2245]
                        point_color.setAlpha(200)  # [2246]
                    else:  # [2247]
                        point_color = QColor(Qt.GlobalColor.white)  # [2248]
                        point_color.setAlpha(200)  # [2249]
                    if (
                        shape.gradient_properties or shape.hatch_properties
                    ) and not shape.filled:  # [2250]
                        point_color = self.center_point_contrast_color  # [2251]

                center_points_to_draw.append(
                    (center, point_color, point_radius)
                )  # [2252]

        if center_points_to_draw:  # [2253]
            painter.save()  # [2254]
            painter.setPen(Qt.PenStyle.NoPen)  # [2255]
            for center, color, radius in center_points_to_draw:  # [2256]
                final_color = QColor(color)  # [2257]
                if final_color != self.center_point_contrast_color:  # [2258]
                    final_color.setAlpha(
                        int(shape.alpha * (final_color.alpha() / 255.0))
                    )  # [2259]

                painter.setBrush(final_color)  # [2260]
                painter.drawEllipse(center, radius, radius)  # [2261]
            painter.restore()  # [2262]

    def draw_resize_handles(self, painter, shape):  # [2263]
        """Draws resize handles for the given shape."""  # [2264]
        if (
            not shape
            or not shape.geometry
            or not shape.visible
            or (shape.is_dimension_part and shape.dimension_type == "text")
            or (
                shape.text_properties
                and shape.text_properties.get("is_angle_display", False)
            )
            or self.temp_mode
        ):  # [2265]
            return  # [2266]

        geo = shape.geometry  # [2267]
        handles_data = []  # [2268]
        transform = QTransform()  # [2269]
        center = QPointF()  # [2270]

        if shape.type == "arc":  # [2271]
            center = self._get_arc_visual_center(shape)  # [2272]
        elif (
            shape.type in ["line", "arrow", "angle_marker"]
            and isinstance(geo, list)
            and len(geo) > 0
            and isinstance(geo[0], QPointF)
        ):  # [2273]
            center = geo[0]  # [2274]
            if shape.type == "angle_marker" and len(geo) == 3:  # [2275]
                center = geo[1]  # [2276]
        elif isinstance(geo, QRectF) and geo.isValid():
            center = geo.center()  # [2277]
        elif isinstance(geo, QPointF):
            center = geo  # [2278]
        elif isinstance(geo, list):  # [2279]
            valid_points = [p for p in geo if isinstance(p, QPointF)]  # [2280]
            if valid_points:
                center = QPointF(
                    sum(p.x() for p in valid_points) / len(valid_points),
                    sum(p.y() for p in valid_points) / len(valid_points),
                )  # [2281]

        if shape.rotation != 0 and not center.isNull():  # [2282]
            transform.translate(center.x(), center.y())  # [2283]
            transform.rotate(shape.rotation)  # [2284]
            transform.translate(-center.x(), -center.y())  # [2285]

        if shape.is_mpoint_marker or shape.is_label:  # [2286]
            return  # [2287]

        if isinstance(geo, QRectF) and geo.isValid():  # [2288]
            if shape.type == "arc":  # [2289]
                rect = geo  # [2290]
                center_unrot = (
                    self._get_arc_visual_center(shape)
                    if hasattr(self, "_get_arc_visual_center")
                    else rect.center()
                )  # [2291]
                rx = rect.width() / 2.0
                ry = rect.height() / 2.0  # [2292]
                start_rad = math.radians(shape.startAngle)
                end_rad = math.radians(shape.startAngle + shape.spanAngle)
                mid_rad = math.radians(
                    shape.startAngle + shape.spanAngle / 2.0
                )  # [2293]

                geom_center_unrot = rect.center()  # [2294]
                start_pt = geom_center_unrot + QPointF(
                    rx * math.cos(start_rad), -ry * math.sin(start_rad)
                )  # [2295]
                end_pt = geom_center_unrot + QPointF(
                    rx * math.cos(end_rad), -ry * math.sin(end_rad)
                )  # [2296]
                mid_pt = geom_center_unrot + QPointF(
                    rx * math.cos(mid_rad), -ry * math.sin(mid_rad)
                )  # [2297]

                rotated_start = transform.map(start_pt)
                rotated_end = transform.map(end_pt)
                rotated_mid = transform.map(mid_pt)  # [2298]
                handles_data.append(("arc_start", rotated_start))  # [2299]
                handles_data.append(("arc_end", rotated_end))  # [2300]
                handles_data.append(("arc_mid", rotated_mid))  # [2301]
            elif shape.type != "text" or not shape.is_dimension_part:  # [2302]
                corners = [
                    geo.topLeft(),
                    geo.topRight(),
                    geo.bottomRight(),
                    geo.bottomLeft(),
                ]  # [2303]
                rotated_corners = [transform.map(p) for p in corners]  # [2304]
                handle_names = [
                    "top_left",
                    "top_right",
                    "bottom_right",
                    "bottom_left",
                ]  # [2305]
                handles_data.extend(zip(handle_names, rotated_corners))  # [2306]
        elif isinstance(geo, list):  # [2307]
            valid_points = [p for p in geo if isinstance(p, QPointF)]  # [2308]
            if valid_points:  # [2309]
                rotated_vertices = [transform.map(p) for p in valid_points]  # [2310]
                if (
                    shape.type == "angle_marker" and len(rotated_vertices) == 3
                ):  # [2311]
                    handles_data.append(("vertex_A", rotated_vertices[0]))  # [2312]
                    handles_data.append(("vertex_O", rotated_vertices[1]))  # [2313]
                    handles_data.append(("vertex_B", rotated_vertices[2]))  # [2314]
                elif shape.type == "spline":  # [2315]
                    handles_data.extend(
                        [(f"vertex_{i}", p) for i, p in enumerate(rotated_vertices)]
                    )  # [2316]
                else:  # [2317]
                    handles_data.extend(
                        [(f"vertex_{i}", p) for i, p in enumerate(rotated_vertices)]
                    )  # [2318]

        if handles_data:  # [2319]
            painter.setPen(QPen(QColor(0, 255, 0), 1))  # [2320]
            painter.setBrush(QBrush(QColor(0, 255, 0, 180)))  # [2321]
            handle_size_f = float(self.handle_size)  # [2322]
            offset = handle_size_f / 2.0  # [2323]
            for handle_name, pos in handles_data:  # [2324]
                handle_rect = QRectF(
                    pos.x() - offset, pos.y() - offset, handle_size_f, handle_size_f
                )  # [2325]
                if (
                    self.active_angle_shape_for_point_drag == shape
                    and self.active_angle_point_handle == handle_name
                ):  # [2326]
                    painter.setBrush(QBrush(QColor(255, 0, 0, 200)))  # [2327]
                else:  # [2328]
                    painter.setBrush(QBrush(QColor(0, 255, 0, 180)))  # [2329]
                painter.drawRect(handle_rect)  # [2330]

    def schedule_shape_removal(self, shape_to_remove):  # [2331]
        """Schedules shape removal after a specified time in TEMP mode."""  # [2332]
        if not self.temp_mode:  # [2333]
            return  # [2334]
        duration_ms = int(self.temp_mode_shape_duration * 1000)  # [2335]
        QTimer.singleShot(
            duration_ms, lambda: self._remove_temp_shape(shape_to_remove)
        )  # [2336]

    def _remove_temp_shape(self, shape_to_remove):  # [2337]
        """Removes a shape from the shapes list (called by timer)."""  # [2338]
        try:  # [2339]
            if shape_to_remove in self.shapes:  # [2340]
                self.shapes.remove(shape_to_remove)  # [2341]
                if shape_to_remove in self.selected_shapes:  # [2342]
                    self.selected_shapes.remove(shape_to_remove)  # [2343]
                self.update()  # [2344]
        except Exception as e:  # [2345]
            print(f"Error removing temp shape: {e}")  # [2346]
            traceback.print_exc()  # [2347]

    @Slot(bool)  # [2348]
    def set_drawing_mode(
        self, enabled, called_from_hotkey=False, called_from_loadimg_exit=False
    ):  # [2349]
        """# [2350]
        Enables or disables drawing mode. # [2351]
        """  # [2352]
        if not enabled:  # [2353]
            if self.show_angle_offset:  # [2354]
                print("Exiting drawing mode, hiding angle offset.")  # [2355]
                self.show_angle_offset = False  # [2356]
                self.angle_offsets.clear()  # [2357]
            self._reset_next_mpoint_label()  # [2358]
            if self.input_mode:  # [2359]
                print(
                    f"Cancelling input mode '{self.input_mode}' due to drawing mode exit."
                )  # [2360]
                self.input_mode = None  # [2361]
            if self.current_tool == "dimension" and self.dimension_points:  # [2362]
                print("Cancelling dimensioning due to drawing mode exit.")  # [2363]
                self.dimension_points.clear()  # [2364]
                self.dimension_preview_shapes.clear()  # [2365]
                self.dimension_preview_line_color = QColor(0, 255, 255, 100)  # [2366]
                self.dimension_preview_color_explicitly_set = False  # [2367]
            if self.current_tool == "angle_marker" and self.angle_points:  # [2368]
                print("Cancelling angle drawing due to drawing mode exit.")  # [2369]
                self.angle_points.clear()  # [2370]
            if self.current_tool == "spline" and self.spline_points:  # [2371]
                print("Cancelling spline drawing due to drawing mode exit.")  # [2372]
                self.spline_points.clear()  # [2373]
            if called_from_loadimg_exit:  # [2374]
                if self._indicator_state_before_image_load is not None:  # [2375]
                    print(
                        "Restoring indicator state after exiting image load mode."
                    )  # [2376]
                    self.set_show_tool_text(
                        self._indicator_state_before_image_load
                    )  # [2377]
                    self._indicator_state_before_image_load = None  # [2378]
                self._entered_edit_via_loadimg = False  # [2379]

        if self.drawing_mode == enabled:  # [2380]
            self.drawing_mode_changed.emit(self.drawing_mode)  # [2381]
            return  # [2382]

        if not enabled and (
            self.board_mode or self.edit_mode or self.temp_mode
        ):  # [2383]
            success = True  # [2384]
            if self.board_mode or self.edit_mode:  # [2385]
                success = self.exit_board_mode(
                    ask_save=False, configure=False
                )  # [2386]
            elif self.temp_mode:  # [2387]
                success = self.exit_temp_mode(configure=False)  # [2388]

            if not success:  # [2389]
                if self.control_panel:  # [2390]
                    self.control_panel.update_draw_button_state(True)  # [2391]
                    self.control_panel.update_edit_mode_button_visuals(
                        self.edit_mode
                    )  # [2392]
                    self.control_panel.update_board_mode_button_visuals(
                        self.board_mode and not self.edit_mode
                    )  # [2393]
                    self.control_panel.update_temp_mode_button_visuals(
                        self.temp_mode
                    )  # [2394]
                return  # [2395]

        if not enabled:  # [2396]
            if self.board_mode:
                self.board_mode = False
                self.board_mode_changed.emit(False)  # [2397]
            if self.edit_mode:
                self.edit_mode = False
                self.edit_mode_changed.emit(False)  # [2398]
            if self.temp_mode:
                self.temp_mode = False
                self.temp_mode_changed.emit(False)  # [2399]
            self._entered_edit_via_loadimg = False  # [2400]

        self.drawing_mode = enabled  # [2401]
        print(f"Drawing mode set to: {self.drawing_mode}")  # [2402]

        self.selected_shapes = []  # [2403]
        self.current_drawing_shape = None  # [2404]
        self.polygon_points = []  # [2405]
        self.angle_points = []  # [2406]
        self.brush_points = []  # [2407]
        self.spline_points = []  # [2408]
        self.resizing = False  # [2409]
        self.dragging = False  # [2410]
        self.drag_start_pos = None  # [2411]
        self.drag_start_geometries = {}  # [2412]
        self.resize_handle = None  # [2413]
        self.is_lasso_selecting = False  # [2414]
        if enabled:  # [2415]
            self.dimension_points.clear()  # [2416]
            self.dimension_preview_shapes.clear()  # [2417]
        if enabled:  # [2418]
            self.angle_points.clear()  # [2419]
        if enabled:  # [2420]
            self.spline_points.clear()  # [2421]
        self.active_angle_shape_for_point_drag = None  # [2422]
        self.active_angle_point_handle = None  # [2423]

        if enabled:  # [2424]
            self.show_angle_offset = False  # [2425]
            self.angle_offsets.clear()  # [2426]

        if (
            enabled
            and not self.board_mode
            and not self.edit_mode
            and not self.temp_mode
            and self.control_panel
        ):  # [2427]
            self.dim_background = self.control_panel.dim_check.isChecked()  # [2428]
            self.show_tool_text = (
                self.control_panel.tool_text_check.isChecked()
            )  # [2429]
            print(
                f"Reapplied NORMAL draw settings: dim_background={self.dim_background}, show_tool_text={self.show_tool_text}"
            )  # [2430]

        if called_from_hotkey:  # [2431]
            QTimer.singleShot(50, self._configure_mode)  # [2432]
        else:  # [2433]
            self._configure_mode()  # [2434]

        self.drawing_mode_changed.emit(self.drawing_mode)  # [2435]

    @Slot(QColor)  # [2436]
    def set_pen_color(self, color):  # [2437]
        """Sets the pen color for NORMAL drawing mode."""  # [2438]
        if isinstance(color, QColor) and color.isValid():  # [2439]
            if color != self.current_pen_color:  # [2440]
                self.current_pen_color = color  # [2441]
                self._clear_gradient_for_selection()  # [2442]
                self._clear_hatch_for_selection()  # [2443]
                self.color_changed.emit(color)  # [2444]

                if not self.dimension_preview_color_explicitly_set:  # [2445]
                    new_preview_color = QColor(self.current_pen_color)  # [2446]
                    new_preview_color.setAlpha(100)  # [2447]
                    self.set_dimension_preview_line_color(
                        new_preview_color, from_pen_color_change=True
                    )  # [2448]

                self.update()  # [2449]

    @Slot(QColor)  # [2450]
    def set_edit_pen_color(self, color):  # [2451]
        """Sets the pen color for EDIT drawing mode."""  # [2452]
        if isinstance(color, QColor) and color.isValid():  # [2453]
            if color != self.current_pen_color_edit:  # [2454]
                self.current_pen_color_edit = color  # [2455]
                self._clear_gradient_for_selection()  # [2456]
                self._clear_hatch_for_selection()  # [2457]
                self.edit_pen_color_changed.emit(color)  # [2458]
                if self.edit_mode:  # [2459]
                    self.update()  # [2460]

    @Slot(QColor)  # [2461]
    def set_board_pen_color_only(self, color):  # [2462]
        """Sets the pen color for BOARD-only (non-EDIT) drawing mode."""  # [2463]
        if isinstance(color, QColor) and color.isValid():  # [2464]
            if color != self.current_pen_color_board_only:  # [2465]
                self.current_pen_color_board_only = color  # [2466]
                self._clear_gradient_for_selection()  # [2467]
                self._clear_hatch_for_selection()  # [2468]
                self.board_pen_color_changed.emit(color)  # [2469]
                if self.board_mode and not self.edit_mode:  # [2470]
                    self.update()  # [2471]

    @Slot(QColor)  # [2472]
    def set_board_background_color(self, color):  # [2473]
        """Sets the background color for BOARD mode."""  # [2474]
        if isinstance(color, QColor) and color.isValid():  # [2475]
            if color != self.board_background_color:  # [2476]
                prev_bg_color = deepcopy(self.board_background_color)  # [2477]
                self.save_state(
                    "change_board_bg", previous_geometries={"board_bg": prev_bg_color}
                )  # [2478]
                self.board_background_color = color  # [2479]
                self.board_background_color_changed.emit(color)  # [2480]
                self.update()  # [2481]

    @Slot(QColor)  # [2482]
    def set_temp_pen_color(self, color):  # [2483]
        """Sets the pen color for TEMP mode."""  # [2484]
        if isinstance(color, QColor) and color.isValid():  # [2485]
            if color != self.current_pen_color_temp:  # [2486]
                self.current_pen_color_temp = color  # [2487]
                self._clear_gradient_for_selection()  # [2488]
                self._clear_hatch_for_selection()  # [2489]
                self.temp_color_changed.emit(color)  # [2490]
                if self.temp_mode:  # [2491]
                    self.update()  # [2492]

    def _clear_gradient_for_selection(self):  # [2493]
        """Clears gradient properties for currently selected shapes."""  # [2494]
        if self.selected_shapes:  # [2495]
            changed = False  # [2496]
            for shape in self.selected_shapes:  # [2497]
                if shape.gradient_properties:  # [2498]
                    shape.gradient_properties = None  # [2499]
                    changed = True  # [2500]

    def _clear_hatch_for_selection(self):  # [2501]
        """Clears hatch properties for currently selected shapes."""  # [2502]
        if self.selected_shapes:  # [2503]
            changed = False  # [2504]
            for shape in self.selected_shapes:  # [2505]
                if shape.hatch_properties:  # [2506]
                    shape.hatch_properties = None  # [2507]
                    changed = True  # [2508]

    @Slot(int)  # [2509]
    def set_alpha(self, alpha_percent):  # [2510]
        """Sets the alpha for shapes based on a percentage value (0-100)."""  # [2511]
        alpha_percent = max(0, min(100, alpha_percent))  # [2512]
        alpha_255 = round(alpha_percent * 2.55)  # [2513]
        alpha_255 = max(0, min(255, alpha_255))  # [2514]

        if alpha_255 != self.current_alpha:  # [2515]
            self.current_alpha = alpha_255  # [2516]
            if self.selected_shapes:  # [2517]
                prev_props = {}  # [2518]
                current_indices = []  # [2519]
                changed_shapes = []  # [2520]
                for shape in self.selected_shapes:  # [2521]
                    if shape.alpha != self.current_alpha:  # [2522]
                        try:  # [2523]
                            shape_idx = self.shapes.index(shape)  # [2524]
                            current_indices.append(shape_idx)  # [2525]
                            prev_props[shape_idx] = shape.alpha  # [2526]
                            shape.alpha = self.current_alpha  # [2527]
                            changed_shapes.append(shape)  # [2528]
                        except ValueError:  # [2529]
                            continue  # [2530]
                if changed_shapes:  # [2531]
                    self.save_state(
                        "change_alpha",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )  # [2532]
                    self.update()  # [2533]
            else:  # [2534]
                self.update()  # [2535]

    @Slot(bool)  # [2536]
    def set_dim_background(self, dim_enabled):  # [2537]
        """Sets whether the background is dimmed in NORMAL drawing mode."""  # [2538]
        if self.dim_background != dim_enabled:  # [2539]
            self.dim_background = dim_enabled  # [2540]
            if self.drawing_mode:  # [2541]
                self._configure_mode()  # [2542]
                self.update()  # [2543]

    @Slot(int)  # [2544]
    def set_line_thickness(self, thickness):  # [2545]
        """Sets the line thickness."""  # [2546]
        thickness = max(1, thickness)  # [2547]
        if thickness != self.current_line_thickness:  # [2548]
            self.current_line_thickness = thickness  # [2549]
            if self.selected_shapes:  # [2550]
                prev_props = {}  # [2551]
                current_indices = []  # [2552]
                changed_shapes = []  # [2553]
                for shape in self.selected_shapes:  # [2554]
                    if shape.line_thickness != self.current_line_thickness:  # [2555]
                        try:  # [2556]
                            shape_idx = self.shapes.index(shape)  # [2557]
                            current_indices.append(shape_idx)  # [2558]
                            prev_props[shape_idx] = shape.line_thickness  # [2559]
                            shape.line_thickness = self.current_line_thickness  # [2560]
                            changed_shapes.append(shape)  # [2561]
                        except ValueError:  # [2562]
                            continue  # [2563]
                if changed_shapes:  # [2564]
                    self.save_state(
                        "change_line_thickness",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )  # [2565]
                    self.update()  # [2566]
            else:  # [2567]
                self.update()  # [2568]

    @Slot(int, object)  # [2569]
    def set_line_style(self, style_value, pattern=None):  # [2570]
        """Sets the current line style and optional custom pattern."""  # [2571]
        try:  # [2572]
            style = Qt.PenStyle(style_value)  # [2573]
            new_pattern = None  # [2574]
            if pattern and style == Qt.PenStyle.CustomDashLine:  # [2575]
                if isinstance(pattern, list) and all(
                    isinstance(x, (int, float)) for x in pattern
                ):  # [2576]
                    new_pattern = pattern  # [2577]
                else:  # [2578]
                    print(
                        f"Warning: Invalid pattern received for CustomDashLine: {pattern}. Resetting pattern."
                    )  # [2579]
                    new_pattern = None  # [2580]
            else:  # [2581]
                new_pattern = None  # [2582]

            if (
                style != self.current_line_style
                or new_pattern != self.current_line_pattern
            ):  # [2583]
                self.current_line_style = style  # [2584]
                self.current_line_pattern = new_pattern  # [2585]

                if self.selected_shapes:  # [2586]
                    changed = False  # [2587]
                    prev_props = {}  # [2588]
                    current_indices = []  # [2589]
                    changed_shapes = []  # [2590]
                    for shape in self.selected_shapes:  # [2591]
                        if (
                            shape.line_style != self.current_line_style
                            or shape.line_pattern != self.current_line_pattern
                        ):  # [2592]
                            try:  # [2593]
                                shape_idx = self.shapes.index(shape)  # [2594]
                                current_indices.append(shape_idx)  # [2595]
                                prev_props[shape_idx] = (
                                    shape.line_style,
                                    shape.line_pattern,
                                )  # [2596]
                                shape.line_style = self.current_line_style  # [2597]
                                shape.line_pattern = self.current_line_pattern  # [2598]
                                changed_shapes.append(shape)  # [2599]
                                changed = True  # [2600]
                            except ValueError:  # [2601]
                                continue  # [2602]
                    if changed:  # [2603]
                        self.save_state(
                            "change_line_style",
                            shapes_involved=changed_shapes,
                            previous_geometries=prev_props,
                            indices=current_indices,
                        )  # [2604]
                        self.update()  # [2605]
                else:  # [2606]
                    self.update()  # [2607]

        except ValueError:  # [2608]
            print(f"Invalid line style value: {style_value}")  # [2609]
            if (
                self.current_line_style != Qt.PenStyle.SolidLine
                or self.current_line_pattern is not None
            ):  # [2610]
                self.current_line_style = Qt.PenStyle.SolidLine  # [2611]
                self.current_line_pattern = None  # [2612]
                self.update()  # [2613]

    @Slot(int)  # [2614]
    def set_arrow_head_size(self, size):  # [2615]
        """Sets the arrow head size."""  # [2616]
        size = max(1, size)  # [2617]
        if size != self.current_arrow_head_size:  # [2618]
            self.current_arrow_head_size = size  # [2619]
            if self.selected_shapes:  # [2620]
                changed = False  # [2621]
                prev_props = {}  # [2622]
                current_indices = []  # [2623]
                changed_shapes = []  # [2624]
                for shape in self.selected_shapes:  # [2625]
                    if (
                        (
                            shape.type == "arrow"
                            or (
                                shape.type == "line_point"
                                and shape.line_point_arrow_style
                            )
                            or (shape.type == "spline" and shape.line_point_arrow_style)
                        )
                        and shape.arrow_head_size != self.current_arrow_head_size
                    ):  # [2626]
                        try:  # [2627]
                            shape_idx = self.shapes.index(shape)  # [2628]
                            current_indices.append(shape_idx)  # [2629]
                            prev_props[shape_idx] = shape.arrow_head_size  # [2630]
                            shape.arrow_head_size = (
                                self.current_arrow_head_size
                            )  # [2631]
                            changed_shapes.append(shape)  # [2632]
                            changed = True  # [2633]
                        except ValueError:  # [2634]
                            continue  # [2635]
                if changed:  # [2636]
                    self.save_state(
                        "resize",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )  # [2637]
                    self.update()  # [2638]
            else:  # [2639]
                self.update()  # [2640]

    @Slot(int)  # [2641]
    def set_arc_span_angle(self, angle):  # [2642]
        """Sets the default span angle for newly drawn arcs."""  # [2643]
        angle = max(1, min(360, angle))  # [2644]
        if self.current_arc_span_angle != angle:  # [2645]
            self.current_arc_span_angle = angle  # [2646]

    @Slot(float)  # [2647]
    def set_temp_mode_duration(self, seconds):  # [2648]
        """Sets the duration for shapes in TEMP mode."""  # [2649]
        duration = max(0.1, seconds)  # [2650]
        if duration != self.temp_mode_shape_duration:  # [2651]
            self.temp_mode_shape_duration = duration  # [2652]

    @Slot(dict)  # [2653]
    def update_default_text_properties(self, new_defaults):  # [2654]
        """Slot to update default text properties from the control panel (Normal mode)."""  # [2655]
        self.default_text_properties.update(new_defaults)  # [2656]

    @Slot(bool)  # [2657]
    def set_show_tool_text(self, show):  # [2658]
        """Slot to set whether tool text/indicators are shown."""  # [2659]
        if self.show_tool_text != show:  # [2660]
            self.show_tool_text = show  # [2661]
            if self.board_mode or self.edit_mode:
                self.show_indicators_in_board_mode = show  # [2662]
            elif self.temp_mode:
                self.show_indicators_in_temp_mode = show  # [2663]

            if self.control_panel:  # [2664]
                self.control_panel.tool_text_check.blockSignals(True)  # [2665]
                self.control_panel.tool_text_check.setChecked(show)  # [2666]
                self.control_panel.tool_text_check.blockSignals(False)  # [2667]

            self.update()  # [2668]

    @Slot(bool)  # [2669]
    def set_show_center_point(self, show):  # [2670]
        """Slot to set whether center points are shown."""  # [2671]
        if self.show_center_point != show:  # [2672]
            self.show_center_point = show  # [2673]
            print(f"Show center point set to: {self.show_center_point}")  # [2674]
            self.show_center_point_changed.emit(show)  # [2675]
            self.update()  # [2676]

    @Slot(str)  # [2677]
    def set_line_point_arrow_style(self, style):  # [2678]
        """Sets the arrow style for line_point and spline tools ('1a', '2a', or None)."""  # [2679]
        if style not in [None, "1a", "2a"]:  # [2680]
            print(
                f"Warning: Invalid line_point_arrow_style '{style}'. Using None."
            )  # [2681]
            style = None  # [2682]

        if self.current_line_point_arrow_style != style:  # [2683]
            self.current_line_point_arrow_style = style  # [2684]
            print(f"Line Point / Spline arrow style set to: {style}")  # [2685]
            self.line_point_arrow_style_changed.emit(style)  # [2686]

            if self.selected_shapes:  # [2687]
                changed_shapes = []  # [2688]
                prev_props = {}  # [2689]
                current_indices = []  # [2690]
                for shape in self.selected_shapes:  # [2691]
                    if shape.type in ["line_point", "spline"]:  # [2692]
                        try:  # [2693]
                            idx = self.shapes.index(shape)  # [2694]
                            prev_props[idx] = deepcopy(shape)  # [2695]
                            shape.line_point_arrow_style = (
                                self.current_line_point_arrow_style
                            )  # [2696]
                            if self.current_line_point_arrow_style:  # [2697]
                                shape.arrow_head_size = (
                                    self.current_arrow_head_size
                                )  # [2698]
                            else:  # [2699]
                                shape.arrow_head_size = None  # [2700]
                            changed_shapes.append(shape)  # [2701]
                            current_indices.append(idx)  # [2702]
                        except ValueError:  # [2703]
                            continue  # [2704]
                if changed_shapes:  # [2705]
                    self.save_state(
                        "change_line_point_arrow_style",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )  # [2706]
                    self.update()  # [2707]
            elif self.drawing_mode and self.current_tool in [
                "line_point",
                "spline",
            ]:  # [2708]
                self.update()  # [2709]

    @Slot(bool)  # [2710]
    def set_divide_enabled(self, enabled):  # [2711]
        """Enables or disables shape division mode."""  # [2712]
        if self.divide_enabled != enabled:  # [2713]
            self.divide_enabled = enabled  # [2714]
            print(f"Divide mode {'enabled' if enabled else 'disabled'}")  # [2715]
            self.divide_enabled_changed.emit(enabled)  # [2716]
            self.update()  # [2717]

    @Slot(int)  # [2718]
    def set_number_of_divisions(self, num_divisions):  # [2719]
        """Sets the number of parts to divide a shape into."""  # [2720]
        num_divisions = max(2, num_divisions)  # [2721]
        if self.number_of_divisions != num_divisions:  # [2722]
            self.number_of_divisions = num_divisions  # [2723]
            print(f"Number of divisions set to: {num_divisions}")  # [2724]
            self.number_of_divisions_changed.emit(num_divisions)  # [2725]
            if self.divide_enabled:  # [2726]
                self.update()  # [2727]

    @Slot(QColor)  # [2728]
    def set_division_point_color(self, color):  # [2729]
        """Sets the color of division points."""  # [2730]
        if isinstance(color, QColor) and color.isValid():  # [2731]
            if self.division_point_color != color:  # [2732]
                self.division_point_color = color  # [2733]
                self.division_point_color_changed.emit(color)  # [2734]
                print(f"Division point color set to: {color.name()}")  # [2735]
                if self.divide_enabled:
                    self.update()  # [2736]
        else:  # [2737]
            print(
                f"Warning: Invalid color received for division points: {color}"
            )  # [2738]

    @Slot(float)  # [2739]
    def set_division_point_size(self, size):  # [2740]
        """Sets the size (diameter) of division points."""  # [2741]
        size = max(1.0, min(20.0, size))  # [2742]
        if abs(self.division_point_size - size) > 1e-3:  # [2743]
            self.division_point_size = size  # [2744]
            self.division_point_size_changed.emit(size)  # [2745]
            print(f"Division point size set to: {size}")  # [2746]
            if self.divide_enabled:
                self.update()  # [2747]

    def _get_current_mode_pen_color(self):  # [2748]
        """Returns the appropriate pen color based on the current mode."""  # [2749]
        if self.edit_mode:  # [2750]
            return self.current_pen_color_edit  # [2751]
        elif self.board_mode:  # [2752]
            return self.current_pen_color_board_only  # [2753]
        elif self.temp_mode:  # [2754]
            return self.current_pen_color_temp  # [2755]
        elif self.current_tool == "angle_marker":  # [2756]
            return self.current_angle_tool_line_color  # [2757]
        else:  # [2758]
            return self.current_pen_color  # [2759]

    def _enter_board_or_edit_mode(self, edit_mode=False):  # [2760]
        """Common logic for entering BOARD or EDIT mode."""  # [2761]
        mode_name = "EDIT" if edit_mode else "BOARD"  # [2762]
        print(f"Entering {mode_name} mode")  # [2763]

        if self.temp_mode:
            self.exit_temp_mode(configure=False)  # [2764]
        if self.input_mode:  # [2765]
            print(
                f"Cancelling input mode '{self.input_mode}' due to mode change."
            )  # [2766]
            self.input_mode = None  # [2767]
        if self.current_tool == "dimension" and self.dimension_points:  # [2768]
            print("Cancelling dimensioning due to mode change.")  # [2769]
            self.dimension_points.clear()  # [2770]
            self.dimension_preview_shapes.clear()  # [2771]
        if self.current_tool == "angle_marker" and self.angle_points:  # [2772]
            print("Cancelling angle drawing due to mode change.")  # [2773]
            self.angle_points.clear()  # [2774]
        if self.current_tool == "spline" and self.spline_points:  # [2775]
            print("Cancelling spline drawing due to mode change.")  # [2776]
            self.spline_points.clear()  # [2777]

        self.board_mode = True  # [2778]
        self.edit_mode = edit_mode  # [2779]
        self.temp_mode = False  # [2780]

        if edit_mode:  # [2781]
            print(
                "EDIT mode active: Using forced transparent background (alpha=1)."
            )  # [2782]
        else:  # [2783]
            if self.board_background_color.alpha() < 5:  # [2784]
                self.board_background_color = QColor(Qt.GlobalColor.white)  # [2785]
                print(
                    "BOARD mode started with transparent saved BG, defaulting to white."
                )  # [2786]

        self.show_indicators_in_board_mode = self.show_tool_text  # [2787]

        self.show_angle_offset = False  # [2788]
        self.angle_offsets.clear()  # [2789]
        self._reset_next_mpoint_label()  # [2790]
        self.active_angle_shape_for_point_drag = None  # [2791]
        self.active_angle_point_handle = None  # [2792]

        if not self.drawing_mode:  # [2793]
            self.set_drawing_mode(True)  # [2794]
        else:  # [2795]
            self._configure_mode()  # [2796]
            self.update()  # [2797]

        self.board_mode_changed.emit(self.board_mode and not self.edit_mode)  # [2798]
        self.edit_mode_changed.emit(self.edit_mode)  # [2799]
        self.temp_mode_changed.emit(False)  # [2800]

    @Slot()  # [2801]
    def enter_board_mode(self):  # [2802]
        """Enters BOARD mode."""  # [2803]
        self._enter_board_or_edit_mode(edit_mode=False)  # [2804]

    @Slot()  # [2805]
    def enter_edit_mode(self):  # [2806]
        """Enters EDIT mode."""  # [2807]
        self._enter_board_or_edit_mode(edit_mode=True)  # [2808]

    def exit_board_mode(
        self, ask_save=False, configure=True, skip_shape_clear_question=False
    ):  # [2809]
        """Exits BOARD or EDIT mode."""  # [2810]
        if not self.board_mode and not self.edit_mode:
            return True  # [2811]

        clear_board = False  # [2812]
        ask_question = (
            not skip_shape_clear_question
            and not self._entered_edit_via_loadimg
            and self.control_panel
            and self.control_panel.clear_warning_check.isChecked()
        )  # [2813]

        if ask_question:  # [2814]
            reply = QMessageBox.question(
                self,
                "Exit Board/Edit Mode",  # [2815]
                "Clear the board before exiting?",  # [2816]
                QMessageBox.StandardButton.Yes
                | QMessageBox.StandardButton.No
                | QMessageBox.StandardButton.Cancel,  # [2817]
                QMessageBox.StandardButton.Cancel,
            )  # [2818]

            if reply == QMessageBox.StandardButton.Cancel:  # [2819]
                print("Board/Edit mode exit cancelled.")  # [2820]
                if self.control_panel:  # [2821]
                    self.control_panel.update_draw_button_state(True)  # [2822]
                    self.control_panel.update_edit_mode_button_visuals(
                        self.edit_mode
                    )  # [2823]
                    self.control_panel.update_board_mode_button_visuals(
                        self.board_mode and not self.edit_mode
                    )  # [2824]
                    self.control_panel.update_temp_mode_button_visuals(
                        self.temp_mode
                    )  # [2825]
                return False  # [2826]
            clear_board = reply == QMessageBox.StandardButton.Yes  # [2827]
        elif (
            not skip_shape_clear_question and not self._entered_edit_via_loadimg
        ):  # [2828]
            print("Skipping clear confirmation based on 'Clear W.' checkbox.")  # [2829]

        print("Exiting BOARD/EDIT mode")  # [2830]
        was_board = self.board_mode  # [2831]
        was_edit = self.edit_mode  # [2832]
        was_loadimg_edit = self._entered_edit_via_loadimg  # [2833]

        self.board_mode = False  # [2834]
        self.edit_mode = False  # [2835]

        self.show_angle_offset = False  # [2836]
        self.angle_offsets.clear()  # [2837]
        self._reset_next_mpoint_label()  # [2838]
        self.active_angle_shape_for_point_drag = None  # [2839]
        self.active_angle_point_handle = None  # [2840]

        self.save_board_settings()  # [2841]

        if clear_board:  # [2842]
            print("Clearing board.")  # [2843]
            self.clear_scene(save_undo=False)  # [2844]

        if self.control_panel:  # [2845]
            self.dim_background = self.control_panel.dim_check.isChecked()  # [2846]
        else:  # [2847]
            self.dim_background = True  # [2848]

        try:  # [2849]
            default_draw_color_str = QColor(255, 0, 0).name(
                QColor.NameFormat.HexArgb
            )  # [2850]
            saved_draw_color_str = self.settings.value(
                "controlPanel/drawPenColor", default_draw_color_str
            )  # [2851]
            restored_draw_color = QColor(saved_draw_color_str)  # [2852]
            if not restored_draw_color.isValid():  # [2853]
                restored_draw_color = QColor(default_draw_color_str)  # [2854]

            if self.current_pen_color != restored_draw_color:  # [2855]
                self.current_pen_color = restored_draw_color  # [2856]
                self.color_changed.emit(self.current_pen_color)  # [2857]
        except Exception as e:  # [2858]
            print(f"Error restoring normal draw pen color: {e}")  # [2859]
            traceback.print_exc()  # [2860]
            if (
                not hasattr(self, "current_pen_color")
                or not self.current_pen_color.isValid()
            ):  # [2861]
                self.current_pen_color = QColor(255, 0, 0)  # [2862]
                self.color_changed.emit(self.current_pen_color)  # [2863]
                print("Set drawing color to default red as a final fallback.")  # [2864]

        if was_board:
            self.board_mode_changed.emit(False)  # [2865]
        if was_edit:
            self.edit_mode_changed.emit(False)  # [2866]

        if configure:  # [2867]
            self.set_drawing_mode(
                False, called_from_loadimg_exit=was_loadimg_edit
            )  # [2868]

        return True  # [2869]

    def save_board_settings(self):  # [2870]
        """Saves current board-related settings (edit pen, board pen, bg, text defaults)."""  # [2871]
        try:  # [2872]
            self.settings.beginGroup("board")  # [2873]
            self.settings.setValue(
                "penColorEdit",
                self.current_pen_color_edit.name(QColor.NameFormat.HexArgb),
            )  # [2874]
            self.settings.setValue(
                "penColorBoard",
                self.current_pen_color_board_only.name(QColor.NameFormat.HexArgb),
            )  # [2875]
            self.settings.setValue(
                "backgroundColor",
                self.board_background_color.name(QColor.NameFormat.HexArgb),
            )  # [2876]
            if hasattr(self, "board_default_text_properties"):  # [2877]
                defaults = self.board_default_text_properties  # [2878]
                self.settings.beginGroup("textDefaults")  # [2879]
                self.settings.setValue("font", defaults.get("font", "Arial"))  # [2880]
                self.settings.setValue("size", defaults.get("size", 14))  # [2881]
                self.settings.setValue("bold", defaults.get("bold", False))  # [2882]
                self.settings.setValue(
                    "italic", defaults.get("italic", False)
                )  # [2883]
                self.settings.setValue(
                    "underline", defaults.get("underline", False)
                )  # [2884]
                self.settings.setValue(
                    "strikeout", defaults.get("strikeout", False)
                )  # [2885]
                self.settings.setValue(
                    "color", defaults.get("color", "#000000")
                )  # [2886]
                self.settings.setValue(
                    "backgroundColor", defaults.get("background_color")
                )  # [2887]
                self.settings.setValue(
                    "alignment", defaults.get("alignment", "left")
                )  # [2888]
                self.settings.setValue(
                    "curve_angle", defaults.get("curve_angle", 0)
                )  # [2889]
                self.settings.endGroup()  # [2890]
            self.settings.endGroup()  # [2891]
            self.settings.sync()  # [2892]
        except Exception as e:
            print(f"Error saving BOARD settings: {e}")  # [2893]

    def load_board_settings(self):  # [2894]
        """Loads board-related settings (edit pen, board pen, bg, text defaults)."""  # [2895]
        try:  # [2896]
            self.settings.beginGroup("board")  # [2897]
            edit_pen_color_str = self.settings.value(
                "penColorEdit",
                QColor(Qt.GlobalColor.black).name(QColor.NameFormat.HexArgb),
            )  # [2898]
            self.current_pen_color_edit = QColor(edit_pen_color_str)  # [2899]
            if not self.current_pen_color_edit.isValid():
                self.current_pen_color_edit = QColor(Qt.GlobalColor.black)  # [2900]
            self.edit_pen_color_changed.emit(self.current_pen_color_edit)  # [2901]

            board_pen_color_str = self.settings.value(
                "penColorBoard",
                QColor(Qt.GlobalColor.blue).name(QColor.NameFormat.HexArgb),
            )  # [2902]
            self.current_pen_color_board_only = QColor(board_pen_color_str)  # [2903]
            if not self.current_pen_color_board_only.isValid():
                self.current_pen_color_board_only = QColor(
                    Qt.GlobalColor.blue
                )  # [2904]
            self.board_pen_color_changed.emit(
                self.current_pen_color_board_only
            )  # [2905]

            bg_color_str = self.settings.value(
                "backgroundColor",
                QColor(Qt.GlobalColor.white).name(QColor.NameFormat.HexArgb),
            )  # [2906]
            self.board_background_color = QColor(bg_color_str)  # [2907]
            if not self.board_background_color.isValid():
                self.board_background_color = QColor(Qt.GlobalColor.white)  # [2908]
            self.board_background_color_changed.emit(
                self.board_background_color
            )  # [2909]

            defaults = self.board_default_text_properties  # [2910]
            self.settings.beginGroup("textDefaults")  # [2911]
            defaults["font"] = self.settings.value("font", defaults["font"])  # [2912]
            defaults["size"] = self.settings.value(
                "size", defaults["size"], type=int
            )  # [2913]
            defaults["bold"] = self.settings.value(
                "bold", defaults["bold"], type=bool
            )  # [2914]
            defaults["italic"] = self.settings.value(
                "italic", defaults["italic"], type=bool
            )  # [2915]
            defaults["underline"] = self.settings.value(
                "underline", defaults["underline"], type=bool
            )  # [2916]
            defaults["strikeout"] = self.settings.value(
                "strikeout", defaults["strikeout"], type=bool
            )  # [2917]
            defaults["color"] = self.settings.value(
                "color", defaults["color"]
            )  # [2918]
            bg_color_setting = self.settings.value("backgroundColor")  # [2919]
            defaults["background_color"] = (
                bg_color_setting if bg_color_setting is not None else None
            )  # [2920]
            defaults["alignment"] = self.settings.value(
                "alignment", defaults["alignment"]
            )  # [2921]
            defaults["curve_angle"] = int(
                self.settings.value("curve_angle", defaults.get("curve_angle", 0))
            )  # [2922]
            self.settings.endGroup()  # [2923]
            self.board_default_text_properties = defaults  # [2924]

            self.settings.endGroup()  # [2925]
        except Exception as e:  # [2926]
            print(f"Error loading BOARD settings: {e}")  # [2927]
            self.current_pen_color_edit = QColor(Qt.GlobalColor.black)  # [2928]
            self.current_pen_color_board_only = QColor(Qt.GlobalColor.blue)  # [2929]
            self.board_background_color = QColor(Qt.GlobalColor.white)  # [2930]
            self.edit_pen_color_changed.emit(self.current_pen_color_edit)  # [2931]
            self.board_pen_color_changed.emit(
                self.current_pen_color_board_only
            )  # [2932]
            self.board_background_color_changed.emit(
                self.board_background_color
            )  # [2933]
            self.board_default_text_properties = {  # [2934]
                "text": "",
                "font": "Arial",
                "size": 14,
                "bold": False,
                "italic": False,  # [2935]
                "underline": False,
                "strikeout": False,
                "color": "#000000",  # [2936]
                "background_color": None,
                "alignment": "left",
                "curve_angle": 0,  # [2937]
            }  # [2938]

    def save_mpoint_label_style(self):  # [2939]
        """Saves the MPoint label text style."""  # [2940]
        if hasattr(self, "mpoint_label_text_properties") and self.settings:  # [2941]
            style_to_save = {
                k: v
                for k, v in self.mpoint_label_text_properties.items()
                if k != "text"
            }  # [2942]
            self.settings.setValue(
                "controlPanel/mpointLabelStyle", style_to_save
            )  # [2943]

    def load_mpoint_label_style(self):  # [2944]
        """Loads the MPoint label text style."""  # [2945]
        if hasattr(self, "mpoint_label_text_properties") and self.settings:  # [2946]
            default_label_style = {  # [2947]
                "font": "Arial",
                "size": 10,
                "bold": False,
                "italic": False,  # [2948]
                "underline": False,
                "strikeout": False,
                "color": "#000000",  # [2949]
                "background_color": None,
                "alignment": "center",
                "curve_angle": 0,  # [2950]
            }  # [2951]
            saved_style = self.settings.value(
                "controlPanel/mpointLabelStyle", default_label_style
            )  # [2952]
            if isinstance(saved_style, dict):  # [2953]
                final_style = default_label_style.copy()  # [2954]
                saved_style_filtered = {
                    k: v for k, v in saved_style.items() if k != "text"
                }  # [2955]
                final_style.update(saved_style_filtered)  # [2956]
                self.mpoint_label_text_properties = final_style  # [2957]
            else:  # [2958]
                self.mpoint_label_text_properties = default_label_style  # [2959]
                print(
                    "Warning: Invalid saved MPoint label style, using defaults."
                )  # [2960]

    def save_dimension_text_defaults(self):  # [2961]
        """Saves the dimension text default properties."""  # [2962]
        if (
            hasattr(self, "dimension_default_text_properties") and self.settings
        ):  # [2963]
            style_to_save = {
                k: v
                for k, v in self.dimension_default_text_properties.items()
                if k != "text"
            }  # [2964]
            self.settings.setValue(
                "overlay/dimensionTextDefaults", style_to_save
            )  # [2965]

    def load_dimension_text_defaults(self):  # [2966]
        """Loads the dimension text default properties."""  # [2967]
        if (
            hasattr(self, "dimension_default_text_properties") and self.settings
        ):  # [2968]
            default_style = {  # [2969]
                "font": "Arial",
                "size": 10,
                "bold": False,
                "italic": False,  # [2970]
                "underline": False,
                "strikeout": False,
                "color": "#000000",  # [2971]
                "background_color": None,
                "alignment": "center",
                "curve_angle": 0,  # [2972]
                "dimension_suffix": "",  # [2973]
            }  # [2974]
            saved_style = self.settings.value(
                "overlay/dimensionTextDefaults", default_style
            )  # [2975]
            if isinstance(saved_style, dict):  # [2976]
                final_style = default_style.copy()  # [2977]
                saved_style_filtered = {
                    k: v for k, v in saved_style.items() if k != "text"
                }  # [2978]
                final_style.update(saved_style_filtered)  # [2979]
                self.dimension_default_text_properties = final_style  # [2980]
            else:  # [2981]
                self.dimension_default_text_properties = default_style  # [2982]
                print(
                    "Warning: Invalid saved dimension text defaults, using defaults."
                )  # [2983]

    def load_dimension_preview_line_color(self):  # [2984]
        """Loads the saved dimension preview line color."""  # [2985]
        default_color_from_pen = QColor(self.current_pen_color)  # [2986]
        default_color_from_pen.setAlpha(100)  # [2987]
        default_color_str = default_color_from_pen.name(
            QColor.NameFormat.HexArgb
        )  # [2988]

        color_str = self.settings.value(
            "overlay/dimensionPreviewLineColor", default_color_str
        )  # [2989]
        loaded_color = QColor(color_str)  # [2990]
        self.dimension_preview_color_explicitly_set = self.settings.value(
            "overlay/dimensionPreviewColorExplicitlySet", False, type=bool
        )  # [2991]

        if loaded_color.isValid():  # [2992]
            self.dimension_preview_line_color = loaded_color  # [2993]
            if not self.dimension_preview_color_explicitly_set:  # [2994]
                if (
                    self.dimension_preview_line_color != default_color_from_pen
                ):  # [2995]
                    self.dimension_preview_color_explicitly_set = True  # [2996]
        else:  # [2997]
            self.dimension_preview_line_color = QColor(0, 255, 255, 100)  # [2998]
            self.dimension_preview_color_explicitly_set = False  # [2999]
            print(
                "Warning: Invalid saved dimension preview line color, using default cyan."
            )  # [3000]
        self.dimension_preview_color_changed.emit(
            self.dimension_preview_line_color
        )  # [3001]

    def save_dimension_preview_line_color(self):  # [3002]
        """Saves the current dimension preview line color and explicit set flag."""  # [3003]
        if hasattr(self, "dimension_preview_line_color") and self.settings:  # [3004]
            self.settings.setValue(
                "overlay/dimensionPreviewLineColor",
                self.dimension_preview_line_color.name(QColor.NameFormat.HexArgb),
            )  # [3005]
            self.settings.setValue(
                "overlay/dimensionPreviewColorExplicitlySet",
                self.dimension_preview_color_explicitly_set,
            )  # [3006]

    @Slot(QColor)  # [3007]
    def set_dimension_preview_line_color(
        self, color, from_pen_color_change=False
    ):  # [3008]
        """Sets the dimension preview line color and emits a signal."""  # [3009]
        if isinstance(color, QColor) and color.isValid():  # [3010]
            if self.dimension_preview_line_color != color or (
                not from_pen_color_change
                and not self.dimension_preview_color_explicitly_set
            ):  # [3011]
                self.dimension_preview_line_color = color  # [3012]
                if not from_pen_color_change:  # [3013]
                    self.dimension_preview_color_explicitly_set = True  # [3014]
                self.dimension_preview_color_changed.emit(
                    self.dimension_preview_line_color
                )  # [3015]
                if (
                    self.drawing_mode
                    and self.current_tool == "dimension"
                    and len(self.dimension_points) > 0
                ):  # [3016]
                    self.update()  # [3017]
        else:  # [3018]
            print(
                f"Warning: Invalid color received for dimension preview line: {color}"
            )  # [3019]

    def save_angle_tool_settings(self):  # [3020]
        if self.settings:  # [3021]
            self.settings.beginGroup("angleTool")  # [3022]
            self.settings.setValue(
                "lineColor",
                self.current_angle_tool_line_color.name(QColor.NameFormat.HexArgb),
            )  # [3023]
            self.settings.setValue(
                "textSize", self.current_angle_tool_text_size
            )  # [3024]
            self.settings.setValue(
                "showInner", self.current_angle_tool_show_inner
            )  # [3025]
            self.settings.setValue(
                "showOuter", self.current_angle_tool_show_outer
            )  # [3026]
            self.settings.endGroup()  # [3027]

    def load_angle_tool_settings(self):  # [3028]
        if self.settings:  # [3029]
            self.settings.beginGroup("angleTool")  # [3030]
            default_color = QColor(255, 165, 0)  # [3031]
            line_color_str = self.settings.value(
                "lineColor", default_color.name(QColor.NameFormat.HexArgb)
            )  # [3032]
            loaded_color = QColor(line_color_str)  # [3033]
            self.current_angle_tool_line_color = (
                loaded_color if loaded_color.isValid() else default_color
            )  # [3034]

            self.current_angle_tool_text_size = self.settings.value(
                "textSize", 10, type=int
            )  # [3035]
            self.current_angle_tool_show_inner = self.settings.value(
                "showInner", True, type=bool
            )  # [3036]
            self.current_angle_tool_show_outer = self.settings.value(
                "showOuter", False, type=bool
            )  # [3037]
            self.settings.endGroup()  # [3038]
            self.angle_tool_config_changed.emit(
                {  # [3039]
                    "color": self.current_angle_tool_line_color,  # [3040]
                    "textSize": self.current_angle_tool_text_size,  # [3041]
                    "showInner": self.current_angle_tool_show_inner,  # [3042]
                    "showOuter": self.current_angle_tool_show_outer,  # [3043]
                }
            )  # [3044]

    @Slot(dict)  # [3045]
    def update_angle_tool_settings(self, settings):  # [3046]
        """Updates Angle tool settings from the control panel."""  # [3047]
        if "color" in settings:
            self.current_angle_tool_line_color = settings["color"]  # [3048]
        if "textSize" in settings:
            self.current_angle_tool_text_size = settings["textSize"]  # [3049]
        if "showInner" in settings:
            self.current_angle_tool_show_inner = settings["showInner"]  # [3050]
        if "showOuter" in settings:
            self.current_angle_tool_show_outer = settings["showOuter"]  # [3051]
        self.save_angle_tool_settings()  # [3052]
        if self.current_tool == "angle_marker":  # [3053]
            self.update()  # [3054]

    def save_hatch_fill_settings(self):  # [3055]
        if self.settings:  # [3056]
            self.settings.beginGroup("hatchFill")  # [3057]
            self.settings.setValue(
                "style", json.dumps(self.current_hatch_style)
            )  # [3058]
            self.settings.setValue(
                "color", self.current_hatch_color.name(QColor.NameFormat.HexArgb)
            )  # [3059]
            self.settings.setValue("thickness", self.current_hatch_thickness)  # [3060]
            self.settings.endGroup()  # [3061]

    def load_hatch_fill_settings(self):  # [3062]
        if self.settings:  # [3063]
            self.settings.beginGroup("hatchFill")  # [3064]
            try:  # [3065]
                style_str = self.settings.value("style", "[]")  # [3066]
                self.current_hatch_style = json.loads(style_str)  # [3067]
                if not isinstance(self.current_hatch_style, list):  # [3068]
                    self.current_hatch_style = []  # [3069]
            except json.JSONDecodeError:  # [3070]
                self.current_hatch_style = []  # [3071]

            default_color = QColor(128, 128, 128)  # [3072]
            color_str = self.settings.value(
                "color", default_color.name(QColor.NameFormat.HexArgb)
            )  # [3073]
            loaded_color = QColor(color_str)  # [3074]
            self.current_hatch_color = (
                loaded_color if loaded_color.isValid() else default_color
            )  # [3075]
            self.current_hatch_thickness = self.settings.value(
                "thickness", 1, type=int
            )  # [3076]
            self.settings.endGroup()  # [3077]
            if self.control_panel:  # [3078]
                self.control_panel.update_hatch_fill_controls()  # [3079]

    def save_division_point_settings(self):  # [3080]
        if self.settings:  # [3081]
            self.settings.beginGroup("divisionPoints")  # [3082]
            self.settings.setValue(
                "color", self.division_point_color.name(QColor.NameFormat.HexArgb)
            )  # [3083]
            self.settings.setValue("size", self.division_point_size)  # [3084]
            self.settings.endGroup()  # [3085]

    def load_division_point_settings(self):  # [3086]
        if self.settings:  # [3087]
            self.settings.beginGroup("divisionPoints")  # [3088]
            default_color = QColor(Qt.GlobalColor.yellow)  # [3089]
            color_str = self.settings.value(
                "color", default_color.name(QColor.NameFormat.HexArgb)
            )  # [3090]
            loaded_color = QColor(color_str)  # [3091]
            self.division_point_color = (
                loaded_color if loaded_color.isValid() else default_color
            )  # [3092]
            self.division_point_size = self.settings.value(
                "size", 5.0, type=float
            )  # [3093]
            self.settings.endGroup()  # [3094]

            self.division_point_color_changed.emit(self.division_point_color)  # [3095]
            self.division_point_size_changed.emit(self.division_point_size)  # [3096]

    def save_snap_settings(self):  # [3097]
        """Saves snapping settings."""  # [3098]
        if self.settings:  # [3099]
            self.settings.beginGroup("snapping")  # [3100]
            self.settings.setValue("mode", self.snap_mode)  # [3101]
            self.settings.setValue("sensitivity", self.snap_sensitivity)  # [3102]
            self.settings.endGroup()  # [3103]
            print(
                f"Saved snap settings: Mode={self.snap_mode}, Sensitivity={self.snap_sensitivity}"
            )  # [3104]

    def load_snap_settings(self):  # [3105]
        """Loads snapping settings."""  # [3106]
        if self.settings:  # [3107]
            self.settings.beginGroup("snapping")  # [3108]
            self.snap_mode = self.settings.value("mode", "none", type=str)  # [3109]
            self.snap_sensitivity = self.settings.value(
                "sensitivity", 5, type=int
            )  # [3110]
            self.settings.endGroup()  # [3111]
            print(
                f"Loaded snap settings: Mode={self.snap_mode}, Sensitivity={self.snap_sensitivity}"
            )  # [3112]
            # Update UI in ControlPanel if it exists # [3113]
            if self.control_panel:  # [3114]
                self.control_panel.update_snap_controls_from_settings()  # [3115]

    @Slot(str)  # [3116]
    def set_snap_mode(self, mode: str):  # [3117]
        """Sets the current snap mode."""  # [3118]
        if mode in ["none", "lines", "grid", "all"]:  # [3119]
            if self.snap_mode != mode:  # [3120]
                self.snap_mode = mode  # [3121]
                print(f"Snap mode set to: {mode}")  # [3122]
                self.snap_mode_changed.emit(mode)  # [3123]
                self.save_snap_settings()  # [3124]
                self.update()  # Potentially refresh if this affects preview # [3125]
        else:  # [3126]
            print(f"Warning: Invalid snap mode '{mode}' requested.")  # [3127]

    @Slot(int)  # [3128]
    def set_snap_sensitivity(self, sensitivity: int):  # [3129]
        """Sets the snap sensitivity."""  # [3130]
        sensitivity = max(1, min(100, sensitivity))  # [3131]
        if self.snap_sensitivity != sensitivity:  # [3132]
            self.snap_sensitivity = sensitivity  # [3133]
            print(f"Snap sensitivity set to: {sensitivity}px")  # [3134]
            self.snap_sensitivity_changed.emit(sensitivity)  # [3135]
            self.save_snap_settings()  # [3136]

    @Slot()  # [3137]
    def enter_temp_mode(self):  # [3138]
        """Enters TEMP drawing mode."""  # [3139]
        print("Entering TEMP mode")  # [3140]

        if self.board_mode or self.edit_mode:  # [3141]
            if not self.exit_board_mode(ask_save=False, configure=False):  # [3142]
                print(
                    "Cannot enter TEMP mode, failed to exit BOARD/EDIT mode."
                )  # [3143]
                return  # [3144]
        if self.input_mode:  # [3145]
            print(
                f"Cancelling input mode '{self.input_mode}' due to mode change."
            )  # [3146]
            self.input_mode = None  # [3147]
        if self.current_tool == "dimension" and self.dimension_points:  # [3148]
            print("Cancelling dimensioning due to mode change.")  # [3149]
            self.dimension_points.clear()  # [3150]
            self.dimension_preview_shapes.clear()  # [3151]
        if self.current_tool == "angle_marker" and self.angle_points:  # [3152]
            print("Cancelling angle drawing due to mode change.")  # [3153]
            self.angle_points.clear()  # [3154]
        if self.current_tool == "spline" and self.spline_points:  # [3155]
            print("Cancelling spline drawing due to mode change.")  # [3156]
            self.spline_points.clear()  # [3157]

        self.temp_mode = True  # [3158]
        self.board_mode = False  # [3159]
        self.edit_mode = False  # [3160]

        self.show_indicators_in_temp_mode = self.show_tool_text  # [3161]

        self.show_angle_offset = False  # [3162]
        self.angle_offsets.clear()  # [3163]
        self._reset_next_mpoint_label()  # [3164]
        self.active_angle_shape_for_point_drag = None  # [3165]
        self.active_angle_point_handle = None  # [3166]

        if not self.drawing_mode:  # [3167]
            self.set_drawing_mode(True)  # [3168]
        else:  # [3169]
            self._configure_mode()  # [3170]
            self.update()  # [3171]

        self.temp_mode_changed.emit(True)  # [3172]
        self.board_mode_changed.emit(False)  # [3173]
        self.edit_mode_changed.emit(False)  # [3174]

    def exit_temp_mode(self, configure=True):  # [3175]
        """Exits TEMP drawing mode."""  # [3176]
        if not self.temp_mode:
            return True  # [3177]

        print("Exiting TEMP mode")  # [3178]
        self.temp_mode = False  # [3179]

        self.show_angle_offset = False  # [3180]
        self.angle_offsets.clear()  # [3181]
        self._reset_next_mpoint_label()  # [3182]
        self.active_angle_shape_for_point_drag = None  # [3183]
        self.active_angle_point_handle = None  # [3184]

        if self.control_panel:  # [3185]
            self.dim_background = self.control_panel.dim_check.isChecked()  # [3186]
        else:  # [3187]
            self.dim_background = True  # [3188]

        self.temp_mode_changed.emit(False)  # [3189]

        if configure:  # [3190]
            self.set_drawing_mode(False)  # [3191]

        return True  # [3192]

    def _configure_mode(self):  # [3193]
        """Configures window properties based on the active mode."""  # [3194]
        if not self.isVisible() and not self.testAttribute(
            Qt.WidgetAttribute.WA_WState_Created
        ):  # [3195]
            QTimer.singleShot(50, self._configure_mode)  # [3196]
            return  # [3197]

        if _IS_WINDOWS and not self.hwnd:  # [3198]
            self.hwnd = self.winId()  # [3199]

        self.releaseKeyboard()  # [3200]
        self.unsetCursor()  # [3201]

        if self.drawing_mode:  # [3202]
            self.setWindowFlags(
                Qt.WindowType.FramelessWindowHint
                | Qt.WindowType.WindowStaysOnTopHint
                | Qt.WindowType.Tool
            )  # [3203]
            self.setMouseTracking(True)  # [3204]

            is_background_opaque = False  # [3205]
            set_translucent_bg_attr = True  # [3206]

            if self.background_pixmap and not self.background_pixmap.isNull():  # [3207]
                is_background_opaque = True  # [3208]
                set_translucent_bg_attr = self.edit_mode  # [3209]
            elif self.edit_mode:  # [3210]
                is_background_opaque = False
                set_translucent_bg_attr = True  # [3211]
            elif self.board_mode:  # [3212]
                is_background_opaque = (
                    self.board_background_color.alpha() == 255
                )  # [3213]
                set_translucent_bg_attr = not is_background_opaque  # [3214]
            elif self.temp_mode:  # [3215]
                is_background_opaque = False
                set_translucent_bg_attr = True  # [3216]
            else:  # [3217]
                is_background_opaque = self.dim_background  # [3218]
                set_translucent_bg_attr = not is_background_opaque  # [3219]

            self.setAttribute(
                Qt.WidgetAttribute.WA_OpaquePaintEvent, is_background_opaque
            )  # [3220]
            self.setAttribute(
                Qt.WidgetAttribute.WA_TranslucentBackground, set_translucent_bg_attr
            )  # [3221]

            if _IS_WINDOWS and self.hwnd:  # [3222]
                result = SetWindowRgn(self.hwnd, None, True)  # [3223]
                if result == 0:
                    print("SetWindowRgn (NULL) failed!")  # [3224]

            self.raise_()
            self.activateWindow()
            self.setFocus(Qt.FocusReason.ActiveWindowFocusReason)  # [3225]
            self.setWindowFlag(Qt.WindowType.WindowTransparentForInput, False)  # [3226]

        else:  # [3227]
            self.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, False)
            self.setAttribute(
                Qt.WidgetAttribute.WA_TranslucentBackground, True
            )  # [3228]
            self.setWindowFlags(
                Qt.WindowType.FramelessWindowHint
                | Qt.WindowType.WindowStaysOnTopHint
                | Qt.WindowType.Tool
            )  # [3229]
            self.setMouseTracking(False)  # [3230]
            if self.input_mode:  # [3231]
                print(
                    f"Cancelling input mode '{self.input_mode}' due to drawing mode exit."
                )  # [3232]
                self.input_mode = None  # [3233]
            self.setWindowFlag(Qt.WindowType.WindowTransparentForInput, True)  # [3234]

        if not self.isVisible():
            self.show()  # [3235]
        self.update()  # [3236]

        if self.control_panel:  # [3237]
            self.control_panel.update_draw_color_preview_button(
                self.current_pen_color
            )  # [3238]
            self.control_panel.update_edit_pen_color_preview_button(
                self.current_pen_color_edit
            )  # [3239]
            self.control_panel.update_board_pen_color_preview_button(
                self.current_pen_color_board_only
            )  # [3240]
            self.control_panel.update_board_bg_color_preview_button(
                self.board_background_color
            )  # [3241]
            self.control_panel.update_temp_color_preview_button(
                self.current_pen_color_temp
            )  # [3242]
            self.control_panel.update_dimension_preview_color_button_style(
                self.dimension_preview_line_color
            )  # [3243]
            self.control_panel.update_angle_tool_color_button_style(
                self.current_angle_tool_line_color
            )  # [3244]
            self.control_panel.update_hatch_fill_color_button_style(
                self.current_hatch_color
            )  # [3245]
            self.control_panel.update_division_point_color_button_style(
                self.division_point_color
            )  # [3246]

            self.control_panel.update_draw_mode_button_visuals()  # [3247]
            self.control_panel.update_edit_mode_button_visuals()  # [3248]
            self.control_panel.update_board_mode_button_visuals()  # [3249]
            self.control_panel.update_temp_mode_button_visuals()  # [3250]
            self.control_panel.update_hide_button_visuals(self.shapes_visible)  # [3251]
            self.control_panel.update_center_button_visuals(
                self.show_center_point
            )  # [3252]
            self.control_panel.update_divide_controls_visuals(
                self.divide_enabled, self.number_of_divisions
            )  # [3253]
            self.control_panel.update_snap_controls_from_settings()  # [3254]

    def get_handle_at(self, point):  # [3255]
        """Finds which resize handle (if any) is at the given point."""  # [3256]
        for shape in reversed(self.selected_shapes):  # [3257]
            if (
                not shape
                or not shape.geometry
                or shape.is_mpoint_marker
                or (
                    shape.is_label
                    and not (
                        shape.type == "text"
                        and shape.text_properties
                        and shape.text_properties.get("is_angle_display", False)
                        == False
                    )
                )
                or (shape.is_dimension_part and shape.dimension_type == "text")
            ):  # [3258]
                continue  # [3259]

            geo = shape.geometry  # [3260]
            handle_size_f = float(self.handle_size)  # [3261]
            check_radius_sq = (handle_size_f * 0.75) ** 2  # [3262]

            transform = QTransform()  # [3263]
            center = QPointF()  # [3264]

            if shape.type == "arc":  # [3265]
                center = self._get_arc_visual_center(shape)  # [3266]
            elif (
                shape.type in ["line", "arrow", "angle_marker"]
                and isinstance(geo, list)
                and len(geo) > 0
                and isinstance(geo[0], QPointF)
            ):  # [3267]
                center = geo[0]  # [3268]
                if shape.type == "angle_marker" and len(geo) == 3:  # [3269]
                    center = geo[1]  # [3270]
            elif isinstance(geo, QRectF) and geo.isValid():
                center = geo.center()  # [3271]
            elif isinstance(geo, QPointF):
                center = geo  # [3272]
            elif isinstance(geo, list):  # [3273]
                valid_points = [p for p in geo if isinstance(p, QPointF)]  # [3274]
                if valid_points:
                    center = QPointF(
                        sum(p.x() for p in valid_points) / len(valid_points),
                        sum(p.y() for p in valid_points) / len(valid_points),
                    )  # [3275]

            if shape.rotation != 0 and not center.isNull():  # [3276]
                transform.translate(center.x(), center.y())  # [3277]
                transform.rotate(shape.rotation)  # [3278]
                transform.translate(-center.x(), -center.y())  # [3279]

            if shape.is_mpoint_marker or shape.is_label:  # [3280]
                return  # [3281]

            if isinstance(geo, QRectF) and geo.isValid():  # [3282]
                if shape.type == "arc":  # [3283]
                    rect = geo  # [3284]
                    center_unrot = (
                        self._get_arc_visual_center(shape)
                        if hasattr(self, "_get_arc_visual_center")
                        else rect.center()
                    )  # [3285]
                    rx = rect.width() / 2.0
                    ry = rect.height() / 2.0  # [3286]
                    start_rad = math.radians(shape.startAngle)
                    end_rad = math.radians(shape.startAngle + shape.spanAngle)
                    mid_rad = math.radians(
                        shape.startAngle + shape.spanAngle / 2.0
                    )  # [3287]

                    geom_center_unrot = rect.center()  # [3288]
                    start_pt = geom_center_unrot + QPointF(
                        rx * math.cos(start_rad), -ry * math.sin(start_rad)
                    )  # [3289]
                    end_pt = geom_center_unrot + QPointF(
                        rx * math.cos(end_rad), -ry * math.sin(end_rad)
                    )  # [3290]
                    mid_pt = geom_center_unrot + QPointF(
                        rx * math.cos(mid_rad), -ry * math.sin(mid_rad)
                    )  # [3291]

                    rotated_start = transform.map(start_pt)
                    rotated_end = transform.map(end_pt)
                    rotated_mid = transform.map(mid_pt)  # [3292]
                    handle_points = {
                        "arc_start": rotated_start,
                        "arc_end": rotated_end,
                        "arc_mid": rotated_mid,
                    }  # [3293]
                    for name, pos_handle in handle_points.items():  # [3294]
                        delta = pos_handle - point  # [3295]
                        if (
                            QPointF.dotProduct(delta, delta) <= check_radius_sq
                        ):  # [3296]
                            return (shape, name)  # [3297]
                else:  # [3298]
                    corners = [
                        geo.topLeft(),
                        geo.topRight(),
                        geo.bottomRight(),
                        geo.bottomLeft(),
                    ]  # [3299]
                    rotated_corners = [transform.map(p) for p in corners]  # [3300]
                    handle_names = [
                        "top_left",
                        "top_right",
                        "bottom_right",
                        "bottom_left",
                    ]  # [3301]
                    for name, pos_handle in zip(
                        handle_names, rotated_corners
                    ):  # [3302]
                        delta = pos_handle - point  # [3303]
                        if (
                            QPointF.dotProduct(delta, delta) <= check_radius_sq
                        ):  # [3304]
                            return (shape, name)  # [3305]
            elif isinstance(geo, list):  # [3306]
                valid_points = [p for p in geo if isinstance(p, QPointF)]  # [3307]
                if valid_points:  # [3308]
                    rotated_vertices = [
                        transform.map(p) for p in valid_points
                    ]  # [3309]
                    if (
                        shape.type == "angle_marker" and len(rotated_vertices) == 3
                    ):  # [3310]
                        handle_names = ["vertex_A", "vertex_O", "vertex_B"]  # [3311]
                        for name, pos_handle in zip(
                            handle_names, rotated_vertices
                        ):  # [3312]
                            delta = pos_handle - point  # [3313]
                            if (
                                QPointF.dotProduct(delta, delta) <= check_radius_sq
                            ):  # [3314]
                                return (shape, name)  # [3315]
                    elif shape.type == "spline":  # [3316]
                        for i, pos_handle in enumerate(rotated_vertices):  # [3317]
                            handle_name = f"vertex_{i}"  # [3318]
                            delta = pos_handle - point  # [3319]
                            if (
                                QPointF.dotProduct(delta, delta) <= check_radius_sq
                            ):  # [3320]
                                return (shape, handle_name)  # [3321]
                    else:  # [3322]
                        for i, pos_handle in enumerate(rotated_vertices):  # [3323]
                            handle_name = f"vertex_{i}"  # [3324]
                            delta = pos_handle - point  # [3325]
                            if (
                                QPointF.dotProduct(delta, delta) <= check_radius_sq
                            ):  # [3326]
                                return (shape, handle_name)  # [3327]
        return None  # [3328]

    def save_state(
        self,
        action_type,
        shapes_involved=None,
        previous_geometries=None,
        indices=None,
        all_shapes_before=None,
        selected_shapes_before=None,
        selected_shapes_after=None,
    ):  # [3329]
        """Saves the current state for undo functionality."""  # [3330]
        all_shapes_before_copy = (
            deepcopy(self.shapes)
            if all_shapes_before is None
            else deepcopy(all_shapes_before)
        )  # [3331]
        selected_shapes_before_copy = (
            deepcopy(self.selected_shapes)
            if selected_shapes_before is None
            else deepcopy(selected_shapes_before)
        )  # [3332]

        state = {  # [3333]
            "action": action_type,  # [3334]
            "all_shapes_before": all_shapes_before_copy,  # [3335]
            "selected_shapes_before": selected_shapes_before_copy,  # [3336]
            "action_data": {},  # [3337]
        }  # [3338]

        if action_type in [
            "move",
            "resize",
            "rotate",
            "scale",
            "change_color",
            "change_alpha",
            "toggle_fill",
            "change_line_style",
            "change_line_thickness",
            "edit_text",
            "toggle_hatch_fill",
            "change_line_point_arrow_style",
            "group_shapes",
            "ungroup_shapes",
        ]:  # [3339]
            state["action_data"]["indices"] = (
                deepcopy(indices) if indices is not None else []
            )  # [3340]
            state["action_data"]["previous_properties"] = (
                deepcopy(previous_geometries) if previous_geometries is not None else {}
            )  # [3341]
            if action_type == "group_shapes":  # [3342]
                if shapes_involved and shapes_involved[0].group_id:  # [3343]
                    state["action_data"]["new_group_id"] = shapes_involved[
                        0
                    ].group_id  # [3344]
            elif action_type == "ungroup_shapes":  # [3345]
                pass  # [3346]

        elif action_type == "paste":  # [3347]
            state["action_data"]["paste_count"] = (
                previous_geometries if isinstance(previous_geometries, int) else 0
            )  # [3348]
        elif action_type == "load_join":  # [3349]
            state["action_data"]["load_join_count"] = (
                previous_geometries if isinstance(previous_geometries, int) else 0
            )  # [3350]
        elif action_type in [
            "draw",
            "draw_group",
            "draw_dimension",
            "draw_angle_marker",
            "draw_spline",
        ]:  # [3351]
            state["action_data"]["added_indices"] = (
                indices if indices is not None else []
            )  # [3352]
        elif action_type in ["delete", "delete_selected", "delete_group"]:  # [3353]
            state["action_data"]["deleted_shapes"] = (
                deepcopy(shapes_involved) if shapes_involved else []
            )  # [3354]
            state["action_data"]["original_indices"] = (
                deepcopy(indices) if indices is not None else []
            )  # [3355]
        elif action_type == "send_to_back":  # [3356]
            pass  # [3357]
        elif action_type == "toggle_visibility":  # [3358]
            state["action_data"]["visibility_target"] = previous_geometries  # [3359]
        elif action_type == "change_board_bg":  # [3360]
            state["action_data"]["board_bg_before"] = (
                previous_geometries.get("board_bg") if previous_geometries else None
            )  # [3361]
        elif action_type == "change_board_pen":  # [3362]
            state["action_data"]["board_pen_before"] = (
                previous_geometries.get("board_pen") if previous_geometries else None
            )  # [3363]
        elif action_type == "change_edit_pen":  # [3364]
            state["action_data"]["edit_pen_before"] = (
                previous_geometries.get("edit_pen") if previous_geometries else None
            )  # [3365]
        elif action_type == "change_board_text_defaults":  # [3366]
            state["action_data"]["board_text_defaults_before"] = (
                previous_geometries.get("board_text_defaults")
                if previous_geometries
                else None
            )  # [3367]
        elif action_type == "change_dimension_text_defaults":  # [3368]
            state["action_data"]["dimension_text_defaults_before"] = (
                previous_geometries.get("dimension_text_defaults")
                if previous_geometries
                else None
            )  # [3369]
        elif action_type == "change_angle_tool_config":  # [3370]
            state["action_data"]["angle_tool_config_before"] = (
                previous_geometries.get("angle_tool_config")
                if previous_geometries
                else None
            )  # [3371]
        elif action_type == "change_hatch_fill_config":  # [3372]
            state["action_data"]["hatch_fill_config_before"] = (
                previous_geometries.get("hatch_fill_config")
                if previous_geometries
                else None
            )  # [3373]
        elif action_type == "change_division_point_config":  # [3374]
            state["action_data"]["division_point_config_before"] = (
                previous_geometries.get("division_point_config")
                if previous_geometries
                else None
            )  # [3375]
        elif action_type in [
            "select_all",
            "lasso_select",
            "select_single_dim_part",
            "select_angle_point",
            "select_angle_text",
        ]:  # [3376]
            state["action_data"]["selected_shapes_after"] = (
                deepcopy(self.selected_shapes)
                if selected_shapes_after is None
                else deepcopy(selected_shapes_after)
            )  # [3377]
            if action_type == "select_angle_point":  # [3378]
                state["action_data"]["active_angle_point_handle_after"] = (
                    self.active_angle_point_handle
                )  # [3379]
                state["action_data"]["active_angle_shape_after"] = (
                    self.active_angle_shape_for_point_drag
                )  # [3380]
        elif action_type == "clear_scene":  # [3381]
            bg_pixmap_data = previous_geometries.get(
                "background_pixmap_before"
            )  # [3382]
            state["action_data"]["background_pixmap_before"] = (
                QPixmap(bg_pixmap_data)
                if bg_pixmap_data and not bg_pixmap_data.isNull()
                else None
            )  # [3383]
            state["action_data"]["shapes_before_clear"] = previous_geometries.get(
                "shapes_before_clear", []
            )  # [3384]

        try:  # [3385]
            self.undo_stack.append(state)  # [3386]
            self.redo_stack.clear()  # [3387]
            MAX_UNDO = 100  # [3388]
            if len(self.undo_stack) > MAX_UNDO:  # [3389]
                self.undo_stack.pop(0)  # [3390]
        except Exception as e:  # [3391]
            print(f"Error saving undo state for action '{action_type}': {e}")  # [3392]
            traceback.print_exc()  # [3393]

    def undo(self):  # [3394]
        """Undoes the last action."""  # [3395]
        if not self.undo_stack:  # [3396]
            print("Undo stack is empty")  # [3397]
            return  # [3398]

        state_to_undo = self.undo_stack.pop()  # [3399]
        action = state_to_undo["action"]  # [3400]
        print(f"Undoing action: {action}")  # [3401]

        try:  # [3402]
            current_shapes_for_redo = deepcopy(self.shapes)  # [3403]
            current_selection_for_redo = deepcopy(self.selected_shapes)  # [3404]
            current_board_bg = deepcopy(self.board_background_color)  # [3405]
            current_board_pen = deepcopy(self.current_pen_color_board_only)  # [3406]
            current_edit_pen = deepcopy(self.current_pen_color_edit)  # [3407]
            current_board_defaults = deepcopy(
                self.board_default_text_properties
            )  # [3408]
            current_dimension_text_defaults = deepcopy(
                self.dimension_default_text_properties
            )  # [3409]
            current_angle_tool_config_for_redo = {  # [3410]
                "color": deepcopy(self.current_angle_tool_line_color),  # [3411]
                "textSize": self.current_angle_tool_text_size,  # [3412]
                "showInner": self.current_angle_tool_show_inner,  # [3413]
                "showOuter": self.current_angle_tool_show_outer,  # [3414]
            }  # [3415]
            current_hatch_fill_config_for_redo = {  # [3416]
                "style": deepcopy(self.current_hatch_style),  # [3417]
                "color": deepcopy(self.current_hatch_color),  # [3418]
                "thickness": self.current_hatch_thickness,  # [3419]
            }  # [3420]
            current_division_point_config_for_redo = {  # [3421]
                "color": deepcopy(self.division_point_color),  # [3422]
                "size": self.division_point_size,  # [3423]
            }  # [3424]
            current_visibility = (
                self.mpoint_label_visible,
                self.mpoint_marker_visible,
                self.shapes_visible,
            )  # [3425]
            current_background_pixmap_for_redo = (
                QPixmap(self.background_pixmap)
                if self.background_pixmap and not self.background_pixmap.isNull()
                else None
            )  # [3426]
            current_active_angle_point_handle_for_redo = (
                self.active_angle_point_handle
            )  # [3427]
            current_active_angle_shape_for_redo = (
                self.active_angle_shape_for_point_drag
            )  # [3428]
            current_line_point_arrow_style_for_redo = (
                self.current_line_point_arrow_style
            )  # [3429]

            self.shapes = state_to_undo["all_shapes_before"]  # [3430]
            self.selected_shapes = state_to_undo["selected_shapes_before"]  # [3431]

            action_data = state_to_undo.get("action_data", {})  # [3432]
            if (
                action == "change_board_bg" and "board_bg_before" in action_data
            ):  # [3433]
                self.board_background_color = action_data["board_bg_before"]  # [3434]
                self.board_background_color_changed.emit(
                    self.board_background_color
                )  # [3435]
            elif (
                action == "change_board_pen" and "board_pen_before" in action_data
            ):  # [3436]
                self.current_pen_color_board_only = action_data[
                    "board_pen_before"
                ]  # [3437]
                self.board_pen_color_changed.emit(
                    self.current_pen_color_board_only
                )  # [3438]
            elif (
                action == "change_edit_pen" and "edit_pen_before" in action_data
            ):  # [3439]
                self.current_pen_color_edit = action_data["edit_pen_before"]  # [3440]
                self.edit_pen_color_changed.emit(self.current_pen_color_edit)  # [3441]
            elif (
                action == "change_board_text_defaults"
                and "board_text_defaults_before" in action_data
            ):  # [3442]
                self.board_default_text_properties = action_data[
                    "board_text_defaults_before"
                ]  # [3443]
            elif (
                action == "change_dimension_text_defaults"
                and "dimension_text_defaults_before" in action_data
            ):  # [3444]
                self.dimension_default_text_properties = action_data[
                    "dimension_text_defaults_before"
                ]  # [3445]
            elif (
                action == "change_angle_tool_config"
                and "angle_tool_config_before" in action_data
            ):  # [3446]
                config = action_data["angle_tool_config_before"]  # [3447]
                self.current_angle_tool_line_color = config["color"]  # [3448]
                self.current_angle_tool_text_size = config["textSize"]  # [3449]
                self.current_angle_tool_show_inner = config["showInner"]  # [3450]
                self.current_angle_tool_show_outer = config["showOuter"]  # [3451]
                self.angle_tool_config_changed.emit(config)  # [3452]
            elif (
                action == "change_hatch_fill_config"
                and "hatch_fill_config_before" in action_data
            ):  # [3453]
                config = action_data["hatch_fill_config_before"]  # [3454]
                self.current_hatch_style = config["style"]  # [3455]
                self.current_hatch_color = config["color"]  # [3456]
                self.current_hatch_thickness = config["thickness"]  # [3457]
                if self.control_panel:
                    self.control_panel.update_hatch_fill_controls()  # [3458]
            elif (
                action == "change_division_point_config"
                and "division_point_config_before" in action_data
            ):  # [3459]
                config = action_data["division_point_config_before"]  # [3460]
                self.division_point_color = config["color"]  # [3461]
                self.division_point_size = config["size"]  # [3462]
                self.division_point_color_changed.emit(
                    self.division_point_color
                )  # [3463]
                self.division_point_size_changed.emit(
                    self.division_point_size
                )  # [3464]
            elif action == "change_line_point_arrow_style":  # [3465]
                if (
                    "previous_properties" in action_data
                    and not action_data["previous_properties"]
                ):  # [3466]
                    self.current_line_point_arrow_style = None  # [3467]
                self.line_point_arrow_style_changed.emit(
                    self.current_line_point_arrow_style
                )  # [3468]
            elif action == "group_shapes":  # [3469]
                if (
                    "indices" in action_data and "previous_properties" in action_data
                ):  # [3470]
                    for idx, original_group_id in action_data[
                        "previous_properties"
                    ].items():  # [3471]
                        if 0 <= idx < len(self.shapes):  # [3472]
                            self.shapes[idx].group_id = original_group_id  # [3473]
            elif action == "ungroup_shapes":  # [3474]
                if (
                    "indices" in action_data and "previous_properties" in action_data
                ):  # [3475]
                    first_idx = action_data["indices"][0]  # [3476]
                    group_id_to_restore = action_data["previous_properties"].get(
                        first_idx
                    )  # [3477]
                    if group_id_to_restore:  # [3478]
                        for idx in action_data["indices"]:  # [3479]
                            if 0 <= idx < len(self.shapes):  # [3480]
                                self.shapes[
                                    idx
                                ].group_id = group_id_to_restore  # [3481]

            elif action == "toggle_visibility":  # [3482]
                target = action_data.get("visibility_target")  # [3483]
                if target == "labels":  # [3484]
                    self.mpoint_label_visible = not self.mpoint_label_visible  # [3485]
                elif target == "markers":  # [3486]
                    self.mpoint_marker_visible = (
                        not self.mpoint_marker_visible
                    )  # [3487]
                elif target == "all":  # [3488]
                    self.mpoint_label_visible = not self.mpoint_label_visible  # [3489]
                    self.mpoint_marker_visible = (
                        not self.mpoint_marker_visible
                    )  # [3490]
                else:  # [3491]
                    self.shapes_visible = not self.shapes_visible  # [3492]
                    self.shapes_visibility_changed.emit(self.shapes_visible)  # [3493]
            elif action == "clear_scene":  # [3494]
                bg_pixmap_data_undo = action_data.get(
                    "background_pixmap_before"
                )  # [3495]
                self.background_pixmap = (
                    QPixmap(bg_pixmap_data_undo)
                    if bg_pixmap_data_undo and not bg_pixmap_data_undo.isNull()
                    else None
                )  # [3496]
                if "shapes_before_clear" in action_data:  # [3497]
                    self.shapes = action_data["shapes_before_clear"]  # [3498]
            elif action == "select_angle_point":  # [3499]
                self.active_angle_point_handle = action_data.get(
                    "active_angle_point_handle_before", None
                )  # [3500]
                self.active_angle_shape_for_point_drag = action_data.get(
                    "active_angle_shape_before", None
                )  # [3501]

            redo_state = {  # [3502]
                "action": action,  # [3503]
                "shapes_to_restore": current_shapes_for_redo,  # [3504]
                "selection_to_restore": current_selection_for_redo,  # [3505]
                "action_data": deepcopy(action_data),  # [3506]
                "board_bg_to_restore": current_board_bg,  # [3507]
                "board_pen_to_restore": current_board_pen,  # [3508]
                "edit_pen_to_restore": current_edit_pen,  # [3509]
                "board_defaults_to_restore": current_board_defaults,  # [3510]
                "dimension_text_defaults_to_restore": current_dimension_text_defaults,  # [3511]
                "angle_tool_config_to_restore": current_angle_tool_config_for_redo,  # [3512]
                "hatch_fill_config_to_restore": current_hatch_fill_config_for_redo,  # [3513]
                "division_point_config_to_restore": current_division_point_config_for_redo,  # [3514]
                "visibility_to_restore": current_visibility,  # [3515]
                "background_pixmap_to_restore": current_background_pixmap_for_redo,  # [3516]
                "active_angle_point_handle_to_restore": current_active_angle_point_handle_for_redo,  # [3517]
                "active_angle_shape_to_restore": current_active_angle_shape_for_redo,  # [3518]
                "line_point_arrow_style_to_restore": current_line_point_arrow_style_for_redo,  # [3519]
            }  # [3520]
            self.redo_stack.append(redo_state)  # [3521]

            self.current_drawing_shape = None  # [3522]
            self.resizing = False  # [3523]
            self.dragging = False  # [3524]
            self.drag_start_pos = None  # [3525]
            self.drag_start_geometries = {}  # [3526]
            self.polygon_points = []  # [3527]
            self.angle_points = []  # [3528]
            self.brush_points = []  # [3529]
            self.spline_points = []  # [3530]
            self.is_lasso_selecting = False  # [3531]
            self.dimension_points.clear()  # [3532]
            self.dimension_preview_shapes.clear()  # [3533]
            self.input_mode = None  # [3534]
            if action not in ["select_angle_point", "select_angle_text"]:  # [3535]
                self.active_angle_point_handle = None  # [3536]
                self.active_angle_shape_for_point_drag = None  # [3537]

            if self.show_angle_offset:  # [3538]
                self.recalculate_and_update_angle_offsets()  # [3539]
            else:  # [3540]
                self.update()  # [3541]

            self._configure_mode()  # [3542]

            print(f"Undo successful. Redo stack size: {len(self.redo_stack)}")  # [3543]

        except Exception as e:  # [3544]
            print(f"Error during undo operation for action '{action}': {e}")  # [3545]
            traceback.print_exc()  # [3546]

    def redo(self):  # [3547]
        """Redoes the last undone action."""  # [3548]
        if not self.redo_stack:  # [3549]
            print("Redo stack is empty")  # [3550]
            return  # [3551]

        state_to_redo = self.redo_stack.pop()  # [3552]
        action = state_to_redo["action"]  # [3553]
        print(f"Redoing action: {action}")  # [3554]

        try:  # [3555]
            shapes_for_undo_stack = deepcopy(self.shapes)  # [3556]
            selection_for_undo_stack = deepcopy(self.selected_shapes)  # [3557]
            board_bg_for_undo_stack = deepcopy(self.board_background_color)  # [3558]
            board_pen_for_undo_stack = deepcopy(
                self.current_pen_color_board_only
            )  # [3559]
            edit_pen_for_undo_stack = deepcopy(self.current_pen_color_edit)  # [3560]
            board_defaults_for_undo_stack = deepcopy(
                self.board_default_text_properties
            )  # [3561]
            dimension_text_defaults_for_undo_stack = deepcopy(
                self.dimension_default_text_properties
            )  # [3562]
            angle_tool_config_for_undo_stack = {  # [3563]
                "color": deepcopy(self.current_angle_tool_line_color),  # [3564]
                "textSize": self.current_angle_tool_text_size,  # [3565]
                "showInner": self.current_angle_tool_show_inner,  # [3566]
                "showOuter": self.current_angle_tool_show_outer,  # [3567]
            }  # [3568]
            hatch_fill_config_for_undo_stack = {  # [3569]
                "style": deepcopy(self.current_hatch_style),  # [3570]
                "color": deepcopy(self.current_hatch_color),  # [3571]
                "thickness": self.current_hatch_thickness,  # [3572]
            }  # [3573]
            division_point_config_for_undo_stack = {  # [3574]
                "color": deepcopy(self.division_point_color),  # [3575]
                "size": self.division_point_size,  # [3576]
            }  # [3577]
            visibility_for_undo_stack = (
                self.mpoint_label_visible,
                self.mpoint_marker_visible,
                self.shapes_visible,
            )  # [3578]
            background_pixmap_for_undo_stack = (
                QPixmap(self.background_pixmap)
                if self.background_pixmap and not self.background_pixmap.isNull()
                else None
            )  # [3579]
            active_angle_point_handle_for_undo = (
                self.active_angle_point_handle
            )  # [3580]
            active_angle_shape_for_undo = (
                self.active_angle_shape_for_point_drag
            )  # [3581]
            line_point_arrow_style_for_undo = (
                self.current_line_point_arrow_style
            )  # [3582]

            self.shapes = state_to_redo["shapes_to_restore"]  # [3583]
            self.selected_shapes = state_to_redo["selection_to_restore"]  # [3584]

            if "board_bg_to_restore" in state_to_redo:  # [3585]
                self.board_background_color = state_to_redo[
                    "board_bg_to_restore"
                ]  # [3586]
                self.board_background_color_changed.emit(
                    self.board_background_color
                )  # [3587]
            if "board_pen_to_restore" in state_to_redo:  # [3588]
                self.current_pen_color_board_only = state_to_redo[
                    "board_pen_to_restore"
                ]  # [3589]
                self.board_pen_color_changed.emit(
                    self.current_pen_color_board_only
                )  # [3590]
            if "edit_pen_to_restore" in state_to_redo:  # [3591]
                self.current_pen_color_edit = state_to_redo[
                    "edit_pen_to_restore"
                ]  # [3592]
                self.edit_pen_color_changed.emit(self.current_pen_color_edit)  # [3593]
            if "board_defaults_to_restore" in state_to_redo:  # [3594]
                self.board_default_text_properties = state_to_redo[
                    "board_defaults_to_restore"
                ]  # [3595]
            if "dimension_text_defaults_to_restore" in state_to_redo:  # [3596]
                self.dimension_default_text_properties = state_to_redo[
                    "dimension_text_defaults_to_restore"
                ]  # [3597]
            if "angle_tool_config_to_restore" in state_to_redo:  # [3598]
                config = state_to_redo["angle_tool_config_to_restore"]  # [3599]
                self.current_angle_tool_line_color = config["color"]  # [3600]
                self.current_angle_tool_text_size = config["textSize"]  # [3601]
                self.current_angle_tool_show_inner = config["showInner"]  # [3602]
                self.current_angle_tool_show_outer = config["showOuter"]  # [3603]
                self.angle_tool_config_changed.emit(config)  # [3604]
            if "hatch_fill_config_to_restore" in state_to_redo:  # [3605]
                config = state_to_redo["hatch_fill_config_to_restore"]  # [3606]
                self.current_hatch_style = config["style"]  # [3607]
                self.current_hatch_color = config["color"]  # [3608]
                self.current_hatch_thickness = config["thickness"]  # [3609]
                if self.control_panel:
                    self.control_panel.update_hatch_fill_controls()  # [3610]
            if "division_point_config_to_restore" in state_to_redo:  # [3611]
                config = state_to_redo["division_point_config_to_restore"]  # [3612]
                self.division_point_color = config["color"]  # [3613]
                self.division_point_size = config["size"]  # [3614]
                self.division_point_color_changed.emit(
                    self.division_point_color
                )  # [3615]
                self.division_point_size_changed.emit(
                    self.division_point_size
                )  # [3616]
            if "line_point_arrow_style_to_restore" in state_to_redo:  # [3617]
                self.current_line_point_arrow_style = state_to_redo[
                    "line_point_arrow_style_to_restore"
                ]  # [3618]
                self.line_point_arrow_style_changed.emit(
                    self.current_line_point_arrow_style
                )  # [3619]
            elif action == "group_shapes":  # [3620]
                if (
                    "action_data" in state_to_redo
                    and "new_group_id" in state_to_redo["action_data"]
                    and "indices" in state_to_redo["action_data"]
                ):  # [3621]
                    new_group_id = state_to_redo["action_data"][
                        "new_group_id"
                    ]  # [3622]
                    for idx in state_to_redo["action_data"]["indices"]:  # [3623]
                        if 0 <= idx < len(self.shapes):  # [3624]
                            self.shapes[idx].group_id = new_group_id  # [3625]
            elif action == "ungroup_shapes":  # [3626]
                if (
                    "action_data" in state_to_redo
                    and "indices" in state_to_redo["action_data"]
                ):  # [3627]
                    for idx in state_to_redo["action_data"]["indices"]:  # [3628]
                        if 0 <= idx < len(self.shapes):  # [3629]
                            self.shapes[idx].group_id = None  # [3630]

            if "visibility_to_restore" in state_to_redo:  # [3631]
                vis_data = state_to_redo["visibility_to_restore"]  # [3632]
                self.mpoint_label_visible = vis_data[0]  # [3633]
                self.mpoint_marker_visible = vis_data[1]  # [3634]
                self.shapes_visible = vis_data[2]  # [3635]
                self.shapes_visibility_changed.emit(self.shapes_visible)  # [3636]
            if "background_pixmap_to_restore" in state_to_redo:  # [3637]
                bg_pixmap_data_redo = state_to_redo.get(
                    "background_pixmap_to_restore"
                )  # [3638]
                self.background_pixmap = (
                    QPixmap(bg_pixmap_data_redo)
                    if bg_pixmap_data_redo and not bg_pixmap_data_redo.isNull()
                    else None
                )  # [3639]
            if "active_angle_point_handle_to_restore" in state_to_redo:  # [3640]
                self.active_angle_point_handle = state_to_redo[
                    "active_angle_point_handle_to_restore"
                ]  # [3641]
                self.active_angle_shape_for_point_drag = state_to_redo[
                    "active_angle_shape_to_restore"
                ]  # [3642]

            undo_entry = {  # [3643]
                "action": action,  # [3644]
                "all_shapes_before": shapes_for_undo_stack,  # [3645]
                "selected_shapes_before": selection_for_undo_stack,  # [3646]
                "action_data": deepcopy(state_to_redo.get("action_data", {})),  # [3647]
            }  # [3648]
            if action == "change_board_bg":  # [3649]
                undo_entry["action_data"]["board_bg_before"] = (
                    board_bg_for_undo_stack  # [3650]
                )
            elif action == "change_board_pen":  # [3651]
                undo_entry["action_data"]["board_pen_before"] = (
                    board_pen_for_undo_stack  # [3652]
                )
            elif action == "change_edit_pen":  # [3653]
                undo_entry["action_data"]["edit_pen_before"] = (
                    edit_pen_for_undo_stack  # [3654]
                )
            elif action == "change_board_text_defaults":  # [3655]
                undo_entry["action_data"]["board_text_defaults_before"] = (
                    board_defaults_for_undo_stack  # [3656]
                )
            elif action == "change_dimension_text_defaults":  # [3657]
                undo_entry["action_data"]["dimension_text_defaults_before"] = (
                    dimension_text_defaults_for_undo_stack  # [3658]
                )
            elif action == "change_angle_tool_config":  # [3659]
                undo_entry["action_data"]["angle_tool_config_before"] = (
                    angle_tool_config_for_undo_stack  # [3660]
                )
            elif action == "change_hatch_fill_config":  # [3661]
                undo_entry["action_data"]["hatch_fill_config_before"] = (
                    hatch_fill_config_for_undo_stack  # [3662]
                )
            elif action == "change_division_point_config":  # [3663]
                undo_entry["action_data"]["division_point_config_before"] = (
                    division_point_config_for_undo_stack  # [3664]
                )
            elif action == "change_line_point_arrow_style":  # [3665]
                undo_entry["action_data"]["previous_properties"] = (
                    line_point_arrow_style_for_undo  # [3666]
                )
            elif action == "clear_scene":  # [3667]
                undo_entry["action_data"]["background_pixmap_before"] = (
                    background_pixmap_for_undo_stack  # [3668]
                )
                undo_entry["action_data"]["shapes_before_clear"] = (
                    shapes_for_undo_stack  # [3669]
                )
            elif action == "select_angle_point":  # [3670]
                undo_entry["action_data"]["active_angle_point_handle_before"] = (
                    active_angle_point_handle_for_undo  # [3671]
                )
                undo_entry["action_data"]["active_angle_shape_before"] = (
                    active_angle_shape_for_undo  # [3672]
                )

            self.undo_stack.append(undo_entry)  # [3673]

            self.current_drawing_shape = None  # [3674]
            self.resizing = False  # [3675]
            self.dragging = False  # [3676]
            self.drag_start_pos = None  # [3677]
            self.drag_start_geometries = {}  # [3678]
            self.polygon_points = []  # [3679]
            self.angle_points = []  # [3680]
            self.brush_points = []  # [3681]
            self.spline_points = []  # [3682]
            self.is_lasso_selecting = False  # [3683]
            self.dimension_points.clear()  # [3684]
            self.dimension_preview_shapes.clear()  # [3685]
            self.input_mode = None  # [3686]
            if action not in ["select_angle_point", "select_angle_text"]:  # [3687]
                self.active_angle_point_handle = None  # [3688]
                self.active_angle_shape_for_point_drag = None  # [3689]

            if self.show_angle_offset:  # [3690]
                self.recalculate_and_update_angle_offsets()  # [3691]
            else:  # [3692]
                self.update()  # [3693]

            self._configure_mode()  # [3694]

            print(f"Redo successful. Redo stack size: {len(self.redo_stack)}")  # [3695]

        except Exception as e:  # [3696]
            print(f"Error during redo operation for action '{action}': {e}")  # [3697]
            traceback.print_exc()  # [3698]

    def remove_shapes_by_animation_tag(self, tag_to_remove):  # [3699]
        """Removes all shapes with the given animation tag."""  # [3700]
        if not tag_to_remove:  # [3701]
            return  # [3702]

        original_shapes_count = len(self.shapes)  # [3703]
        self.shapes = [
            shape for shape in self.shapes if shape.animation_tag != tag_to_remove
        ]  # [3704]
        num_removed = original_shapes_count - len(self.shapes)  # [3705]

        if num_removed > 0:  # [3706]
            print(
                f"Removed {num_removed} shapes with animation tag '{tag_to_remove}'."
            )  # [3707]
            self.update()  # [3708]

    def mousePressEvent(self, event: QMouseEvent):  # [3709]
        """Handles mouse press events for drawing, selecting, resizing, dragging."""  # [3710]
        if not self.drawing_mode:
            return  # [3711]
        if self.input_mode:  # [3712]
            print(
                f"Cancelling input mode '{self.input_mode}' due to mouse press."
            )  # [3713]
            self.input_mode = None  # [3714]
            self.update()  # [3715]

        if not self.isActiveWindow():  # [3716]
            self.activateWindow()  # [3717]
        if not self.hasFocus():  # [3718]
            self.setFocus(Qt.FocusReason.MouseFocusReason)  # [3719]

        pos = event.position()  # [3720]
        self.current_mouse_pos = pos  # [3721]

        # Apply snapping to the click position # [3722]
        snapped_pos = self._get_snapped_point(pos)  # [3723]
        if snapped_pos is not None:  # [3724]
            print(f"Original click: {pos}, Snapped click: {snapped_pos}")  # [3725]
            pos = snapped_pos  # Replace original position with snapped one # [3726]
            self.current_mouse_pos = pos  # Also update current_mouse_pos # [3727]

        modifiers = event.modifiers()  # [3728]
        ctrl_pressed = modifiers & Qt.KeyboardModifier.ControlModifier  # [3729]
        alt_pressed = modifiers & Qt.KeyboardModifier.AltModifier  # [3730]
        shift_pressed = modifiers & Qt.KeyboardModifier.ShiftModifier  # [3731]

        if self.current_tool == "dimension":  # [3732]
            if event.button() == Qt.MouseButton.LeftButton:  # [3733]
                if len(self.dimension_points) == 0:  # [3734]
                    self.dimension_points.append(pos)  # [3735]
                    print(f"Dimension Tool: Point 1 set at {pos}")  # [3736]
                    self.update()  # [3737]
                elif len(self.dimension_points) == 1:  # [3738]
                    self.dimension_points.append(pos)  # [3739]
                    print(f"Dimension Tool: Point 2 set at {pos}")  # [3740]
                    self.update()  # [3741]
                elif len(self.dimension_points) == 2:  # [3742]
                    self.dimension_points.append(pos)  # [3743]
                    print(f"Dimension Tool: Offset point set at {pos}")  # [3744]
                    self.finalize_dimension()  # [3745]
                event.accept()  # [3746]
            elif event.button() == Qt.MouseButton.RightButton:  # [3747]
                print("Dimension Tool: Cancelled with RMB.")  # [3748]
                self.dimension_points.clear()  # [3749]
                self.dimension_preview_shapes.clear()  # [3750]
                self.update()  # [3751]
                event.accept()  # [3752]
            return  # [3753]
        elif self.current_tool == "angle_marker":  # [3754]
            if event.button() == Qt.MouseButton.LeftButton:  # [3755]
                handle = self.get_handle_at(pos)  # [3756]
                if (
                    ctrl_pressed
                    and handle
                    and handle[0].type == "angle_marker"
                    and handle[1] in ["vertex_A", "vertex_O", "vertex_B"]
                ):  # [3757]
                    shape, handle_name = handle  # [3758]
                    if shape not in self.selected_shapes:  # [3759]
                        self.selected_shapes = [shape]  # [3760]

                    self.active_angle_shape_for_point_drag = shape  # [3761]
                    self.active_angle_point_handle = handle_name  # [3762]
                    self.resizing = True  # [3763]
                    self.resize_handle = handle_name  # [3764]
                    self.drag_start_pos = pos  # [3765]
                    saved_selection_before = deepcopy(self.selected_shapes)  # [3766]
                    self.drag_start_geometries = {
                        self.shapes.index(shape): deepcopy(shape)
                    }  # [3767]
                    self.undo_indices_cache = [self.shapes.index(shape)]  # [3768]
                    self.save_state(
                        "select_angle_point",
                        selected_shapes_before=saved_selection_before,
                        selected_shapes_after=self.selected_shapes,
                    )  # [3769]

                    print(
                        f"Angle Tool: Selected point {handle_name} of existing angle marker for dragging."
                    )  # [3770]
                    self.update()  # [3771]
                    event.accept()  # [3772]
                    return  # [3773]

                elif not self.active_angle_shape_for_point_drag:  # [3774]
                    if len(self.angle_points) < 3:  # [3775]
                        self.angle_points.append(pos)  # [3776]
                        print(
                            f"Angle Tool: Point {len(self.angle_points)} set at {pos}"
                        )  # [3777]
                        if len(self.angle_points) == 3:  # [3778]
                            self.finalize_angle_marker()  # [3779]
                        self.update()  # [3780]
                    event.accept()  # [3781]
            elif event.button() == Qt.MouseButton.RightButton:  # [3782]
                print("Angle Tool: Cancelled with RMB.")  # [3783]
                self.angle_points.clear()  # [3784]
                self.current_drawing_shape = None  # [3785]
                self.active_angle_shape_for_point_drag = None  # [3786]
                self.active_angle_point_handle = None  # [3787]
                self.resizing = False  # [3788]
                self.update()  # [3789]
                event.accept()  # [3790]
            return  # [3791]
        elif self.current_tool == "spline":  # [3792]
            if event.button() == Qt.MouseButton.LeftButton:  # [3793]
                self.spline_points.append(pos)  # [3794]
                print(
                    f"Spline Tool: Point {len(self.spline_points)} set at {pos}"
                )  # [3795]
                self.update()  # [3796]
                event.accept()  # [3797]
            elif event.button() == Qt.MouseButton.RightButton:  # [3798]
                self.finish_drawing_spline()  # [3799]
                event.accept()  # [3800]
            return  # [3801]

        if event.button() == Qt.MouseButton.LeftButton:  # [3802]
            action_taken = False  # [3803]

            if self.current_tool == "line_point" and ctrl_pressed:  # [3804]
                self.is_lasso_selecting = True  # [3805]
                print("Starting Lasso Select...")  # [3806]
                if not self.polygon_points:  # [3807]
                    self.polygon_points = [pos]  # [3808]
                else:  # [3809]
                    self.polygon_points.append(pos)  # [3810]
                self.update()  # [3811]
                event.accept()  # [3812]
                action_taken = True  # [3813]
                return  # [3814]

            if (
                self.current_tool == "line_point" and not self.is_lasso_selecting
            ):  # [3815]
                point_to_add = pos  # [3816]
                if ctrl_pressed and self.snapped_line_point_preview_end:  # [3817]
                    point_to_add = self.snapped_line_point_preview_end  # [3818]

                if (
                    not self.polygon_points
                    or (point_to_add - self.polygon_points[-1]).manhattanLength() > 1e-3
                ):  # [3819]
                    self.polygon_points.append(point_to_add)  # [3820]
                self.snapped_line_point_preview_end = None  # [3821]
                self.update()  # [3822]
                event.accept()  # [3823]
                action_taken = True  # [3824]
                return  # [3825]

            handle = self.get_handle_at(pos)  # [3826]
            if handle:  # [3827]
                shape, handle_name = handle  # [3828]
                if shape.type == "arc":  # [3829]
                    print(
                        f"Arc resizing started on handle: {handle_name} (Logic TBD)"
                    )  # [3830]
                elif shape.type == "angle_marker":  # [3831]
                    if not ctrl_pressed:  # [3832]
                        pass  # [3833]
                    else:  # [3834]
                        event.accept()  # [3835]
                        return  # [3836]
                elif shape.type == "spline":  # [3837]
                    print(
                        f"Spline vertex dragging started on handle: {handle_name}"
                    )  # [3838]
                    self.resizing = True  # [3839]
                    self.resize_handle = handle_name  # [3840]
                    self.drag_start_pos = pos  # [3841]
                    if shape not in self.selected_shapes:  # [3842]
                        self.selected_shapes = [shape]  # [3843]

                    self.drag_start_geometries = {
                        self.shapes.index(shape): deepcopy(shape)
                    }  # [3844]
                    self.undo_indices_cache = [self.shapes.index(shape)]  # [3845]
                    self.update()  # [3846]
                    event.accept()  # [3847]
                    action_taken = True  # [3848]
                    return  # [3849]

                else:  # [3850]
                    print(
                        f"Starting resize on shape {shape.type}, handle: {handle_name}"
                    )  # [3851]

                self.resizing = True  # [3852]
                self.resize_handle = handle_name  # [3853]
                self.drag_start_pos = pos  # [3854]
                shapes_to_select = [shape]  # [3855]
                if shape.group_id:  # [3856]
                    group_members = [
                        s
                        for s in self.shapes
                        if s.group_id == shape.group_id and s != shape
                    ]  # [3857]
                    shapes_to_select.extend(group_members)  # [3858]

                if not ctrl_pressed:  # [3859]
                    if shape not in self.selected_shapes:  # [3860]
                        self.selected_shapes = shapes_to_select  # [3861]
                else:  # [3862]
                    for s_to_sel in shapes_to_select:  # [3863]
                        if s_to_sel not in self.selected_shapes:  # [3864]
                            self.selected_shapes.append(s_to_sel)  # [3865]

                if self.show_angle_offset:  # [3866]
                    self.recalculate_and_update_angle_offsets()  # [3867]

                self.drag_start_geometries = {}  # [3868]
                current_indices_for_resize = []  # [3869]
                for s_sel in self.selected_shapes:  # [3870]
                    try:  # [3871]
                        idx = self.shapes.index(s_sel)  # [3872]
                        self.drag_start_geometries[idx] = deepcopy(s_sel)  # [3873]
                        current_indices_for_resize.append(idx)  # [3874]
                    except ValueError:
                        pass  # [3875]
                self.undo_indices_cache = current_indices_for_resize  # [3876]
                self.update()  # [3877]
                event.accept()  # [3878]
                action_taken = True  # [3879]
                return  # [3880]

            top_shape = None  # [3881]
            top_shape_idx = -1  # [3882]
            for i, shape_iter in enumerate(reversed(self.shapes)):  # [3883]
                if (
                    shape_iter
                    and shape_iter.geometry
                    and shape_iter.visible
                    and shape_iter.contains(pos)
                ):  # [3884]
                    top_shape = shape_iter  # [3885]
                    top_shape_idx = len(self.shapes) - 1 - i  # [3886]
                    break  # [3887]

            if ctrl_pressed and top_shape:  # [3888]
                print(f"Ctrl+Click on shape {top_shape_idx}")  # [3889]
                selection_changed = False  # [3890]
                saved_selection_before = deepcopy(self.selected_shapes)  # [3891]
                shapes_to_toggle = []  # [3892]

                if (
                    top_shape.type == "angle_marker" and not top_shape.is_label
                ):  # [3893]
                    shapes_to_toggle = [top_shape]  # [3894]
                elif (
                    top_shape.type == "text"
                    and top_shape.text_properties
                    and top_shape.text_properties.get("is_angle_display")
                ):  # [3895]
                    shapes_to_toggle = [top_shape]  # [3896]
                elif top_shape.is_dimension_part:  # [3897]
                    shapes_to_toggle = [top_shape]  # [3898]
                elif top_shape.group_id:  # [3899]
                    shapes_to_toggle = [
                        s for s in self.shapes if s.group_id == top_shape.group_id
                    ]  # [3900]
                else:  # [3901]
                    shapes_to_toggle = [top_shape]  # [3902]

                all_in_selection = all(
                    s_toggle in self.selected_shapes for s_toggle in shapes_to_toggle
                )  # [3903]

                if all_in_selection:  # [3904]
                    for s_toggle in shapes_to_toggle:  # [3905]
                        if s_toggle in self.selected_shapes:  # [3906]
                            self.selected_shapes.remove(s_toggle)  # [3907]
                            selection_changed = True  # [3908]
                            if (
                                s_toggle == self.active_angle_shape_for_point_drag
                            ):  # [3909]
                                self.active_angle_shape_for_point_drag = None  # [3910]
                                self.active_angle_point_handle = None  # [3911]
                else:  # [3912]
                    for s_toggle in shapes_to_toggle:  # [3913]
                        if s_toggle not in self.selected_shapes:  # [3914]
                            self.selected_shapes.append(s_toggle)  # [3915]
                            selection_changed = True  # [3916]

                if selection_changed:  # [3917]
                    undo_action_type = (
                        "select_angle_text"
                        if (
                            top_shape.type == "text"
                            and top_shape.text_properties
                            and top_shape.text_properties.get("is_angle_display")
                        )
                        else (
                            "select_angle_point"
                            if top_shape.type == "angle_marker"
                            else "select_single_dim_part"
                        )
                    )  # [3918]
                    self.save_state(
                        undo_action_type,
                        selected_shapes_before=saved_selection_before,
                        selected_shapes_after=deepcopy(self.selected_shapes),
                    )  # [3919]
                    if self.show_angle_offset:  # [3920]
                        self.recalculate_and_update_angle_offsets()  # [3921]
                    else:  # [3922]
                        self.update()  # [3923]
                event.accept()  # [3924]
                action_taken = True  # [3925]
                return  # [3926]

            if (
                not ctrl_pressed and top_shape and top_shape in self.selected_shapes
            ):  # [3927]
                if (
                    top_shape.type == "text"
                    and top_shape.text_properties
                    and top_shape.text_properties.get("is_angle_display")
                ):  # [3928]
                    print(
                        f"Starting drag for angle text: {top_shape.group_id}"
                    )  # [3929]
                    self.dragging = True  # [3930]
                    self.drag_start_pos = pos  # [3931]
                    self.drag_start_geometries = {}  # [3932]
                    current_indices_for_drag = []  # [3933]
                    marker_shape = next(
                        (
                            s
                            for s in self.shapes
                            if s.group_id == top_shape.group_id
                            and s.type == "angle_marker"
                            and s in self.selected_shapes
                        ),
                        None,
                    )  # [3934]
                    shapes_to_drag_this_time = [top_shape]  # [3935]
                    if marker_shape and marker_shape in self.selected_shapes:  # [3936]
                        shapes_to_drag_this_time.append(marker_shape)  # [3937]

                    for s_sel in shapes_to_drag_this_time:  # [3938]
                        try:  # [3939]
                            idx = self.shapes.index(s_sel)  # [3940]
                            self.drag_start_geometries[idx] = deepcopy(s_sel)  # [3941]
                            current_indices_for_drag.append(idx)  # [3942]
                        except ValueError:
                            pass  # [3943]
                    self.undo_indices_cache = current_indices_for_drag  # [3944]
                    self.update()  # [3945]
                    event.accept()  # [3946]
                    action_taken = True  # [3947]
                    return  # [3948]
                elif top_shape.type == "angle_marker":  # [3949]
                    print(
                        f"Starting drag for angle marker shape (group: {top_shape.group_id})"
                    )  # [3950]
                    self.dragging = True  # [3951]
                    self.drag_start_pos = pos  # [3952]
                    self.drag_start_geometries = {}  # [3953]
                    current_indices_for_drag = []  # [3954]
                    shapes_to_drag_group = [
                        s for s in self.shapes if s.group_id == top_shape.group_id
                    ]  # [3955]
                    for s_sel in shapes_to_drag_group:  # [3956]
                        if s_sel not in self.selected_shapes:  # [3957]
                            self.selected_shapes.append(s_sel)  # [3958]
                        try:  # [3959]
                            idx = self.shapes.index(s_sel)  # [3960]
                            self.drag_start_geometries[idx] = deepcopy(s_sel)  # [3961]
                            current_indices_for_drag.append(idx)  # [3962]
                        except ValueError:
                            pass  # [3963]
                    self.undo_indices_cache = current_indices_for_drag  # [3964]
                    self.update()  # [3965]
                    event.accept()  # [3966]
                    action_taken = True  # [3967]
                    return  # [3968]
                else:  # [3969]
                    print(
                        f"Starting drag for {len(self.selected_shapes)} selected shape(s)"
                    )  # [3970]
                    self.dragging = True  # [3971]
                    self.drag_start_pos = pos  # [3972]
                    self.drag_start_geometries = {}  # [3973]
                    current_indices_for_drag = []  # [3974]
                    for s_sel in self.selected_shapes:  # [3975]
                        try:  # [3976]
                            idx = self.shapes.index(s_sel)  # [3977]
                            self.drag_start_geometries[idx] = deepcopy(s_sel)  # [3978]
                            current_indices_for_drag.append(idx)  # [3979]
                        except ValueError:
                            pass  # [3980]
                    self.undo_indices_cache = current_indices_for_drag  # [3981]
                    self.update()  # [3982]
                    event.accept()  # [3983]
                    action_taken = True  # [3984]
                    return  # [3985]

            if not action_taken or (ctrl_pressed and top_shape):  # [3986]
                if not ctrl_pressed and not top_shape:  # [3987]
                    if self.selected_shapes:  # [3988]
                        print("Click on empty space: Clearing selection.")  # [3989]
                        saved_selection_before = deepcopy(
                            self.selected_shapes
                        )  # [3990]
                        self.selected_shapes = []  # [3991]
                        self.save_state(
                            "select_single_dim_part",
                            selected_shapes_before=saved_selection_before,
                            selected_shapes_after=[],
                        )  # [3992]
                        if self.show_angle_offset:  # [3993]
                            self.recalculate_and_update_angle_offsets()  # [3994]
                        else:  # [3995]
                            self.update()  # [3996]
                        self.active_angle_shape_for_point_drag = None  # [3997]
                        self.active_angle_point_handle = None  # [3998]

                self.dragging = False  # [3999]
                self.resizing = False  # [4000]
                self.drag_start_pos = None  # [4001]

                if self.current_tool == "MPoint":  # [4002]
                    print(f"Creating MPoint at {pos}")  # [4003]
                    self.create_mpoint_with_label(pos)  # [4004]
                    self.drag_start_pos = None  # [4005]
                    self.current_drawing_shape = None  # [4006]
                    event.accept()  # [4007]
                    return  # [4008]

                fixed_params = self.get_fixed_size_params(self.current_tool)  # [4009]
                fixed_size_tool = fixed_params is not None  # [4010]

                if fixed_size_tool:  # [4011]
                    print(
                        f"Fixed size draw requested: {self.current_tool} with params {fixed_params}"
                    )  # [4012]
                    pen_color = self._get_current_mode_pen_color()  # [4013]
                    alpha = self.current_alpha  # [4014]
                    thickness = self.current_line_thickness  # [4015]
                    line_style = self.current_line_style  # [4016]
                    line_pattern = self.current_line_pattern  # [4017]
                    filled = (
                        self.control_panel.fill_check.isChecked()
                        if self.control_panel
                        else True
                    )  # [4018]
                    kwargs = {}  # [4019]

                    final_shape = self.create_fixed_shape(
                        pos,
                        self.current_tool,
                        fixed_params,
                        pen_color,
                        alpha,
                        thickness,
                        line_style,
                        line_pattern,
                        filled,
                        kwargs,
                    )  # [4020]

                    if final_shape:  # [4021]
                        self.shapes.append(final_shape)  # [4022]
                        self.save_state(
                            "draw", indices=[len(self.shapes) - 1]
                        )  # [4023]
                        if self.temp_mode:
                            self.schedule_shape_removal(final_shape)  # [4024]
                        self._configure_mode()  # [4025]
                        self.update()  # [4026]
                        print(f"Fixed size {self.current_tool} created.")  # [4027]
                        if (
                            not self.board_mode
                            and not self.edit_mode
                            and not self.temp_mode
                        ):  # [4028]
                            self.set_drawing_mode(False)  # [4029]
                    else:  # [4030]
                        print(
                            f"Warning: Could not create fixed size shape for tool {self.current_tool}"
                        )  # [4031]

                    self.drag_start_pos = None  # [4032]
                    self.current_drawing_shape = None  # [4033]
                    event.accept()  # [4034]
                    return  # [4035]

                self.drag_start_pos = pos  # [4036]
                pen_color = self._get_current_mode_pen_color()  # [4037]
                alpha = self.current_alpha
                thickness = self.current_line_thickness
                line_style = self.current_line_style
                line_pattern = self.current_line_pattern  # [4038]
                arrow_size = self.current_arrow_head_size
                brush_size = self.brush_size  # [4039]
                filled = (
                    self.control_panel.fill_check.isChecked()
                    if self.control_panel
                    else True
                )  # [4040]
                kwargs = {}  # [4041]
                hatch_props = None  # [4042]
                if (
                    self.control_panel and self.control_panel.hatch_fill_enabled()
                ):  # [4043]
                    hatch_props = {  # [4044]
                        "style": self.control_panel.get_hatch_style(),  # [4045]
                        "color": self.current_hatch_color,  # [4046]
                        "thickness": self.current_hatch_thickness,  # [4047]
                    }  # [4048]

                if not self.is_lasso_selecting:  # [4049]
                    if self.current_tool in [
                        "rect",
                        "ellipse",
                        "arc",
                        "trapeze",
                        "regular_polygon",
                    ]:  # [4050]
                        geom = QRectF(pos, QSizeF(0, 0))  # [4051]
                        actual_fill = (
                            filled
                            if self.current_tool
                            in ["rect", "ellipse", "trapeze", "regular_polygon", "arc"]
                            else False
                        )  # [4052]
                        if self.current_tool == "arc":  # [4053]
                            kwargs["startAngle"] = 0  # [4054]
                            kwargs["spanAngle"] = self.current_arc_span_angle  # [4055]
                        if self.current_tool == "rect":  # [4056]
                            kwargs["rounded"] = (
                                self.control_panel.fixed_size_widgets["rect"][
                                    "Rounded"
                                ].isChecked()
                                if self.control_panel
                                and "rect" in self.control_panel.fixed_size_widgets
                                else False
                            )  # [4057]
                            kwargs["corner_radius"] = (
                                self.control_panel.fixed_size_widgets["rect"][
                                    "Radius"
                                ].value()
                                if self.control_panel
                                and "rect" in self.control_panel.fixed_size_widgets
                                else 5
                            )  # [4058]
                        if self.current_tool == "regular_polygon":  # [4059]
                            kwargs["num_sides"] = (
                                self.control_panel.fixed_size_widgets[
                                    "regular_polygon"
                                ]["Sides"].value()
                                if self.control_panel
                                and "regular_polygon"
                                in self.control_panel.fixed_size_widgets
                                else 5
                            )  # [4060]

                        self.current_drawing_shape = Shape(  # [4061]
                            self.current_tool,
                            geom,
                            pen_color,  # [4062]
                            filled=actual_fill,
                            alpha=alpha,
                            line_thickness=thickness,  # [4063]
                            line_style=line_style,
                            line_pattern=line_pattern,  # [4064]
                            gradient_properties=None,
                            hatch_properties=hatch_props,  # [4065]
                            **kwargs,  # [4066]
                        )  # [4067]
                    elif self.current_tool == "line_point":
                        pass  # [4068]
                    elif self.current_tool == "spline":
                        pass  # [4069]
                    elif self.current_tool == "text":  # [4070]
                        self.current_drawing_shape = None  # [4071]
                    elif self.current_tool in ["line", "arrow"]:  # [4072]
                        double_headed_state = False  # [4073]
                        if (
                            self.current_tool == "arrow"
                            and self.control_panel
                            and "arrow" in self.control_panel.fixed_size_widgets
                            and "DoubleHeaded"
                            in self.control_panel.fixed_size_widgets["arrow"]
                        ):  # [4074]
                            double_headed_state = self.control_panel.fixed_size_widgets[
                                "arrow"
                            ]["DoubleHeaded"].isChecked()  # [4075]
                        self.current_drawing_shape = Shape(
                            self.current_tool,
                            [pos, pos],
                            pen_color,
                            filled=False,
                            alpha=alpha,
                            line_thickness=thickness,
                            line_style=line_style,
                            line_pattern=line_pattern,
                            gradient_properties=None,
                            hatch_properties=hatch_props,
                            arrow_head_size=(
                                arrow_size if self.current_tool == "arrow" else None
                            ),
                            double_headed=double_headed_state,
                        )  # [4076]
                    elif self.current_tool == "triangle":  # [4077]
                        actual_fill = (
                            filled if self.current_tool == "triangle" else False
                        )  # [4078]
                        self.current_drawing_shape = Shape(
                            "triangle",
                            [pos, pos, pos],
                            pen_color,
                            filled=actual_fill,
                            alpha=alpha,
                            line_thickness=thickness,
                            line_style=line_style,
                            line_pattern=line_pattern,
                            gradient_properties=None,
                            hatch_properties=hatch_props,
                        )  # [4079]
                    elif (
                        self.current_tool in ["polygon", "line_point"]
                        and not self.is_lasso_selecting
                    ):  # [4080]
                        if not self.polygon_points:  # [4081]
                            self.polygon_points = [pos]  # [4082]
                        else:  # [4083]
                            self.polygon_points.append(pos)  # [4084]
                        self.update()  # [4085]
                        event.accept()  # [4086]
                        return  # [4087]
                    elif self.current_tool == "brush":  # [4088]
                        self.brush_points = [pos]  # [4089]
                        self.current_drawing_shape = Shape(
                            "brush",
                            self.brush_points,
                            pen_color,
                            filled=False,
                            alpha=alpha,
                            line_thickness=brush_size,
                            line_style=Qt.PenStyle.SolidLine,
                            line_pattern=None,
                            gradient_properties=None,
                            hatch_properties=None,
                        )  # [4090]
                    self.update()  # [4091]
                event.accept()  # [4092]

        elif (
            event.button() == Qt.MouseButton.RightButton and self.drawing_mode
        ):  # [4093]
            if self.input_mode:  # [4094]
                print(
                    f"Cancelling input mode '{self.input_mode}' due to RMB press."
                )  # [4095]
                self.input_mode = None  # [4096]
                self.update()  # [4097]
                event.accept()  # [4098]
                return  # [4099]
            if (
                self.current_tool in ["polygon", "line_point"] and self.polygon_points
            ):  # [4100]
                if self.is_lasso_selecting:  # [4101]
                    print("Cancelling Lasso Select with RMB.")  # [4102]
                    self.is_lasso_selecting = False  # [4103]
                    self.polygon_points = []  # [4104]
                    self.update()  # [4105]
                else:  # [4106]
                    self.finish_drawing_poly_line()  # [4107]
            elif self.current_tool == "spline" and self.spline_points:  # [4108]
                self.finish_drawing_spline()  # [4109]
            else:  # [4110]
                selection_was_cleared = len(self.selected_shapes) > 0  # [4111]
                print("Right-click: Clearing selection/drawing action.")  # [4112]
                if not ctrl_pressed:  # [4113]
                    self.selected_shapes = []  # [4114]
                    self.active_angle_shape_for_point_drag = None  # [4115]
                    self.active_angle_point_handle = None  # [4116]

                self.current_drawing_shape = None  # [4117]
                self.polygon_points = []  # [4118]
                self.angle_points = []  # [4119]
                self.brush_points = []  # [4120]
                self.spline_points = []  # [4121]
                self.resizing = False  # [4122]
                self.dragging = False  # [4123]
                self.is_lasso_selecting = False  # [4124]
                if self.current_tool == "dimension":  # [4125]
                    self.dimension_points.clear()  # [4126]
                    self.dimension_preview_shapes.clear()  # [4127]
                elif self.current_tool == "angle_marker":  # [4128]
                    self.angle_points.clear()  # [4129]

                if (
                    selection_was_cleared
                    and self.show_angle_offset
                    and not ctrl_pressed
                ):  # [4130]
                    self.recalculate_and_update_angle_offsets()  # [4131]
                else:
                    self.update()  # [4132]
            event.accept()  # [4133]

    def finish_drawing_poly_line(self):  # [4134]
        """Helper function to finalize the current polygon or line point drawing."""  # [4135]
        tool = self.current_tool  # [4136]
        min_points = 3 if tool == "polygon" else 1  # [4137]
        if (
            tool == "polygon"
            and len(self.polygon_points) >= 2
            and self.polygon_points[-1] == self.polygon_points[-2]
        ):  # [4138]
            self.polygon_points.pop()  # [4139]

        if len(self.polygon_points) >= min_points:  # [4140]
            pen_color = self._get_current_mode_pen_color()  # [4141]

            alpha = self.current_alpha  # [4142]
            thickness = self.current_line_thickness  # [4143]
            line_style = self.current_line_style  # [4144]
            line_pattern = self.current_line_pattern  # [4145]
            is_fillable = tool == "polygon"  # [4146]
            filled = is_fillable and (
                self.control_panel.fill_check.isChecked()
                if self.control_panel
                else True
            )  # [4147]
            hatch_props = None  # [4148]
            if (
                self.control_panel
                and self.control_panel.hatch_fill_enabled()
                and is_fillable
            ):  # [4149]
                hatch_props = {  # [4150]
                    "style": self.control_panel.get_hatch_style(),  # [4151]
                    "color": self.current_hatch_color,  # [4152]
                    "thickness": self.current_hatch_thickness,  # [4153]
                }  # [4154]

            lpas = None  # [4155]
            ahs = None  # [4156]
            if tool == "line_point":  # [4157]
                lpas = self.current_line_point_arrow_style  # [4158]
                if lpas:  # [4159]
                    ahs = self.current_arrow_head_size  # [4160]

            final_geometry = self.polygon_points[:]  # [4161]
            final_shape = Shape(
                tool,
                final_geometry,
                pen_color,
                filled=filled,
                alpha=alpha,
                line_thickness=thickness,
                line_style=line_style,
                line_pattern=line_pattern,
                gradient_properties=None,
                hatch_properties=hatch_props,
                line_point_arrow_style=lpas,
                arrow_head_size=ahs,
            )  # [4162]
            self.shapes.append(final_shape)  # [4163]
            self.save_state("draw", indices=[len(self.shapes) - 1])  # [4164]

            if self.temp_mode:  # [4165]
                self.schedule_shape_removal(final_shape)  # [4166]

            self._configure_mode()  # [4167]

            if (
                not self.board_mode and not self.edit_mode and not self.temp_mode
            ):  # [4168]
                self.set_drawing_mode(False)  # [4169]
        else:  # [4170]
            print(
                f"Not enough points ({len(self.polygon_points)}/{min_points}) to create {tool}, discarding."
            )  # [4171]
        self.polygon_points = []  # [4172]
        self.current_drawing_shape = None  # [4173]
        self.is_lasso_selecting = False  # [4174]
        self.update()  # [4175]

    def finish_drawing_spline(self):  # [4176]
        """Finalizes drawing a Spline curve."""  # [4177]
        if (
            len(self.spline_points) >= 4 and (len(self.spline_points) - 1) % 3 == 0
        ):  # [4178]
            print(
                f"Finalizing Spline shape with {len(self.spline_points)} points."
            )  # [4179]
            pen_color = self._get_current_mode_pen_color()  # [4180]
            alpha = self.current_alpha  # [4181]
            thickness = self.current_line_thickness  # [4182]
            line_style = self.current_line_style  # [4183]
            line_pattern = self.current_line_pattern  # [4184]

            lpas = self.current_line_point_arrow_style  # [4185]
            ahs = None  # [4186]
            if lpas:  # [4187]
                ahs = self.current_arrow_head_size  # [4188]

            final_geometry = self.spline_points[:]  # [4189]
            final_shape = Shape(  # [4190]
                "spline",
                final_geometry,
                pen_color,  # [4191]
                filled=False,
                alpha=alpha,
                line_thickness=thickness,  # [4192]
                line_style=line_style,
                line_pattern=line_pattern,  # [4193]
                line_point_arrow_style=lpas,
                arrow_head_size=ahs,  # [4194]
            )  # [4195]
            self.shapes.append(final_shape)  # [4196]
            self.save_state("draw_spline", indices=[len(self.shapes) - 1])  # [4197]

            if self.temp_mode:  # [4198]
                self.schedule_shape_removal(final_shape)  # [4199]

            self._configure_mode()  # [4200]
            print("Spline shape added.")  # [4201]

            if (
                not self.board_mode and not self.edit_mode and not self.temp_mode
            ):  # [4202]
                self.set_drawing_mode(False)  # [4203]
        else:  # [4204]
            print(
                f"Not enough or incorrect number of points ({len(self.spline_points)}) for Spline, discarding."
            )  # [4205]

        self.spline_points = []  # [4206]
        self.current_drawing_shape = None  # [4207]
        self.update()  # [4208]

    def mouseMoveEvent(self, event: QMouseEvent):  # [4209]
        """Handles mouse movement for drawing preview, dragging, and resizing."""  # [4210]
        if not self.drawing_mode:
            return  # [4211]
        if self.input_mode:  # [4212]
            print(
                f"Cancelling input mode '{self.input_mode}' due to mouse move."
            )  # [4213]
            self.input_mode = None  # [4214]
            self.update()  # [4215]

        pos = event.position()  # [4216]

        # Apply snapping to cursor position # [4217]
        self.snapped_point_preview = None  # Reset feedback # [4218]
        self.snapped_line_preview = None  # [4219]
        snapped_pos = self._get_snapped_point(pos)  # [4220]
        if snapped_pos is not None:  # [4221]
            pos = snapped_pos  # Replace original position with snapped one # [4222]

        self.current_mouse_pos = pos  # [4223]

        modifiers = event.modifiers()  # [4224]
        shift_pressed = modifiers & Qt.KeyboardModifier.ShiftModifier  # [4225]
        ctrl_pressed = modifiers & Qt.KeyboardModifier.ControlModifier  # [4226]

        if not ctrl_pressed or not (  # [4227]
            (
                self.current_drawing_shape
                and self.current_drawing_shape.type in ["line", "arrow", "angle_marker"]
            )  # [4228]
            or (self.current_tool == "line_point" and self.polygon_points)  # [4229]
        ):  # [4230]
            if self.current_snap_angle is not None:  # [4231]
                self.current_snap_angle = None  # [4232]
                self.update()  # [4233]
            if (
                self.snapped_line_point_preview_end is not None and not ctrl_pressed
            ):  # [4234]
                self.snapped_line_point_preview_end = None  # [4235]
                self.update()  # [4236]

        if self.resizing and self.resize_handle and self.drag_start_pos:  # [4237]
            direct_shape = (
                self.active_angle_shape_for_point_drag
                if self.active_angle_shape_for_point_drag
                else (self.selected_shapes[0] if self.selected_shapes else None)
            )  # [4238]
            if not direct_shape:
                return  # [4239]

            shape_index = -1  # [4240]
            try:
                shape_index = self.shapes.index(direct_shape)  # [4241]
            except ValueError:
                print("Warning: Resized shape not found in list.")
                return  # [4242]

            if shape_index not in self.drag_start_geometries:  # [4243]
                print("Warning: Missing original shape data for resize.")  # [4244]
                return  # [4245]

            original_shape_copy = self.drag_start_geometries[shape_index]  # [4246]
            shape_being_resized = self.shapes[shape_index]  # [4247]

            if (
                shape_being_resized.type == "arc" and "arc_" in self.resize_handle
            ):  # [4248]
                original_geo_arc = original_shape_copy.geometry  # [4249]
                original_arc_center_for_inv = self._get_arc_visual_center(
                    original_shape_copy
                )  # [4250]

                inv_transform_arc = QTransform()  # [4251]
                if (
                    original_shape_copy.rotation != 0
                    and not original_arc_center_for_inv.isNull()
                ):  # [4252]
                    inv_transform_arc.translate(
                        original_arc_center_for_inv.x(), original_arc_center_for_inv.y()
                    )  # [4253]
                    inv_transform_arc.rotate(-original_shape_copy.rotation)  # [4254]
                    inv_transform_arc.translate(
                        -original_arc_center_for_inv.x(),
                        -original_arc_center_for_inv.y(),
                    )  # [4255]

                unrotated_pos_arc = inv_transform_arc.map(pos)  # [4256]

                original_rect_center = original_geo_arc.center()  # [4257]

                if self.resize_handle == "arc_start":  # [4258]
                    delta_from_center = (
                        unrotated_pos_arc - original_rect_center
                    )  # [4259]
                    new_start_angle_rad = math.atan2(
                        -delta_from_center.y(), delta_from_center.x()
                    )  # [4260]
                    new_start_angle_deg = math.degrees(new_start_angle_rad)  # [4261]
                    shape_being_resized.startAngle = new_start_angle_deg % 360  # [4262]

                elif self.resize_handle == "arc_end":  # [4263]
                    delta_from_center = (
                        unrotated_pos_arc - original_rect_center
                    )  # [4264]
                    new_end_angle_rad = math.atan2(
                        -delta_from_center.y(), delta_from_center.x()
                    )  # [4265]
                    new_end_angle_deg = math.degrees(new_end_angle_rad)  # [4266]
                    current_start_deg_norm = (
                        shape_being_resized.startAngle % 360
                    )  # [4267]
                    new_end_deg_norm = new_end_angle_deg % 360  # [4268]

                    new_span_deg = new_end_deg_norm - current_start_deg_norm  # [4269]
                    if new_span_deg <= 0:
                        new_span_deg += 360  # [4270]
                    shape_being_resized.spanAngle = new_span_deg  # [4271]

                elif self.resize_handle == "arc_mid":  # [4272]
                    delta_from_center = (
                        unrotated_pos_arc - original_rect_center
                    )  # [4273]
                    new_mid_angle_rad = math.atan2(
                        -delta_from_center.y(), delta_from_center.x()
                    )  # [4274]
                    new_mid_angle_deg = math.degrees(new_mid_angle_rad)  # [4275]

                    current_start_deg_norm = (
                        shape_being_resized.startAngle % 360
                    )  # [4276]

                    span_candidate1 = (
                        new_mid_angle_deg - current_start_deg_norm
                    ) * 2  # [4277]
                    if span_candidate1 <= 0:
                        span_candidate1 += 720  # [4278]
                    span_candidate1 %= 360  # [4279]
                    if span_candidate1 == 0 and shape_being_resized.spanAngle > 180:
                        span_candidate1 = 360  # [4280]

                    shape_being_resized.spanAngle = max(
                        1, min(360, span_candidate1)
                    )  # [4281]

                self.update()  # [4282]
                return  # [4283]

            original_geo = original_shape_copy.geometry  # [4284]
            original_rotation = original_shape_copy.rotation  # [4285]

            center = QPointF()  # [4286]
            current_geo_for_center = shape_being_resized.geometry  # [4287]
            if shape_being_resized.type == "arc":  # [4288]
                center = self._get_arc_visual_center(shape_being_resized)  # [4289]
            elif (
                shape_being_resized.type in ["line", "arrow", "angle_marker"]
                and isinstance(current_geo_for_center, list)
                and len(current_geo_for_center) > 0
                and isinstance(current_geo_for_center[0], QPointF)
            ):  # [4290]
                center = current_geo_for_center[0]  # [4291]
                if (
                    shape_being_resized.type == "angle_marker"
                    and len(current_geo_for_center) == 3
                ):  # [4292]
                    center = current_geo_for_center[1]  # [4293]
            elif (
                isinstance(current_geo_for_center, QRectF)
                and current_geo_for_center.isValid()
            ):  # [4294]
                center = current_geo_for_center.center()  # [4295]
            elif isinstance(current_geo_for_center, QPointF):  # [4296]
                center = current_geo_for_center  # [4297]
            elif isinstance(current_geo_for_center, list):  # [4298]
                valid_points = [
                    p for p in current_geo_for_center if isinstance(p, QPointF)
                ]  # [4299]
                if valid_points:
                    center = QPointF(
                        sum(p.x() for p in valid_points) / len(valid_points),
                        sum(p.y() for p in valid_points) / len(valid_points),
                    )  # [4300]

            can_rotate = not center.isNull()  # [4301]

            inv_transform = QTransform()  # [4302]
            if shape_being_resized.rotation != 0 and can_rotate:  # [4303]
                inv_transform.translate(center.x(), center.y())  # [4304]
                inv_transform.rotate(-shape_being_resized.rotation)  # [4305]
                inv_transform.translate(-center.x(), -center.y())  # [4306]
            unrotated_pos = inv_transform.map(pos) if can_rotate else pos  # [4307]

            unrotated_original_geo = None  # [4308]
            if isinstance(original_geo, QRectF):  # [4309]
                original_transform_center = QPointF()  # [4310]
                if original_shape_copy.type == "arc":  # [4311]
                    original_transform_center = self._get_arc_visual_center(
                        original_shape_copy
                    )  # [4312]
                else:  # [4313]
                    original_transform_center = original_geo.center()  # [4314]

                if (
                    original_rotation != 0 and not original_transform_center.isNull()
                ):  # [4315]
                    orig_inv_tf = (
                        QTransform()
                        .translate(
                            original_transform_center.x(), original_transform_center.y()
                        )
                        .rotate(-original_rotation)
                        .translate(
                            -original_transform_center.x(),
                            -original_transform_center.y(),
                        )
                    )  # [4316]
                    unrotated_original_geo = orig_inv_tf.mapRect(original_geo)  # [4317]
                else:  # [4318]
                    unrotated_original_geo = QRectF(original_geo)  # [4319]

            elif isinstance(original_geo, QPointF):  # [4320]
                if original_rotation != 0 and not original_geo.isNull():  # [4321]
                    orig_inv_tf = (
                        QTransform()
                        .translate(original_geo.x(), original_geo.y())
                        .rotate(-original_rotation)
                        .translate(-original_geo.x(), -original_geo.y())
                    )  # [4322]
                    unrotated_original_geo = orig_inv_tf.map(original_geo)  # [4323]
                else:  # [4324]
                    unrotated_original_geo = QPointF(original_geo)  # [4325]
            elif isinstance(original_geo, list):  # [4326]
                valid_orig_points = [
                    p for p in original_geo if isinstance(p, QPointF)
                ]  # [4327]
                if len(valid_orig_points) == len(original_geo):  # [4328]
                    if original_rotation != 0:  # [4329]
                        orig_rot_center_list = QPointF()  # [4330]
                        if original_shape_copy.type in ["line", "arrow"]:
                            orig_rot_center_list = valid_orig_points[0]  # [4331]
                        elif (
                            original_shape_copy.type == "angle_marker"
                            and len(valid_orig_points) == 3
                        ):
                            orig_rot_center_list = valid_orig_points[1]  # [4332]
                        else:  # [4333]
                            orig_rot_center_list = QPointF(
                                sum(p.x() for p in valid_orig_points)
                                / len(valid_orig_points),
                                sum(p.y() for p in valid_orig_points)
                                / len(valid_orig_points),
                            )  # [4334]

                        if not orig_rot_center_list.isNull():  # [4335]
                            orig_inv_tf = (
                                QTransform()
                                .translate(
                                    orig_rot_center_list.x(), orig_rot_center_list.y()
                                )
                                .rotate(-original_rotation)
                                .translate(
                                    -orig_rot_center_list.x(), -orig_rot_center_list.y()
                                )
                            )  # [4336]
                            unrotated_original_geo = [
                                orig_inv_tf.map(p) for p in valid_orig_points
                            ]  # [4337]
                        else:
                            unrotated_original_geo = [
                                QPointF(p) for p in valid_orig_points
                            ]  # [4338]
                    else:  # [4339]
                        unrotated_original_geo = [
                            QPointF(p) for p in valid_orig_points
                        ]  # [4340]
                else:
                    unrotated_original_geo = None  # [4341]

            if unrotated_original_geo is None:  # [4342]
                print(
                    "Warning: Could not determine unrotated original geometry for resize."
                )  # [4343]
                return  # [4344]

            if isinstance(unrotated_original_geo, QRectF):  # [4345]
                new_unrotated_rect = QRectF(unrotated_original_geo)  # [4346]
                if self.resize_handle == "top_left":
                    new_unrotated_rect.setTopLeft(unrotated_pos)  # [4347]
                elif self.resize_handle == "top_right":
                    new_unrotated_rect.setTopRight(unrotated_pos)  # [4348]
                elif self.resize_handle == "bottom_right":
                    new_unrotated_rect.setBottomRight(unrotated_pos)  # [4349]
                elif self.resize_handle == "bottom_left":
                    new_unrotated_rect.setBottomLeft(unrotated_pos)  # [4350]
                new_unrotated_rect = new_unrotated_rect.normalized()  # [4351]
                if (
                    shift_pressed
                    and unrotated_original_geo.height() > 1e-6
                    and shape_being_resized.type != "arc"
                ):  # [4352]
                    original_aspect = (
                        unrotated_original_geo.width() / unrotated_original_geo.height()
                    )  # [4353]
                    current_width = new_unrotated_rect.width()
                    current_height = new_unrotated_rect.height()  # [4354]
                    if current_height < 1e-6:
                        current_height = 1e-6  # [4355]
                    new_width = current_width
                    new_height = current_height  # [4356]
                    if "left" in self.resize_handle or "right" in self.resize_handle:
                        new_height = current_width / original_aspect  # [4357]
                    else:
                        new_width = current_height * original_aspect  # [4358]
                    if self.resize_handle == "top_left":
                        new_unrotated_rect = QRectF(
                            new_unrotated_rect.right() - new_width,
                            new_unrotated_rect.bottom() - new_height,
                            new_width,
                            new_height,
                        )  # [4359]
                    elif self.resize_handle == "top_right":
                        new_unrotated_rect = QRectF(
                            new_unrotated_rect.left(),
                            new_unrotated_rect.bottom() - new_height,
                            new_width,
                            new_height,
                        )  # [4360]
                    elif self.resize_handle == "bottom_right":
                        new_unrotated_rect = QRectF(
                            new_unrotated_rect.left(),
                            new_unrotated_rect.top(),
                            new_width,
                            new_height,
                        )  # [4361]
                    elif self.resize_handle == "bottom_left":
                        new_unrotated_rect = QRectF(
                            new_unrotated_rect.right() - new_width,
                            new_unrotated_rect.top(),
                            new_width,
                            new_height,
                        )  # [4362]
                final_new_geo = new_unrotated_rect.normalized()  # [4363]
                if shape_being_resized.rotation != 0 and can_rotate:  # [4364]
                    fwd_transform = (
                        QTransform()
                        .translate(center.x(), center.y())
                        .rotate(shape_being_resized.rotation)
                        .translate(-center.x(), -center.y())
                    )  # [4365]
                    final_new_geo = fwd_transform.mapRect(final_new_geo)  # [4366]
                shape_being_resized.geometry = final_new_geo  # [4367]
            elif isinstance(unrotated_original_geo, list) and (
                "vertex_" in self.resize_handle
                or self.active_angle_shape_for_point_drag
            ):  # [4368]
                try:  # [4369]
                    if shape_being_resized.type == "angle_marker":  # [4370]
                        vertex_map = {
                            "vertex_A": 0,
                            "vertex_O": 1,
                            "vertex_B": 2,
                        }  # [4371]
                        vertex_idx = vertex_map.get(self.resize_handle, -1)  # [4372]
                    elif shape_being_resized.type == "spline":  # [4373]
                        vertex_idx = int(self.resize_handle.split("_")[1])  # [4374]
                    else:  # [4375]
                        vertex_idx = int(self.resize_handle.split("_")[1])  # [4376]
                    if 0 <= vertex_idx < len(shape_being_resized.geometry):  # [4377]
                        current_points = shape_being_resized.geometry  # [4378]
                        if isinstance(current_points, list):  # [4379]
                            fwd_transform = QTransform()  # [4380]
                            if (
                                shape_being_resized.rotation != 0 and can_rotate
                            ):  # [4381]
                                fwd_transform.translate(center.x(), center.y()).rotate(
                                    shape_being_resized.rotation
                                ).translate(-center.x(), -center.y())  # [4382]
                            rotated_new_pos = (
                                fwd_transform.map(unrotated_pos)
                                if can_rotate
                                else unrotated_pos
                            )  # [4383]
                            current_points[vertex_idx] = rotated_new_pos  # [4384]
                            if shape_being_resized.type == "angle_marker":  # [4385]
                                self.update_angle_marker_text(
                                    shape_being_resized.group_id
                                )  # [4386]
                        else:
                            print(
                                "Warning: geometry is not a list during vertex resize."
                            )  # [4387]
                except (ValueError, IndexError) as e:
                    print(
                        f"Error parsing resize handle vertex index: {self.resize_handle} - {e}"
                    )  # [4388]

            if self.show_angle_offset:
                self.recalculate_and_update_angle_offsets()  # [4389]
            else:
                self.update()  # [4390]
            return  # [4391]

        if self.dragging and self.selected_shapes and self.drag_start_pos:  # [4392]
            delta = pos - self.drag_start_pos  # [4393]
            moved = False  # [4394]
            for shape in self.selected_shapes:  # [4395]
                shape_index = -1  # [4396]
                try:
                    shape_index = self.shapes.index(shape)  # [4397]
                except ValueError:
                    continue  # [4398]

                if shape_index in self.drag_start_geometries:  # [4399]
                    original_shape_copy = self.drag_start_geometries[
                        shape_index
                    ]  # [4400]
                    original_geo = original_shape_copy.geometry  # [4401]

                    if (
                        isinstance(original_geo, QRectF) and original_geo.isValid()
                    ):  # [4402]
                        shape.geometry = original_geo.translated(delta)  # [4403]
                        moved = True  # [4404]
                    elif isinstance(original_geo, QPointF):  # [4405]
                        shape.geometry = original_geo + delta  # [4406]
                        moved = True  # [4407]
                    elif isinstance(original_geo, list):  # [4408]
                        valid_original_points = [
                            p for p in original_geo if isinstance(p, QPointF)
                        ]  # [4409]
                        if len(valid_original_points) == len(original_geo):  # [4410]
                            shape.geometry = [
                                p + delta for p in valid_original_points
                            ]  # [4411]
                            moved = True  # [4412]
                        else:
                            print(
                                "Warning: Original geometry list contained non-QPointF during drag."
                            )  # [4413]

                    if shape.type == "angle_marker" or (
                        shape.type == "text"
                        and shape.text_properties
                        and shape.text_properties.get("is_angle_display")
                    ):  # [4414]
                        if shape.group_id:  # [4415]
                            self.update_angle_marker_text(shape.group_id)  # [4416]

            if moved:  # [4417]
                if self.show_angle_offset:
                    self.recalculate_and_update_angle_offsets()  # [4418]
                else:
                    self.update()  # [4419]
            return  # [4420]

        if self.drag_start_pos:  # [4421]
            if self.is_lasso_selecting:
                self.update()  # [4422]
            elif self.current_drawing_shape:  # [4423]
                tool = self.current_drawing_shape.type  # [4424]
                start_pos = self.drag_start_pos  # [4425]
                if tool in [
                    "rect",
                    "ellipse",
                    "arc",
                    "trapeze",
                    "regular_polygon",
                ]:  # [4426]
                    new_rect = QRectF(start_pos, pos).normalized()  # [4427]
                    if shift_pressed and tool not in [
                        "arc",
                        "trapeze",
                        "regular_polygon",
                    ]:  # [4428]
                        size = max(new_rect.width(), new_rect.height())  # [4429]
                        dx = pos.x() - start_pos.x()
                        dy = pos.y() - start_pos.y()  # [4430]
                        new_top_left = QPointF(start_pos)  # [4431]
                        if dx < 0:
                            new_top_left.setX(start_pos.x() - size)  # [4432]
                        if dy < 0:
                            new_top_left.setY(start_pos.y() - size)  # [4433]
                        new_rect = QRectF(new_top_left, QSizeF(size, size))  # [4434]
                    if tool in ["rect", "ellipse", "arc"]:  # [4435]
                        self.current_drawing_shape.geometry = new_rect  # [4436]
                        if tool == "arc":
                            self.current_drawing_shape.spanAngle = (
                                self.current_arc_span_angle
                            )  # [4437]
                    elif tool == "trapeze":  # [4438]
                        center_preview = new_rect.center()
                        w_preview = new_rect.width()
                        h_preview = new_rect.height()  # [4439]
                        b1_prev = w_preview
                        b2_prev = w_preview * 0.5
                        half_b1 = b1_prev / 2.0
                        half_b2 = b2_prev / 2.0  # [4440]
                        p1 = center_preview + QPointF(-half_b1, h_preview / 2.0)
                        p2 = center_preview + QPointF(
                            half_b1, h_preview / 2.0
                        )  # [4441]
                        p3 = center_preview + QPointF(half_b2, -h_preview / 2.0)
                        p4 = center_preview + QPointF(
                            -half_b2, -h_preview / 2.0
                        )  # [4442]
                        self.current_drawing_shape.geometry = [p1, p2, p3, p4]  # [4443]
                    elif tool == "regular_polygon":  # [4444]
                        center_preview = start_pos
                        delta_preview = pos - center_preview  # [4445]
                        radius_preview = math.sqrt(
                            delta_preview.x() ** 2 + delta_preview.y() ** 2
                        )  # [4446]
                        sides_preview = self.current_drawing_shape.num_sides
                        points_preview = []  # [4447]
                        for i in range(sides_preview):  # [4448]
                            angle = (math.pi * 2 * i / sides_preview) - (
                                math.pi / 2
                            )  # [4449]
                            x = center_preview.x() + radius_preview * math.cos(angle)
                            y = center_preview.y() + radius_preview * math.sin(
                                angle
                            )  # [4450]
                            points_preview.append(QPointF(x, y))  # [4451]
                        self.current_drawing_shape.geometry = points_preview  # [4452]
                elif tool in ["line", "arrow"]:  # [4453]
                    end_pos = pos  # [4454]
                    if ctrl_pressed:  # [4455]
                        dx = pos.x() - start_pos.x()
                        dy = pos.y() - start_pos.y()  # [4456]
                        if abs(dx) > 1e-6 or abs(dy) > 1e-6:  # [4457]
                            angle_rad_draw = math.atan2(dy, dx)
                            snap_step_draw = math.radians(15.0)  # [4458]
                            snapped_rad_draw = (
                                round(angle_rad_draw / snap_step_draw) * snap_step_draw
                            )  # [4459]
                            length = math.sqrt(dx**2 + dy**2)  # [4460]
                            end_pos = start_pos + QPointF(
                                length * math.cos(snapped_rad_draw),
                                length * math.sin(snapped_rad_draw),
                            )  # [4461]
                            angle_rad_display = math.atan2(dx, -dy)
                            snap_step_display = 15.0  # [4462]
                            snapped_deg_display = (
                                round(
                                    math.degrees(angle_rad_display) / snap_step_display
                                )
                                * snap_step_display
                            )  # [4463]
                            self.current_snap_angle = (
                                snapped_deg_display % 360
                            )  # [4464]
                        else:
                            end_pos = start_pos
                            self.current_snap_angle = None  # [4465]
                    else:
                        self.current_snap_angle = None  # [4466]
                    self.current_drawing_shape.geometry = [start_pos, end_pos]  # [4467]
                elif tool == "triangle":  # [4468]
                    rect = QRectF(start_pos, pos).normalized()  # [4469]
                    p1 = rect.bottomLeft()
                    p2 = rect.bottomRight()
                    p3 = QPointF(rect.center().x(), rect.top())  # [4470]
                    self.current_drawing_shape.geometry = [p1, p2, p3]  # [4471]
                elif tool == "brush" and self.brush_points:  # [4472]
                    if (
                        QPointF.dotProduct(
                            pos - self.brush_points[-1], pos - self.brush_points[-1]
                        )
                        > 4
                    ):  # [4473]
                        self.brush_points.append(pos)  # [4474]
                        self.current_drawing_shape.geometry = self.brush_points[
                            :
                        ]  # [4475]
                if tool not in [
                    "text",
                    "polygon",
                    "line_point",
                    "MPoint",
                    "dimension",
                    "angle_marker",
                    "spline",
                ]:
                    self.update()  # [4476]
        elif (
            self.current_tool == "line_point"
            and self.polygon_points
            and not self.is_lasso_selecting
        ):  # [4477]
            if ctrl_pressed:  # [4478]
                start_pos_snap = self.polygon_points[-1]  # [4479]
                current_mouse_pos_snap = pos  # [4480]
                dx_snap = current_mouse_pos_snap.x() - start_pos_snap.x()  # [4481]
                dy_snap = current_mouse_pos_snap.y() - start_pos_snap.y()  # [4482]

                if abs(dx_snap) > 1e-6 or abs(dy_snap) > 1e-6:  # [4483]
                    angle_rad_draw = math.atan2(dy_snap, dx_snap)  # [4484]
                    snap_step_draw = math.radians(15.0)  # [4485]
                    snapped_rad_draw = (
                        round(angle_rad_draw / snap_step_draw) * snap_step_draw
                    )  # [4486]
                    length_snap = math.sqrt(dx_snap**2 + dy_snap**2)  # [4487]
                    self.snapped_line_point_preview_end = start_pos_snap + QPointF(
                        length_snap * math.cos(snapped_rad_draw),
                        length_snap * math.sin(snapped_rad_draw),
                    )  # [4488]

                    angle_rad_display = math.atan2(dx_snap, -dy_snap)  # [4489]
                    snap_step_display = 15.0  # [4490]
                    snapped_deg_display = (
                        round(math.degrees(angle_rad_display) / snap_step_display)
                        * snap_step_display
                    )  # [4491]
                    self.current_snap_angle = snapped_deg_display % 360  # [4492]
                else:  # [4493]
                    self.snapped_line_point_preview_end = start_pos_snap  # [4494]
                    self.current_snap_angle = None  # [4495]
            else:  # [4496]
                self.snapped_line_point_preview_end = None  # [4497]
                self.current_snap_angle = None  # [4498]
            self.update()  # [4499]
        elif (
            self.current_tool == "polygon"
            and self.polygon_points
            and not self.is_lasso_selecting
        ):  # [4500]
            self.update()  # [4501]
        elif self.current_tool == "spline" and self.spline_points:  # [4502]
            self.update()  # [4503]
        elif self.current_tool == "dimension" and len(self.dimension_points) > 0:
            self.update()  # [4504]
        elif self.current_tool == "angle_marker" and len(self.angle_points) > 0:
            self.update()  # [4505]

    def mouseReleaseEvent(self, event: QMouseEvent):  # [4506]
        """Handles mouse release events to finalize drawing, dragging, or resizing."""  # [4507]
        if not self.drawing_mode:
            return  # [4508]
        if self.input_mode:  # [4509]
            self.input_mode = None
            self.update()
            event.accept()
            return  # [4510]

        if self.current_snap_angle is not None:
            self.current_snap_angle = None
            self.update()  # [4511]
        if self.current_tool == "dimension":
            event.accept()
            return  # [4512]
        if self.current_tool == "angle_marker":  # [4513]
            if self.resizing and self.active_angle_shape_for_point_drag:  # [4514]
                print(
                    f"Finished dragging angle point: {self.active_angle_point_handle}"
                )  # [4515]
                if (
                    hasattr(self, "undo_indices_cache") and self.undo_indices_cache
                ):  # [4516]
                    self.save_state(
                        "resize",
                        shapes_involved=[self.active_angle_shape_for_point_drag],
                        previous_geometries=self.drag_start_geometries,
                        indices=self.undo_indices_cache,
                    )  # [4517]
                self.resizing = False
                self.active_angle_shape_for_point_drag = None
                self.active_angle_point_handle = None  # [4518]
                self.drag_start_pos = None
                self.drag_start_geometries = {}
                self.undo_indices_cache = []  # [4519]
                self.update()
                event.accept()
                return  # [4520]
            event.accept()
            return  # [4521]
        if self.current_tool == "spline":  # [4522]
            if self.resizing:  # [4523]
                print(
                    f"Finished resizing spline vertex: {self.resize_handle}"
                )  # [4524]
                if (
                    self.selected_shapes
                    and hasattr(self, "undo_indices_cache")
                    and self.undo_indices_cache
                ):  # [4525]
                    moved_significantly = False  # [4526]
                    previous_properties_for_undo = {}  # [4527]
                    involved_shapes_for_undo = []  # [4528]
                    for idx in self.undo_indices_cache:  # [4529]
                        if (
                            0 <= idx < len(self.shapes)
                            and idx in self.drag_start_geometries
                        ):  # [4530]
                            shape_resized = self.shapes[idx]  # [4531]
                            original_shape_copy = self.drag_start_geometries[
                                idx
                            ]  # [4532]
                            previous_properties_for_undo[idx] = deepcopy(
                                original_shape_copy
                            )  # [4533]
                            if (
                                shape_resized.geometry != original_shape_copy.geometry
                            ):  # [4534]
                                moved_significantly = True  # [4535]
                                involved_shapes_for_undo.append(shape_resized)  # [4536]
                    if moved_significantly:  # [4537]
                        self.save_state(
                            "resize",
                            shapes_involved=involved_shapes_for_undo,
                            previous_geometries=previous_properties_for_undo,
                            indices=self.undo_indices_cache,
                        )  # [4538]
                self.resizing = False
                self.resize_handle = None  # [4539]
                self.drag_start_pos = None
                self.drag_start_geometries = {}  # [4540]
                self.undo_indices_cache = []  # [4541]
                self.update()  # [4542]
            event.accept()  # [4543]
            return  # [4544]

        pos = event.position()  # [4545]
        if event.button() == Qt.MouseButton.LeftButton:  # [4546]
            if self.resizing:  # [4547]
                print(
                    f"Finished resizing shape, handle: {self.resize_handle}"
                )  # [4548]
                if self.selected_shapes:  # [4549]
                    if (
                        hasattr(self, "undo_indices_cache") and self.undo_indices_cache
                    ):  # [4550]
                        moved_significantly = False
                        previous_properties_for_undo = {}
                        involved_shapes_for_undo = []  # [4551]
                        for idx in self.undo_indices_cache:  # [4552]
                            if (
                                0 <= idx < len(self.shapes)
                                and idx in self.drag_start_geometries
                            ):  # [4553]
                                shape_resized = self.shapes[idx]
                                original_shape_copy = self.drag_start_geometries[
                                    idx
                                ]  # [4554]
                                previous_properties_for_undo[idx] = deepcopy(
                                    original_shape_copy
                                )  # [4555]
                                if (
                                    shape_resized.geometry
                                    != original_shape_copy.geometry
                                    or (
                                        shape_resized.type == "arc"
                                        and (
                                            shape_resized.startAngle
                                            != original_shape_copy.startAngle
                                            or shape_resized.spanAngle
                                            != original_shape_copy.spanAngle
                                        )
                                    )
                                    or (shape_resized.type == "angle_marker")
                                ):  # [4556]
                                    moved_significantly = True
                                    involved_shapes_for_undo.append(
                                        shape_resized
                                    )  # [4557]
                        if moved_significantly:  # [4558]
                            print("Resize resulted in change, saving state.")  # [4559]
                            self.save_state(
                                "resize",
                                shapes_involved=involved_shapes_for_undo,
                                previous_geometries=previous_properties_for_undo,
                                indices=self.undo_indices_cache,
                            )  # [4560]
                            if self.show_angle_offset:
                                self.recalculate_and_update_angle_offsets()  # [4561]
                            if any(
                                s.type == "angle_marker"
                                for s in involved_shapes_for_undo
                            ):  # [4562]
                                for shape_undo in involved_shapes_for_undo:  # [4563]
                                    if (
                                        shape_undo.type == "angle_marker"
                                        and shape_undo.group_id
                                    ):
                                        self.update_angle_marker_text(
                                            shape_undo.group_id
                                        )  # [4564]
                        else:
                            print(
                                "Resize resulted in negligible change, not saving undo."
                            )  # [4565]
                    else:
                        print(
                            "Warning: Could not determine shape or original geometry for resize undo."
                        )  # [4566]
                else:
                    print(
                        "Warning: No shape selected or index invalid at end of resize."
                    )  # [4567]
                self.resizing = False
                self.resize_handle = None
                self.drag_start_pos = None
                self.drag_start_geometries = {}
                self.undo_indices_cache = []  # [4568]
                self.update()
                event.accept()
                return  # [4569]

            if self.dragging:  # [4570]
                moved_significantly = False  # [4571]
                if self.selected_shapes and self.drag_start_pos:  # [4572]
                    delta = pos - self.drag_start_pos  # [4573]
                    if delta.manhattanLength() > 2 and hasattr(
                        self, "undo_indices_cache"
                    ):  # [4574]
                        moved_significantly = True
                        previous_properties_for_undo = {}
                        moved_shapes_for_undo = []
                        valid_indices = []  # [4575]
                        for idx in self.undo_indices_cache:  # [4576]
                            if (
                                0 <= idx < len(self.shapes)
                                and idx in self.drag_start_geometries
                            ):  # [4577]
                                current_shape = self.shapes[idx]
                                original_shape_copy = self.drag_start_geometries[
                                    idx
                                ]  # [4578]
                                previous_properties_for_undo[idx] = deepcopy(
                                    original_shape_copy
                                )
                                moved_shapes_for_undo.append(current_shape)
                                valid_indices.append(idx)  # [4579]
                        if moved_shapes_for_undo:  # [4580]
                            self.save_state(
                                "move",
                                shapes_involved=moved_shapes_for_undo,
                                previous_geometries=previous_properties_for_undo,
                                indices=valid_indices,
                            )  # [4581]
                            if self.show_angle_offset:
                                self.recalculate_and_update_angle_offsets()  # [4582]
                            if any(
                                s.type == "angle_marker"
                                or (
                                    s.type == "text"
                                    and s.text_properties
                                    and s.text_properties.get("is_angle_display")
                                )
                                for s in moved_shapes_for_undo
                            ):  # [4583]
                                for shape_undo in moved_shapes_for_undo:  # [4584]
                                    if shape_undo.group_id:
                                        self.update_angle_marker_text(
                                            shape_undo.group_id
                                        )  # [4585]
                        else:
                            print(
                                "Drag ended, but couldn't map indices/geometries for undo."
                            )  # [4586]
                self.dragging = False
                self.drag_start_pos = None
                self.drag_start_geometries = {}
                self.undo_indices_cache = []  # [4587]
                self.update()
                event.accept()
                return  # [4588]

            if self.current_drawing_shape and self.current_tool not in [
                "text",
                "polygon",
                "line_point",
                "MPoint",
                "spline",
            ]:  # [4589]
                tool = self.current_drawing_shape.type
                valid_final_shape = True
                geo = self.current_drawing_shape.geometry
                min_size = 3  # [4590]
                if tool in ["rect", "ellipse", "arc"]:  # [4591]
                    if (
                        not isinstance(geo, QRectF)
                        or not geo.isValid()
                        or geo.width() < min_size
                        or geo.height() < min_size
                    ):
                        valid_final_shape = False  # [4592]
                elif tool in ["line", "arrow", "triangle"]:  # [4593]
                    if isinstance(geo, list) and len(geo) >= 2:  # [4594]
                        p_start = geo[0]
                        p_end = geo[-1]  # [4595]
                        if isinstance(p_start, QPointF) and isinstance(
                            p_end, QPointF
                        ):  # [4596]
                            if (p_end - p_start).manhattanLength() < min_size:
                                valid_final_shape = False  # [4597]
                        else:
                            valid_final_shape = False  # [4598]
                    else:
                        valid_final_shape = False  # [4599]
                elif tool == "brush":  # [4600]
                    if not isinstance(geo, list) or len(geo) < 2:
                        valid_final_shape = False  # [4601]
                elif tool == "trapeze":  # [4602]
                    if not isinstance(geo, list) or len(geo) < 4:
                        valid_final_shape = False  # [4603]
                elif tool == "regular_polygon":  # [4604]
                    if not isinstance(geo, list) or len(geo) < 3:
                        valid_final_shape = False  # [4605]
                if valid_final_shape:  # [4606]
                    final_shape = self.current_drawing_shape  # [4607]
                    if (
                        final_shape.type == "arrow"
                        and self.control_panel
                        and "arrow" in self.control_panel.fixed_size_widgets
                        and "DoubleHeaded"
                        in self.control_panel.fixed_size_widgets["arrow"]
                    ):  # [4608]
                        final_shape.double_headed = (
                            self.control_panel.fixed_size_widgets["arrow"][
                                "DoubleHeaded"
                            ].isChecked()
                        )  # [4609]
                    self.shapes.append(final_shape)  # [4610]
                    self.save_state("draw", indices=[len(self.shapes) - 1])  # [4611]
                    if self.temp_mode:
                        self.schedule_shape_removal(final_shape)  # [4612]
                    self._configure_mode()  # [4613]
                    is_fixed_size = (
                        self.get_fixed_size_params(tool) is not None
                    )  # [4614]
                    if (
                        not is_fixed_size
                        and not self.board_mode
                        and not self.edit_mode
                        and not self.temp_mode
                    ):
                        self.set_drawing_mode(False)  # [4615]
                else:
                    print(f"Discarding tiny/invalid {tool} shape.")  # [4616]
                self.current_drawing_shape = None
                self.brush_points = []
                self.drag_start_pos = None
                self.update()
                event.accept()
                return  # [4617]

            if self.current_tool == "text" and self.drag_start_pos:  # [4618]
                initial_props_for_dialog = None
                pen_color = None  # [4619]
                if self.edit_mode:
                    initial_props_for_dialog = deepcopy(
                        self.board_default_text_properties
                    )
                    pen_color = self.current_pen_color_edit  # [4620]
                elif self.board_mode:
                    initial_props_for_dialog = deepcopy(
                        self.board_default_text_properties
                    )
                    pen_color = self.current_pen_color_board_only  # [4621]
                elif self.temp_mode:
                    initial_props_for_dialog = deepcopy(self.default_text_properties)
                    pen_color = self.current_pen_color_temp  # [4622]
                else:
                    initial_props_for_dialog = deepcopy(self.default_text_properties)
                    pen_color = self.current_pen_color  # [4623]
                initial_props_for_dialog["text"] = ""
                initial_props_for_dialog["color"] = pen_color.name(
                    QColor.NameFormat.HexRgb
                )
                initial_props_for_dialog.setdefault("curve_angle", 0)  # [4624]
                initial_rect = QRectF(self.drag_start_pos, pos).normalized()  # [4625]
                if initial_rect.width() < 10 or initial_rect.height() < 10:
                    initial_rect = None  # [4626]
                self.show_text_dialog(
                    self.drag_start_pos,
                    shape_to_edit=None,
                    initial_props=initial_props_for_dialog,
                    initial_rect=initial_rect,
                )  # [4627]
                self.drag_start_pos = None
                self.current_drawing_shape = None
                self.update()
                event.accept()
                return  # [4628]

            if (
                self.current_tool in ["polygon", "line_point"]
                and not self.is_lasso_selecting
            ):
                self.update()
                event.accept()
                return  # [4629]
            if self.is_lasso_selecting:
                self.update()
                event.accept()
                return  # [4630]
        elif (
            event.button() == Qt.MouseButton.RightButton and self.drawing_mode
        ):  # [4631]
            if self.input_mode:
                self.input_mode = None
                self.update()
                event.accept()
                return  # [4632]
            pass  # [4633]

    def mouseDoubleClickEvent(self, event: QMouseEvent):  # [4634]
        """Handles double-click events to finalize polygons or edit text."""  # [4635]
        if not self.drawing_mode:
            return  # [4636]
        if self.input_mode:
            self.input_mode = None
            self.update()
            event.accept()
            return  # [4637]
        if self.current_tool == "dimension":
            event.accept()
            return  # [4638]
        if self.current_tool == "angle_marker":
            event.accept()
            return  # [4639]
        if self.current_tool == "spline":  # [4640]
            self.finish_drawing_spline()  # [4641]
            event.accept()  # [4642]
            return  # [4643]

        pos = event.position()  # [4644]
        if event.button() == Qt.MouseButton.LeftButton:  # [4645]
            if self.is_lasso_selecting and self.polygon_points:  # [4646]
                print("Finishing Lasso Select with double-click.")  # [4647]
                invert_lasso = False  # [4648]
                if self.control_panel and hasattr(
                    self.control_panel, "line_point_invert_check"
                ):  # [4649]
                    invert_lasso = (
                        self.control_panel.line_point_invert_check.isChecked()
                    )  # [4650]
                self.select_shapes_in_lasso(invert_lasso)  # [4651]
                self.is_lasso_selecting = False
                self.polygon_points = []
                self.update()
                event.accept()
                return  # [4652]

            if (
                not self.is_lasso_selecting
                and self.current_tool in ["polygon", "line_point"]
                and self.polygon_points
            ):  # [4653]
                self.finish_drawing_poly_line()
                event.accept()
                return  # [4654]

            top_shape = None
            top_shape_idx = -1  # [4655]
            for i, shape_iter in enumerate(reversed(self.shapes)):  # [4656]
                if (
                    shape_iter
                    and shape_iter.geometry
                    and shape_iter.visible
                    and shape_iter.contains(pos)
                ):  # [4657]
                    top_shape = shape_iter
                    top_shape_idx = len(self.shapes) - 1 - i
                    break  # [4658]
            if top_shape:  # [4659]
                require_ctrl = not (
                    (top_shape.is_dimension_part and top_shape.dimension_type == "text")
                    or (
                        top_shape.type == "text"
                        and top_shape.text_properties
                        and top_shape.text_properties.get("is_angle_display", False)
                    )
                )  # [4660]
                if (
                    require_ctrl
                    and not event.modifiers() & Qt.KeyboardModifier.ControlModifier
                ):
                    print("Ignoring double-click on shape without Ctrl.")
                    event.accept()
                    return  # [4661]
                if top_shape.type == "text":  # [4662]
                    current_props_copy = (
                        deepcopy(top_shape.text_properties)
                        if top_shape.text_properties
                        else {}
                    )  # [4663]
                    if not current_props_copy:  # [4664]
                        if (
                            top_shape.is_dimension_part
                            and top_shape.dimension_type == "text"
                        ):
                            current_props_copy = deepcopy(
                                self.dimension_default_text_properties
                            )  # [4665]
                        elif (
                            top_shape.text_properties
                            and top_shape.text_properties.get("is_angle_display", False)
                        ):  # [4666]
                            current_props_copy = {  # [4667]
                                "font": "Arial",
                                "size": self.current_angle_tool_text_size,
                                "bold": False,
                                "italic": False,
                                "underline": False,
                                "strikeout": False,
                                "color": self.current_angle_tool_line_color.name(),
                                "background_color": None,
                                "alignment": "center",
                                "curve_angle": 0,
                                "is_angle_display": True,
                                "text": top_shape.text_properties.get(
                                    "text", ""
                                ),  # [4668]
                            }  # [4669]
                        elif self.edit_mode or self.board_mode:
                            current_props_copy = deepcopy(
                                self.board_default_text_properties
                            )  # [4670]
                        elif self.temp_mode:
                            current_props_copy = deepcopy(
                                self.default_text_properties
                            )  # [4671]
                        else:
                            current_props_copy = deepcopy(
                                self.default_text_properties
                            )  # [4672]
                    current_props_copy.setdefault("curve_angle", 0)
                    current_props_copy.setdefault("is_angle_display", False)  # [4673]
                    self.show_text_dialog(
                        pos,
                        shape_to_edit=top_shape,
                        initial_props=current_props_copy,
                        is_angle_text_edit=(
                            top_shape.text_properties
                            and top_shape.text_properties.get("is_angle_display", False)
                        ),
                    )  # [4674]
                    event.accept()
                    return  # [4675]
                elif require_ctrl:  # [4676]
                    print(
                        f"Deleting shape {top_shape_idx} via Ctrl+double-click"
                    )  # [4677]
                    self.save_state(
                        "delete",
                        shapes_involved=[deepcopy(top_shape)],
                        indices=[top_shape_idx],
                    )  # [4678]
                    self.shapes.pop(top_shape_idx)  # [4679]
                    if top_shape in self.selected_shapes:
                        self.selected_shapes.remove(top_shape)  # [4680]
                    if self.show_angle_offset:
                        self.recalculate_and_update_angle_offsets()  # [4681]
                    self.update()
                    self._configure_mode()
                    event.accept()
                    return  # [4682]
            self.update()
            event.accept()  # [4683]

    def _show_color_picker_for_selection(self, key_name):  # [4684]
        """Helper function to display a color picker for selected shapes."""  # [4685]
        if not self.selected_shapes:
            return True  # [4686]
        print(
            f"Numpad '{key_name}' detected. Opening color picker for {len(self.selected_shapes)} selected shapes."
        )  # [4687]
        initial_color = self.selected_shapes[0].color
        options = QColorDialog.ColorDialogOption.DontUseNativeDialog
        dialog_title = "Choose Color for Selection"
        allow_alpha = False  # [4688]
        if self.edit_mode:
            dialog_title = "Choose Edit Pen Color for Selection"
            allow_alpha = False  # [4689]
        elif self.board_mode:
            dialog_title = "Choose Board Pen Color for Selection"
            allow_alpha = False  # [4690]
        elif self.temp_mode:
            dialog_title = "Choose Temp Color for Selection"
            allow_alpha = True  # [4691]
        else:
            dialog_title = "Choose Draw Color for Selection"
            allow_alpha = True  # [4692]
        if allow_alpha:
            options |= QColorDialog.ColorDialogOption.ShowAlphaChannel  # [4693]
        print(
            "Note: Standard color dialog does not support gradient selection."
        )  # [4694]
        color = QColorDialog.getColor(
            initial_color, self, dialog_title, options
        )  # [4695]
        if color.isValid():  # [4696]
            prev_props = {}
            current_indices = []
            changed_shapes = []  # [4697]
            for shape in self.selected_shapes:  # [4698]
                try:  # [4699]
                    shape_idx = self.shapes.index(shape)
                    current_indices.append(shape_idx)
                    prev_props[shape_idx] = deepcopy(shape)  # [4700]
                    new_shape_color = QColor(color)  # [4701]
                    if not allow_alpha:
                        new_shape_color.setAlpha(shape.color.alpha())  # [4702]
                    shape.color = new_shape_color
                    shape.gradient_properties = None
                    shape.hatch_properties = None
                    changed_shapes.append(shape)  # [4703]
                except ValueError:
                    continue  # [4704]
            if changed_shapes:
                self.save_state(
                    "change_color",
                    shapes_involved=changed_shapes,
                    previous_geometries=prev_props,
                    indices=current_indices,
                )
                self.update()  # [4705]
        else:
            print("Color dialog cancelled or color invalid.")  # [4706]
        return True  # [4707]

    def _delete_selected_shapes_action(self):  # [4708]
        """Handles the deletion of currently selected shapes."""  # [4709]
        if not self.selected_shapes:
            print("Delete action called, but no shapes selected.")
            return  # [4710]
        print(
            f"Attempting to delete {len(self.selected_shapes)} selected shape(s)."
        )  # [4711]
        shapes_to_delete_from_list = []
        indices_to_delete_from_list = []
        copies_for_undo = []  # [4712]
        for s_sel in self.selected_shapes:  # [4713]
            try:  # [4714]
                idx = self.shapes.index(s_sel)
                shapes_to_delete_from_list.append(s_sel)
                indices_to_delete_from_list.append(idx)
                copies_for_undo.append(deepcopy(s_sel))  # [4715]
            except ValueError:
                print(
                    f"Warning: Selected shape not found in main list during delete: {s_sel}"
                )
                continue  # [4716]
        if not shapes_to_delete_from_list:
            print("No shapes to delete.")
            return  # [4717]
        try:  # [4718]
            indexed_copies_for_undo = sorted(
                zip(indices_to_delete_from_list, copies_for_undo), key=lambda x: x[0]
            )  # [4719]
            sorted_indices_for_undo = [item[0] for item in indexed_copies_for_undo]
            sorted_copies_for_undo = [
                item[1] for item in indexed_copies_for_undo
            ]  # [4720]
            is_any_grouped = any(
                s.group_id for s in shapes_to_delete_from_list
            )  # [4721]
            undo_action = (
                "delete_group" if is_any_grouped else "delete_selected"
            )  # [4722]
            self.save_state(
                undo_action,
                shapes_involved=sorted_copies_for_undo,
                indices=sorted_indices_for_undo,
            )  # [4723]
            for index in sorted(indices_to_delete_from_list, reverse=True):  # [4724]
                if 0 <= index < len(self.shapes):
                    self.shapes.pop(index)  # [4725]
            selection_was_cleared = bool(self.selected_shapes)
            self.selected_shapes = []  # [4726]
            self.active_angle_shape_for_point_drag = None
            self.active_angle_point_handle = None  # [4727]
            if selection_was_cleared and self.show_angle_offset:
                self.recalculate_and_update_angle_offsets()  # [4728]
            else:
                self.update()  # [4729]
            self._configure_mode()
            print(
                f"Successfully deleted {len(shapes_to_delete_from_list)} shape(s)."
            )  # [4730]
        except Exception as e:
            print(f"Error during shape deletion: {e}")
            traceback.print_exc()  # [4731]

    def keyPressEvent(self, event: QKeyEvent):  # [4732]
        """Handles key press events for shortcuts and actions."""  # [4733]

        key = event.key()  # [4734]
        modifiers = event.modifiers()  # [4735]
        text = event.text()  # [4736]

        is_anim_active = False  # [4737]
        if self.control_panel and hasattr(
            self.control_panel, "_animation_running"
        ):  # [4738]
            is_anim_active = self.control_panel._animation_running  # [4739]

        if is_anim_active:  # [4740]
            print(f"[Overlay KeyPress] Animation ACTIVE. Key: {key}")  # [4741]
            if key == Qt.Key.Key_Escape:  # [4742]
                print(
                    "[Overlay KeyPress] Esc pressed during animation -> Stopping."
                )  # [4743]
                if self.control_panel:
                    self.control_panel.stop_animation_playback(
                        triggered_by_escape=True
                    )  # [4744]
                event.accept()
                return  # [4745]
            elif key == Qt.Key.Key_Space:  # [4746]
                print(
                    "[Overlay KeyPress] Space pressed during animation -> Pausing/Resuming."
                )  # [4747]
                if self.control_panel:
                    self.control_panel.pause_resume_animation()  # [4748]
                event.accept()
                return  # [4749]
            else:
                print(f"[Overlay KeyPress] Consuming key {key} during animation.")
                event.accept()
                return  # [4750]

        if (
            key == Qt.Key.Key_Home and modifiers & Qt.KeyboardModifier.ControlModifier
        ):  # [4751]
            if self.control_panel:  # [4752]
                if (
                    self.control_panel.isHidden() or self.control_panel.isMinimized()
                ):  # [4753]
                    self.control_panel.showNormal()
                    self.control_panel.raise_()
                    self.control_panel.activateWindow()
                    self.control_panel.setVisible(True)
                    print("Ctrl+Home: Shown/Restored Control Panel")  # [4754]
                else:
                    self.control_panel.hide()
                    print("Ctrl+Home: Hidden Control Panel")  # [4755]
            event.accept()
            return  # [4756]

        if not self.drawing_mode:
            super().keyPressEvent(event)
            return  # [4757]

        ctrl_pressed = modifiers & Qt.KeyboardModifier.ControlModifier
        alt_pressed = modifiers & Qt.KeyboardModifier.AltModifier
        shift_pressed = modifiers & Qt.KeyboardModifier.ShiftModifier  # [4758]
        keypad_modifier = modifiers & Qt.KeyboardModifier.KeypadModifier  # [4759]
        ralt_pressed = (key == Qt.Key.Key_AltGr) or (
            ctrl_pressed and alt_pressed and key == Qt.Key.Key_Control
        )  # [4760]
        self.pressed_keys.add(key)  # [4761]

        if self.input_mode:  # [4762]
            if key in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
                self.input_mode = None
                self.update()
                event.accept()
                return  # [4763]
            elif key == Qt.Key.Key_Escape:
                print("Cancelling input mode.")
                self.input_mode = None
                self.update()
                event.accept()
                return  # [4764]
            elif key not in (Qt.Key.Key_PageUp, Qt.Key.Key_PageDown):
                print(f"Input mode cancelled by key {key}.")
                self.input_mode = None
                self.update()  # [4765]

        is_page_key = key in (Qt.Key.Key_PageUp, Qt.Key.Key_PageDown)  # [4766]
        if is_page_key:  # [4767]
            if not self.control_panel:
                event.ignore()
                return  # [4768]
            spin_box_to_change = None
            combo_box_to_change = None
            delta = 0  # [4769]
            if key == Qt.Key.Key_PageUp:
                delta = 1  # [4770]
            elif key == Qt.Key.Key_PageDown:
                delta = -1  # [4771]
            if shift_pressed and not ctrl_pressed and not alt_pressed:
                spin_box_to_change = self.control_panel.alpha_spin
                print(f"Changing transparency via Shift+PgKey ({delta})")  # [4772]
            elif alt_pressed and not ctrl_pressed and not shift_pressed:
                spin_box_to_change = self.control_panel.brush_size_spin
                print(f"Changing brush size via Alt+PgKey ({delta})")  # [4773]
            elif ctrl_pressed and not shift_pressed and not alt_pressed:
                spin_box_to_change = self.control_panel.arrow_size_spin
                print(f"Changing arrow head via Ctrl+PgKey ({delta})")  # [4774]
            elif ctrl_pressed and shift_pressed and not alt_pressed:
                combo_box_to_change = self.control_panel.style_combo
                print(f"Changing line style via Ctrl+Shift+PgKey ({delta})")  # [4775]
            if spin_box_to_change:  # [4776]
                current_value = spin_box_to_change.value()
                new_value = current_value + delta  # [4777]
                min_val = spin_box_to_change.minimum()
                max_val = spin_box_to_change.maximum()
                new_value = max(min_val, min(max_val, new_value))  # [4778]
                if new_value != current_value:
                    spin_box_to_change.setValue(new_value)  # [4779]
                event.accept()
                return  # [4780]
            elif combo_box_to_change:  # [4781]
                current_index = combo_box_to_change.currentIndex()
                count = combo_box_to_change.count()
                new_index = (current_index + delta) % count  # [4782]
                if new_index < 0:
                    new_index += count  # [4783]
                if new_index != current_index:
                    combo_box_to_change.setCurrentIndex(new_index)
                    self.control_panel.on_style_combo_activated(new_index)  # [4784]
                event.accept()
                return  # [4785]

        if (
            key == Qt.Key.Key_J
            and alt_pressed
            and not ctrl_pressed
            and not shift_pressed
        ):  # [4786]
            print(
                f"Alt+J pressed. Toggling angle offset display (currently {'ON' if self.show_angle_offset else 'OFF'})."
            )  # [4787]
            if self.show_angle_offset:
                self.show_angle_offset = False
                self.angle_offsets.clear()
                self.update()  # [4788]
            else:
                self.show_angle_offset = True
                self.recalculate_and_update_angle_offsets()  # [4789]
            event.accept()
            return  # [4790]

        if key == Qt.Key.Key_H:  # [4791]
            if shift_pressed and not ctrl_pressed and not alt_pressed:
                self.toggle_mpoint_label_visibility()
                event.accept()
                return  # [4792]
            elif ctrl_pressed and not shift_pressed and not alt_pressed:
                self.toggle_mpoint_marker_visibility()
                event.accept()
                return  # [4793]
            elif alt_pressed and not shift_pressed and not ctrl_pressed:
                self.toggle_mpoint_group_visibility()
                event.accept()
                return  # [4794]
            elif not ctrl_pressed and not alt_pressed and not shift_pressed:
                self.toggle_shapes_visibility()
                event.accept()
                return  # [4795]
        elif (
            key == Qt.Key.Key_C
            and not ctrl_pressed
            and not alt_pressed
            and not shift_pressed
        ):  # [4796]
            if self.control_panel and hasattr(
                self.control_panel, "center_check"
            ):  # [4797]
                self.control_panel.center_check.toggle()  # [4798]
                print(
                    f"Center point display toggled to: {self.show_center_point}"
                )  # [4799]
                event.accept()  # [4800]
                return  # [4801]
        elif (
            key == Qt.Key.Key_V
            and not ctrl_pressed
            and not alt_pressed
            and not shift_pressed
        ):  # [4802]
            if self.control_panel and hasattr(
                self.control_panel, "divide_check"
            ):  # [4803]
                self.control_panel.divide_check.toggle()  # [4804]
                print(f"Divide shapes toggled to: {self.divide_enabled}")  # [4805]
                event.accept()  # [4806]
                return  # [4807]
        elif not ctrl_pressed and not alt_pressed and self.control_panel:  # [4808]
            target_checkbox_hatch = None  # [4809]
            if text == "/":  # [4810]
                target_checkbox_hatch = (
                    self.control_panel.hatch_forward_slash_check
                )  # [4811]
                print("Shortcut '/' for Forward Slash Hatch toggled.")  # [4812]
            elif text == "\\":  # [4813]
                target_checkbox_hatch = (
                    self.control_panel.hatch_backward_slash_check
                )  # [4814]
                print("Shortcut '\\' for Backward Slash Hatch toggled.")  # [4815]
            elif text == "|":  # [4816]
                target_checkbox_hatch = (
                    self.control_panel.hatch_vertical_check
                )  # [4817]
                print("Shortcut '|' for Vertical Hatch toggled.")  # [4818]
            elif text == "_":  # [4819]
                target_checkbox_hatch = (
                    self.control_panel.hatch_horizontal_check
                )  # [4820]
                print("Shortcut '_' for Horizontal Hatch toggled.")  # [4821]

            if target_checkbox_hatch:  # [4822]
                target_checkbox_hatch.toggle()  # [4823]
                event.accept()  # [4824]
                return  # [4825]
        elif key == Qt.Key.Key_G and ctrl_pressed:  # [4826]
            if shift_pressed:  # [4827]
                self.ungroup_selected_shapes()  # [4828]
            else:  # [4829]
                self.group_selected_shapes()  # [4830]
            event.accept()  # [4831]
            return  # [4832]

        if key == Qt.Key.Key_Escape:  # [4833]
            print("Escape pressed (overlay focus, normal handling)")  # [4834]
            if self.selected_shapes:  # [4835]
                print("Clearing selection via Escape.")
                self.selected_shapes = []
                self.active_angle_shape_for_point_drag = None
                self.active_angle_point_handle = None  # [4836]
                if self.show_angle_offset:
                    self.recalculate_and_update_angle_offsets()  # [4837]
                else:
                    self.update()  # [4838]
                event.accept()
                return  # [4839]
            if self.edit_mode and self._entered_edit_via_loadimg:  # [4840]
                print("Escape pressed in loadimg EDIT mode.")  # [4841]
                msg_box = QMessageBox(self)
                msg_box.setWindowTitle("Exit Image Mode")
                msg_box.setText(
                    "What would you like to do with the background image?"
                )  # [4842]
                clear_button = msg_box.addButton(
                    "Clear Image & Shapes", QMessageBox.ButtonRole.DestructiveRole
                )
                save_button = msg_box.addButton(
                    "Save View as JPG", QMessageBox.ButtonRole.AcceptRole
                )  # [4843]
                cancel_button = msg_box.addButton(QMessageBox.StandardButton.Cancel)
                msg_box.setDefaultButton(cancel_button)
                msg_box.exec()  # [4844]
                clicked_button = msg_box.clickedButton()  # [4845]
                if clicked_button == cancel_button:
                    print("Image mode exit cancelled.")
                    event.accept()
                    return  # [4846]
                if clicked_button == clear_button:  # [4847]
                    print("Clearing background image and all shapes.")
                    self.background_pixmap = None
                    self.clear_scene(save_undo=False)  # [4848]
                    self.exit_board_mode(
                        ask_save=False, configure=True, skip_shape_clear_question=True
                    )
                    event.accept()
                    return  # [4849]
                if clicked_button == save_button:  # [4850]
                    print("Saving current view as JPG.")  # [4851]
                    default_save_path = self.settings.value(
                        "paths/lastScreenshotSaveDir",
                        QStandardPaths.writableLocation(
                            QStandardPaths.StandardLocation.PicturesLocation
                        ),
                    )  # [4852]
                    filename, _ = QFileDialog.getSaveFileName(
                        self,
                        "Save View As JPG",
                        default_save_path,
                        "JPG Image (*.jpg *.jpeg)",
                    )  # [4853]
                    if filename:  # [4854]
                        if not filename.lower().endswith((".jpg", ".jpeg")):
                            filename += ".jpg"  # [4855]
                        self.settings.setValue(
                            "paths/lastScreenshotSaveDir", os.path.dirname(filename)
                        )  # [4856]
                        QTimer.singleShot(
                            100,
                            lambda: self._perform_delayed_screenshot_and_exit(filename),
                        )  # [4857]
                    else:
                        print("Save cancelled by user.")
                        event.accept()  # [4858]
                    return  # [4859]
            current_time = time.time()
            double_press_interval = 0.4  # [4860]
            if (
                (self.board_mode or self.edit_mode)
                and not self._entered_edit_via_loadimg
                and (current_time - self.last_esc_press_time < double_press_interval)
            ):  # [4861]
                print(
                    "Double Escape detected: Attempting to exit BOARD/EDIT mode."
                )  # [4862]
                skip_clear_ask = self._entered_edit_via_loadimg
                self.exit_board_mode(
                    ask_save=False, skip_shape_clear_question=skip_clear_ask
                )  # [4863]
                self.last_esc_press_time = 0
                event.accept()
                return  # [4864]
            self.last_esc_press_time = current_time  # [4865]
            if self.temp_mode:
                print("Exiting TEMP mode via Escape.")
                self.exit_temp_mode()
                event.accept()
                return  # [4866]
            if self.current_tool == "dimension" and self.dimension_points:  # [4867]
                print("Cancelling dimensioning.")
                self.dimension_points.clear()
                self.dimension_preview_shapes.clear()
                self.update()
                event.accept()
                return  # [4868]
            elif self.current_tool == "angle_marker" and self.angle_points:  # [4869]
                print("Cancelling angle drawing.")
                self.angle_points.clear()
                self.current_drawing_shape = None
                self.update()
                event.accept()
                return  # [4870]
            elif self.current_tool == "spline" and self.spline_points:  # [4871]
                print("Cancelling spline drawing.")
                self.spline_points.clear()
                self.current_drawing_shape = None
                self.update()
                event.accept()
                return  # [4872]
            elif self.is_lasso_selecting:
                print("Cancelling Lasso Select.")
                self.is_lasso_selecting = False
                self.polygon_points = []
                self.update()
                event.accept()
                return  # [4873]
            elif (
                self.current_tool in ["polygon", "line_point"] and self.polygon_points
            ):  # [4874]
                print("Cancelling polygon/line_point drawing.")
                self.polygon_points = []
                self.current_drawing_shape = None
                self.update()
                event.accept()
                return  # [4875]
            elif self.current_drawing_shape:
                print("Cancelling current shape drawing preview.")
                self.current_drawing_shape = None
                self.brush_points = []
                self.update()
                event.accept()
                return  # [4876]
            elif self.resizing or self.dragging:  # [4877]
                print("Cancelling resize/drag.")  # [4878]
                if self.drag_start_geometries:  # [4879]
                    for (
                        index,
                        original_shape_copy,
                    ) in self.drag_start_geometries.items():  # [4880]
                        if 0 <= index < len(self.shapes):
                            self.shapes[index] = original_shape_copy  # [4881]
                self.resizing = False
                self.dragging = False
                self.resize_handle = None
                self.drag_start_pos = None
                self.drag_start_geometries = {}
                self.undo_indices_cache = []  # [4882]
                self.active_angle_shape_for_point_drag = None
                self.active_angle_point_handle = None
                self.update()
                event.accept()
                return  # [4883]
            elif self.show_angle_offset:
                print("Escape pressed, hiding angle offset.")
                self.show_angle_offset = False
                self.angle_offsets.clear()
                self.update()
                event.accept()
                return  # [4884]
            elif self.board_mode or self.edit_mode:  # [4885]
                if not self._entered_edit_via_loadimg:
                    print(
                        "Single Esc in Board/Edit mode - press again quickly to exit."
                    )  # [4886]
                event.accept()
                return  # [4887]
            else:
                print("Exiting NORMAL drawing mode via Escape.")
                self.set_drawing_mode(False)
                event.accept()
                return  # [4888]

        if keypad_modifier and key in (
            Qt.Key.Key_Delete,
            Qt.Key.Key_Period,
            Qt.Key.Key_Asterisk,
        ):  # [4889]
            if self._show_color_picker_for_selection(
                "." if key != Qt.Key.Key_Asterisk else "*"
            ):
                event.accept()
                return  # [4890]
        if keypad_modifier and key == Qt.Key.Key_Slash:  # [4891]
            if self.selected_shapes:  # [4892]
                changed_shapes = []
                prev_props = {}
                current_indices = []  # [4893]
                for shape in self.selected_shapes:  # [4894]
                    is_fillable = (
                        shape.type
                        in [
                            "rect",
                            "ellipse",
                            "triangle",
                            "polygon",
                            "trapeze",
                            "regular_polygon",
                            "arc",
                        ]
                        or shape.is_mpoint_marker
                    )  # [4895]
                    if is_fillable:  # [4896]
                        try:
                            shape_idx = self.shapes.index(shape)  # [4897]
                        except ValueError:
                            continue  # [4898]
                        current_indices.append(shape_idx)
                        prev_props[shape_idx] = deepcopy(shape)
                        shape.filled = not shape.filled  # [4899]
                        if shape.filled and shape.hatch_properties:
                            shape.hatch_properties = None  # [4900]
                        changed_shapes.append(shape)  # [4901]
                if changed_shapes:
                    self.save_state(
                        "toggle_fill",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )
                    self.update()  # [4902]
                else:
                    print("No fillable shapes selected.")  # [4903]
            else:
                print("Numpad '/' pressed, but no shapes selected.")  # [4904]
            event.accept()
            return  # [4905]

        if (
            key == Qt.Key.Key_A
            and ctrl_pressed
            and not shift_pressed
            and not alt_pressed
        ):
            self.select_all_shapes()
            event.accept()
            return  # [4906]
        if ctrl_pressed and not shift_pressed and not alt_pressed:  # [4907]
            if key == Qt.Key.Key_C:
                self.copy_shapes()
                event.accept()
                return  # [4908]
            elif key == Qt.Key.Key_V:
                self.paste_shapes()
                event.accept()
                return  # [4909]
        if key == Qt.Key.Key_Z and ctrl_pressed and not alt_pressed:  # [4910]
            if shift_pressed:
                self.redo()  # [4911]
            else:
                self.undo()  # [4912]
            event.accept()
            return  # [4913]
        elif (
            key == Qt.Key.Key_Y
            and ctrl_pressed
            and not shift_pressed
            and not alt_pressed
        ):
            self.redo()
            event.accept()
            return  # [4914]
        if key == Qt.Key.Key_S and ctrl_pressed:  # [4915]
            if self.control_panel:
                self.control_panel.save_scene_action()  # [4916]
            event.accept()
            return  # [4917]
        if key == Qt.Key.Key_L and ctrl_pressed and not shift_pressed:  # [4918]
            if self.control_panel:
                self.control_panel.load_scene_action()  # [4919]
            event.accept()
            return  # [4920]
        if key == Qt.Key.Key_L and ctrl_pressed and shift_pressed:  # [4921]
            if self.control_panel:
                self.control_panel.load_and_join_scene_action()  # [4922]
            event.accept()
            return  # [4923]
        if key == Qt.Key.Key_C and shift_pressed and not ctrl_pressed:  # [4924]
            print("Shift+C: Clearing all shapes.")
            self.clear_scene(
                keep_background_image=(
                    self.edit_mode and self._entered_edit_via_loadimg
                )
            )
            event.accept()
            return  # [4925]
        if key == Qt.Key.Key_K and ctrl_pressed:  # [4926]
            if self.control_panel:
                self.control_panel.toggle_shortcuts_window(force_reset=False)  # [4927]
            event.accept()
            return  # [4928]

        if (
            ralt_pressed and keypad_modifier and Qt.Key.Key_0 <= key <= Qt.Key.Key_9
        ):  # [4929]
            if self.selected_shapes:  # [4930]
                num_value = key - Qt.Key.Key_0
                percentage = num_value * 100.0 / 9.0
                alpha_255 = round(percentage * 2.55)
                alpha_255 = max(0, min(255, alpha_255))  # [4931]
                print(
                    f"Applying Alpha {alpha_255}/255 ({percentage:.1f}%) to {len(self.selected_shapes)} selected shapes (RAlt+Num{num_value})"
                )  # [4932]
                prev_props = {}
                current_indices = []
                changed_shapes = []  # [4933]
                for shape in self.selected_shapes:  # [4934]
                    if shape.alpha != alpha_255:  # [4935]
                        try:  # [4936]
                            shape_idx = self.shapes.index(shape)
                            current_indices.append(shape_idx)
                            prev_props[shape_idx] = deepcopy(shape)  # [4937]
                            shape.alpha = alpha_255
                            changed_shapes.append(shape)  # [4938]
                        except ValueError:
                            continue  # [4939]
                if changed_shapes:
                    self.save_state(
                        "change_alpha",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )
                    self.update()  # [4940]
                else:
                    print("Selected shapes already have target alpha.")  # [4941]
                event.accept()
                return  # [4942]
            else:
                print("RAlt+Numpad pressed, but no shapes selected.")
                event.accept()
                return  # [4943]

        if self.board_mode or self.edit_mode:  # [4944]
            if (
                ctrl_pressed
                and not alt_pressed
                and not shift_pressed
                and Qt.Key.Key_0 <= key <= Qt.Key.Key_9
            ):  # [4945]
                num_value = key - Qt.Key.Key_0
                alpha = int(round((num_value / 9.0) * 254)) + 1 if num_value > 0 else 1
                alpha = min(255, max(1, alpha))  # [4946]
                current_bg = self.board_background_color
                new_color = QColor(
                    current_bg.red(), current_bg.green(), current_bg.blue(), alpha
                )  # [4947]
                if new_color != current_bg:
                    self.set_board_background_color(new_color)  # [4948]
                event.accept()
                return  # [4949]
            elif (
                alt_pressed
                and not ctrl_pressed
                and not shift_pressed
                and key in self.board_color_shortcuts
            ):  # [4950]
                target_rgb_color = self.board_color_shortcuts[key]
                current_bg = self.board_background_color  # [4951]
                new_color = QColor(
                    target_rgb_color.red(),
                    target_rgb_color.green(),
                    target_rgb_color.blue(),
                    current_bg.alpha(),
                )  # [4952]
                if new_color != current_bg:
                    self.set_board_background_color(new_color)  # [4953]
                event.accept()
                return  # [4954]
            elif (
                not ctrl_pressed
                and not alt_pressed
                and not shift_pressed
                and key in self.board_color_shortcuts
            ):  # [4955]
                target_color = self.board_color_shortcuts[key]
                pen_action = None
                prev_pen_color = None  # [4956]
                if self.edit_mode:
                    pen_action = "change_edit_pen"
                    prev_pen_color = deepcopy(self.current_pen_color_edit)  # [4957]
                elif self.board_mode:
                    pen_action = "change_board_pen"
                    prev_pen_color = deepcopy(
                        self.current_pen_color_board_only
                    )  # [4958]
                if self.selected_shapes:  # [4959]
                    prev_props = {}
                    current_indices = []
                    changed_shapes = []  # [4960]
                    for shape in self.selected_shapes:  # [4961]
                        try:
                            shape_idx = self.shapes.index(shape)  # [4962]
                        except ValueError:
                            continue  # [4963]
                        if (
                            shape.color != target_color
                            or shape.gradient_properties
                            or shape.hatch_properties
                        ):  # [4964]
                            current_indices.append(shape_idx)
                            prev_props[shape_idx] = deepcopy(shape)  # [4965]
                            shape.color = QColor(target_color)
                            changed_shapes.append(shape)  # [4966]
                            shape.gradient_properties = None
                            shape.hatch_properties = None  # [4967]
                    if changed_shapes:
                        self.save_state(
                            "change_color",
                            shapes_involved=changed_shapes,
                            previous_geometries=prev_props,
                            indices=current_indices,
                        )
                        self.update()  # [4968]
                elif pen_action:  # [4969]
                    if target_color != prev_pen_color:  # [4970]
                        if self.edit_mode:
                            self.save_state(
                                pen_action,
                                previous_geometries={"edit_pen": prev_pen_color},
                            )
                            self.set_edit_pen_color(QColor(target_color))  # [4971]
                        else:
                            self.save_state(
                                pen_action,
                                previous_geometries={"board_pen": prev_pen_color},
                            )
                            self.set_board_pen_color_only(
                                QColor(target_color)
                            )  # [4972]
                event.accept()
                return  # [4973]
        elif (
            not self.board_mode
            and not self.edit_mode
            and not ctrl_pressed
            and not alt_pressed
            and not shift_pressed
            and key in self.color_shortcuts
        ):  # [4974]
            target_color = self.color_shortcuts[key]  # [4975]
            if self.selected_shapes:  # [4976]
                prev_props = {}
                current_indices = []
                changed_shapes = []  # [4977]
                for shape in self.selected_shapes:  # [4978]
                    try:
                        shape_idx = self.shapes.index(shape)  # [4979]
                    except ValueError:
                        continue  # [4980]
                    if (
                        shape.color != target_color
                        or shape.gradient_properties
                        or shape.hatch_properties
                    ):  # [4981]
                        current_indices.append(shape_idx)
                        prev_props[shape_idx] = deepcopy(shape)  # [4982]
                        shape.color = QColor(target_color)
                        changed_shapes.append(shape)  # [4983]
                        shape.gradient_properties = None
                        shape.hatch_properties = None  # [4984]
                if changed_shapes:
                    self.save_state(
                        "change_color",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )
                    self.update()  # [4985]
            else:  # [4986]
                if self.temp_mode:
                    self.set_temp_pen_color(QColor(target_color))  # [4987]
                else:
                    self.set_pen_color(QColor(target_color))  # [4988]
            event.accept()
            return  # [4989]

        if (
            alt_pressed
            and not ctrl_pressed
            and not shift_pressed
            and self.control_panel
        ):  # [4990]
            action_performed_for_alt = False  # [4991]
            if self.current_tool == "line_point":  # [4992]
                if key == Qt.Key.Key_N:  # [4993]
                    self.control_panel.line_point_no_arrow_radio.toggle()  # [4994]
                    action_performed_for_alt = True  # [4995]
                elif key == Qt.Key.Key_E:  # [4996]
                    self.control_panel.line_point_1a_radio.toggle()  # [4997]
                    action_performed_for_alt = True  # [4998]
                elif key == Qt.Key.Key_D:  # [4999]
                    self.control_panel.line_point_2a_radio.toggle()  # [5000]
                    action_performed_for_alt = True  # [5001]
            elif self.current_tool == "spline":  # [5002]
                if key == Qt.Key.Key_N:  # [5003]
                    self.control_panel.line_point_no_arrow_radio_spline.toggle()  # [5004]
                    action_performed_for_alt = True  # [5005]
                elif key == Qt.Key.Key_E:  # [5006]
                    self.control_panel.line_point_1a_radio_spline.toggle()  # [5007]
                    action_performed_for_alt = True  # [5008]
                elif key == Qt.Key.Key_D:  # [5009]
                    self.control_panel.line_point_2a_radio_spline.toggle()  # [5010]
                    action_performed_for_alt = True  # [5011]
            elif self.current_tool == "arrow":  # [5012]
                if key == Qt.Key.Key_D:  # [5013]
                    self.control_panel.fixed_size_widgets["arrow"][
                        "DoubleHeaded"
                    ].toggle()  # [5014]
                    action_performed_for_alt = True  # [5015]
            elif self.current_tool == "MPoint":  # [5016]
                if key == Qt.Key.Key_S:  # [5017]
                    self.control_panel.mpoint_square_check.toggle()  # [5018]
                    action_performed_for_alt = True  # [5019]
                elif key == Qt.Key.Key_O:  # [5020]
                    self.control_panel.mpoint_circle_radio.toggle()  # [5021]
                    action_performed_for_alt = True  # [5022]

            if action_performed_for_alt:  # [5023]
                event.accept()  # [5024]
                return  # [5025]

        should_check_tools = (
            not self.input_mode
            and not ctrl_pressed
            and not alt_pressed
            and not (keypad_modifier and Qt.Key.Key_0 <= key <= Qt.Key.Key_9)
        )  # [5026]
        if should_check_tools:  # [5027]
            new_tool = None  # [5028]
            is_param_shortcut = is_page_key and (
                (shift_pressed and not ctrl_pressed and not alt_pressed)
                or (alt_pressed and not ctrl_pressed and not shift_pressed)
                or (ctrl_pressed and not shift_pressed and not alt_pressed)
                or (ctrl_pressed and shift_pressed and not alt_pressed)
            )  # [5029]
            if not is_param_shortcut:  # [5030]
                if key == Qt.Key.Key_R:
                    new_tool = "rect"  # [5031]
                elif key == Qt.Key.Key_E:
                    new_tool = "ellipse"  # [5032]
                elif key == Qt.Key.Key_T and not shift_pressed:
                    new_tool = "triangle"  # [5033]
                elif key == Qt.Key.Key_U:
                    new_tool = "arc"  # [5034]
                elif key == Qt.Key.Key_Z:
                    new_tool = "trapeze"  # [5035]
                elif key == Qt.Key.Key_L:
                    new_tool = "line"  # [5036]
                elif key == Qt.Key.Key_M:
                    new_tool = "line_point"  # [5037]
                elif key == Qt.Key.Key_A and not shift_pressed:
                    new_tool = "arrow"  # [5038]
                elif key == Qt.Key.Key_P:
                    new_tool = "polygon"  # [5039]
                elif key == Qt.Key.Key_W:
                    new_tool = "regular_polygon"  # [5040]
                elif key == Qt.Key.Key_O:
                    new_tool = "MPoint"  # [5041]
                elif key == Qt.Key.Key_Greater:
                    new_tool = "angle_marker"  # [5042]
                elif key == Qt.Key.Key_B:
                    new_tool = "brush"  # [5043]
                elif key == Qt.Key.Key_X:
                    new_tool = "text"  # [5044]
                elif (
                    key == Qt.Key.Key_S
                    and not ctrl_pressed
                    and not alt_pressed
                    and not shift_pressed
                ):
                    new_tool = "spline"  # [5045]
                elif key == Qt.Key.Key_Q:
                    new_tool = "dimension"  # [5046]

                if self.current_tool == "line_point":  # [5047]
                    if (
                        key == Qt.Key.Key_I
                        and not alt_pressed
                        and not ctrl_pressed
                        and not shift_pressed
                    ):  # [5048]
                        if hasattr(
                            self.control_panel, "line_point_invert_check"
                        ):  # [5049]
                            self.control_panel.line_point_invert_check.toggle()  # [5050]
                        event.accept()
                        return  # [5051]
                elif self.current_tool == "MPoint":  # [5052]
                    if (
                        key == Qt.Key.Key_S
                        and not alt_pressed
                        and not ctrl_pressed
                        and not shift_pressed
                    ):  # [5053]
                        pass  # [5054]
                    elif (
                        key == Qt.Key.Key_T
                        and not alt_pressed
                        and not ctrl_pressed
                        and not shift_pressed
                    ):  # [5055]
                        self.control_panel.mpoint_label_check.toggle()  # [5056]
                        event.accept()
                        return  # [5057]
                elif self.current_tool == "angle_marker":  # [5058]
                    if (
                        key == Qt.Key.Key_I
                        and not alt_pressed
                        and not ctrl_pressed
                        and not shift_pressed
                    ):  # [5059]
                        self.control_panel.angle_tool_inner_check.toggle()  # [5060]
                        event.accept()
                        return  # [5061]
                    elif (
                        key == Qt.Key.Key_O
                        and not alt_pressed
                        and not ctrl_pressed
                        and not shift_pressed
                    ):  # [5062]
                        self.control_panel.angle_tool_outer_check.toggle()  # [5063]
                        event.accept()
                        return  # [5064]
                elif self.current_tool == "rect":  # [5065]
                    if (
                        key == Qt.Key.Key_U
                        and not alt_pressed
                        and not ctrl_pressed
                        and not shift_pressed
                    ):  # [5066]
                        self.control_panel.fixed_size_widgets["rect"][
                            "Rounded"
                        ].toggle()  # [5067]
                        event.accept()
                        return  # [5068]

            if new_tool and new_tool != self.current_tool:  # [5069]
                self.current_tool = new_tool  # [5070]
                if self.control_panel:
                    self.control_panel.set_tool(new_tool)  # [5071]
                self.unsetCursor()
                self.current_drawing_shape = None
                self.polygon_points.clear()
                self.brush_points.clear()
                self.angle_points.clear()
                self.spline_points.clear()  # [5072]
                self.dragging = False
                self.resizing = False
                self.is_lasso_selecting = False  # [5073]
                if self.input_mode:
                    self.input_mode = None  # [5074]
                self.dimension_points.clear()
                self.dimension_preview_shapes.clear()  # [5075]
                if (
                    new_tool == "dimension"
                    and hasattr(self, "overlay")
                    and self.overlay is not None
                    and not self.overlay.dimension_preview_color_explicitly_set
                ):  # [5076]
                    new_preview_color = QColor(self.current_pen_color)
                    new_preview_color.setAlpha(100)  # [5077]
                    self.overlay.overlay.set_dimension_preview_line_color(
                        new_preview_color, from_pen_color_change=True
                    )  # [5078]
                self.active_angle_shape_for_point_drag = None
                self.active_angle_point_handle = None  # [5079]
                self.update()
                print(f"Tool changed to: {self.current_tool}")  # [5080]
                event.accept()
                return  # [5081]
            elif new_tool and new_tool == self.current_tool:  # [5082]
                print(f"Tool {new_tool} is already active.")  # [5083]
                event.accept()
                return  # [5084]

        if (
            key == Qt.Key.Key_Y
            and not ctrl_pressed
            and not alt_pressed
            and not shift_pressed
        ):
            self.send_selection_to_back()
            event.accept()
            return  # [5085]
        if key == Qt.Key.Key_Delete or key == Qt.Key.Key_Backspace:  # [5086]
            if not (keypad_modifier and key == Qt.Key.Key_Delete):
                self._delete_selected_shapes_action()
                event.accept()
                return  # [5087]
        if (
            keypad_modifier
            and key in (Qt.Key.Key_Plus, Qt.Key.Key_Minus)
            and not self.selected_shapes
        ):  # [5088]
            if self.control_panel:  # [5089]
                current_thickness = self.control_panel.thickness_spin.value()
                step = 1  # [5090]
                if key == Qt.Key.Key_Plus:
                    new_thickness = current_thickness + step  # [5091]
                else:
                    new_thickness = current_thickness - step  # [5092]
                min_val = self.control_panel.thickness_spin.minimum()
                max_val = self.control_panel.thickness_spin.maximum()
                new_thickness = max(min_val, min(max_val, new_thickness))  # [5093]
                if new_thickness != current_thickness:
                    print(f"Changing thickness via Numpad+/- to: {new_thickness}")
                    self.control_panel.thickness_spin.setValue(new_thickness)  # [5094]
                event.accept()
                return  # [5095]
            else:
                print("Numpad +/- pressed, but control panel not available.")
                event.accept()
                return  # [5096]

        if self.selected_shapes:  # [5097]
            delta_x, delta_y = 0, 0
            scale_factor = 1.0
            rotation_delta = 0
            action_type = None
            prev_props = {}
            needs_angle_recalc = False  # [5098]
            is_angle_point_active = (
                self.active_angle_shape_for_point_drag is not None
            )  # [5099]
            nudge = 1 if not shift_pressed else 10  # [5100]

            if is_angle_point_active and key in (
                Qt.Key.Key_Left,
                Qt.Key.Key_Right,
                Qt.Key.Key_Up,
                Qt.Key.Key_Down,
            ):  # [5101]
                if key == Qt.Key.Key_Left:
                    delta_x = -nudge  # [5102]
                elif key == Qt.Key.Key_Right:
                    delta_x = nudge  # [5103]
                elif key == Qt.Key.Key_Up:
                    delta_y = -nudge  # [5104]
                elif key == Qt.Key.Key_Down:
                    delta_y = nudge  # [5105]

                active_shape = self.active_angle_shape_for_point_drag  # [5106]
                handle_name = self.active_angle_point_handle  # [5107]
                point_idx_map = {"vertex_A": 0, "vertex_O": 1, "vertex_B": 2}  # [5108]
                if handle_name in point_idx_map:  # [5109]
                    idx_to_move = point_idx_map[handle_name]  # [5110]
                    if isinstance(
                        active_shape.geometry, list
                    ) and 0 <= idx_to_move < len(active_shape.geometry):  # [5111]
                        current_indices_undo = []  # [5112]
                        if active_shape in self.shapes:  # [5113]
                            try:  # [5114]
                                current_indices_undo.append(
                                    self.shapes.index(active_shape)
                                )  # [5115]
                            except ValueError:  # [5116]
                                current_indices_undo = []  # [5117]

                        prev_props_undo = {}  # [5118]
                        if current_indices_undo:  # [5119]
                            prev_props_undo = {
                                current_indices_undo[0]: deepcopy(active_shape)
                            }  # [5120]
                            self.save_state(
                                "resize",
                                shapes_involved=[active_shape],
                                previous_geometries=prev_props_undo,
                                indices=current_indices_undo,
                            )  # [5121]

                        active_shape.geometry[idx_to_move] += QPointF(
                            delta_x, delta_y
                        )  # [5122]
                        self.update_angle_marker_text(active_shape.group_id)  # [5123]
                        self.update()  # [5124]
                        event.accept()  # [5125]
                        return  # [5126]
            elif (
                any(
                    s.type == "text"
                    and s.text_properties
                    and s.text_properties.get("is_angle_display")
                    for s in self.selected_shapes
                )
                and key
                in (Qt.Key.Key_Left, Qt.Key.Key_Right, Qt.Key.Key_Up, Qt.Key.Key_Down)
                and not is_angle_point_active
            ):  # [5127]
                if key == Qt.Key.Key_Left:
                    delta_x = -nudge  # [5128]
                elif key == Qt.Key.Key_Right:
                    delta_x = nudge  # [5129]
                elif key == Qt.Key.Key_Up:
                    delta_y = -nudge  # [5130]
                elif key == Qt.Key.Key_Down:
                    delta_y = nudge  # [5131]
                action_type = "move"  # [5132]
                needs_angle_recalc = True  # [5133]
            elif (
                not ctrl_pressed and not alt_pressed and not is_angle_point_active
            ):  # [5134]
                if key == Qt.Key.Key_Left:
                    delta_x = -nudge
                    action_type = "move"  # [5135]
                elif key == Qt.Key.Key_Right:
                    delta_x = nudge
                    action_type = "move"  # [5136]
                elif key == Qt.Key.Key_Up:
                    delta_y = -nudge
                    action_type = "move"  # [5137]
                elif key == Qt.Key.Key_Down:
                    delta_y = nudge
                    action_type = "move"  # [5138]
                elif key in (Qt.Key.Key_Plus, Qt.Key.Key_Equal):
                    scale_factor = 1.02 if not shift_pressed else 1.1
                    action_type = "scale"  # [5139]
                elif key == Qt.Key.Key_Minus:
                    scale_factor = 1.0 / (1.02 if not shift_pressed else 1.1)
                    action_type = "scale"  # [5140]
                if action_type in ["move", "scale"]:
                    needs_angle_recalc = True  # [5141]
            elif alt_pressed and not is_angle_point_active:  # [5142]
                if key == Qt.Key.Key_Left:
                    rotation_delta = -1 if shift_pressed else -0.1
                    action_type = "rotate"  # [5143]
                elif key == Qt.Key.Key_Right:
                    rotation_delta = 1 if shift_pressed else 0.1
                    action_type = "rotate"  # [5144]
                if action_type == "rotate":
                    needs_angle_recalc = True  # [5145]
            elif ctrl_pressed and not is_angle_point_active:  # [5146]
                if key == Qt.Key.Key_Left:
                    rotation_delta = -90
                    action_type = "rotate"  # [5147]
                elif key == Qt.Key.Key_Right:
                    rotation_delta = 90
                    action_type = "rotate"  # [5148]
                if action_type == "rotate":
                    needs_angle_recalc = True  # [5149]

            if action_type:  # [5150]
                selected_to_transform = []  # [5151]
                if action_type == "move":  # [5152]
                    selected_to_transform = self.selected_shapes  # [5153]
                else:  # [5154]
                    selected_to_transform = [
                        s
                        for s in self.selected_shapes
                        if not (
                            (s.is_dimension_part and s.dimension_type == "text")
                            or (
                                s.type == "text"
                                and s.text_properties
                                and s.text_properties.get("is_angle_display", False)
                            )
                        )
                    ]  # [5155]

                if not selected_to_transform:
                    print(
                        f"Action '{action_type}' ignored: Selection contains only non-transformable text."
                    )
                    event.accept()
                    return  # [5156]

                print(
                    f"Performing {action_type} on {len(selected_to_transform)} shapes"
                )  # [5157]
                current_indices = []
                prev_props = {}
                changed_shapes = []  # [5158]
                for shape in selected_to_transform:  # [5159]
                    try:
                        shape_idx = self.shapes.index(shape)  # [5160]
                    except ValueError:
                        continue  # [5161]
                    current_indices.append(shape_idx)
                    changed_shapes.append(shape)
                    prev_props[shape_idx] = deepcopy(shape)  # [5162]

                for shape in changed_shapes:  # [5163]
                    if action_type == "move":  # [5164]
                        if (
                            isinstance(shape.geometry, QRectF)
                            and shape.geometry.isValid()
                        ):
                            shape.geometry.translate(delta_x, delta_y)  # [5165]
                        elif isinstance(shape.geometry, QPointF):
                            shape.geometry += QPointF(delta_x, delta_y)  # [5166]
                        elif isinstance(shape.geometry, list):
                            shape.geometry = [
                                QPointF(p.x() + delta_x, p.y() + delta_y)
                                for p in shape.geometry
                                if isinstance(p, QPointF)
                            ]  # [5167]
                        if (
                            shape.type == "text"
                            and shape.text_properties
                            and shape.text_properties.get("is_angle_display")
                            and shape.group_id
                        ):  # [5168]
                            marker_shape = next(
                                (
                                    s
                                    for s in self.shapes
                                    if s.group_id == shape.group_id
                                    and s.type == "angle_marker"
                                    and s in self.selected_shapes
                                ),
                                None,
                            )  # [5169]
                            if marker_shape and isinstance(
                                marker_shape.geometry, list
                            ):  # [5170]
                                marker_shape.geometry = [
                                    p + QPointF(delta_x, delta_y)
                                    for p in marker_shape.geometry
                                    if isinstance(p, QPointF)
                                ]  # [5171]
                        elif shape.type == "angle_marker" and shape.group_id:  # [5172]
                            text_shape_angle = next(
                                (
                                    s
                                    for s in self.shapes
                                    if s.group_id == shape.group_id
                                    and s.type == "text"
                                    and s.text_properties
                                    and s.text_properties.get("is_angle_display")
                                    and s in self.selected_shapes
                                ),
                                None,
                            )  # [5173]
                            if text_shape_angle and isinstance(
                                text_shape_angle.geometry, QRectF
                            ):  # [5174]
                                text_shape_angle.geometry.translate(
                                    delta_x, delta_y
                                )  # [5175]

                        if shape.type == "angle_marker" or (
                            shape.type == "text"
                            and shape.text_properties
                            and shape.text_properties.get("is_angle_display")
                        ):  # [5176]
                            if shape.group_id:
                                self.update_angle_marker_text(shape.group_id)  # [5177]
                    elif action_type == "scale":  # [5178]
                        center = self._get_shape_center(shape)  # [5179]
                        if not center.isNull():  # [5180]
                            tf = (
                                QTransform()
                                .translate(center.x(), center.y())
                                .scale(scale_factor, scale_factor)
                                .translate(-center.x(), -center.y())
                            )  # [5181]
                            if (
                                isinstance(shape.geometry, QRectF)
                                and shape.geometry.isValid()
                            ):
                                shape.geometry = tf.mapRect(shape.geometry)  # [5182]
                            elif isinstance(shape.geometry, QPointF):
                                shape.geometry = tf.map(shape.geometry)  # [5183]
                            elif isinstance(shape.geometry, list):
                                shape.geometry = [
                                    tf.map(p)
                                    for p in shape.geometry
                                    if isinstance(p, QPointF)
                                ]  # [5184]
                            if shape.type == "angle_marker" and shape.group_id:
                                self.update_angle_marker_text(shape.group_id)  # [5185]
                    elif action_type == "rotate":  # [5186]
                        new_rotation = (
                            shape.rotation + rotation_delta
                        ) % 360.0  # [5187]
                        if new_rotation < 0:
                            new_rotation += 360.0  # [5188]
                        shape.rotation = round(new_rotation, 1)  # [5189]
                        if shape.type == "angle_marker" and shape.group_id:
                            self.update_angle_marker_text(shape.group_id)  # [5190]

                if current_indices and prev_props:  # [5191]
                    self.save_state(
                        action_type,
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                        selected_shapes_before=deepcopy(self.selected_shapes),
                    )  # [5192]
                if self.show_angle_offset and needs_angle_recalc:
                    self.recalculate_and_update_angle_offsets()  # [5193]
                else:
                    self.update()  # [5194]
                self._configure_mode()
                event.accept()
                return  # [5195]

        super().keyPressEvent(event)  # [5196]

    def keyReleaseEvent(self, event: QKeyEvent):  # [5197]
        """Handles key release events, mainly for tracking pressed keys."""  # [5198]
        key = event.key()  # [5199]
        if key in self.pressed_keys:  # [5200]
            try:  # [5201]
                self.pressed_keys.remove(key)  # [5202]
            except KeyError:  # [5203]
                pass  # [5204]

        if key == Qt.Key.Key_Control:  # [5205]
            if self.current_tool == "line_point":  # [5206]
                if self.snapped_line_point_preview_end is not None:  # [5207]
                    self.snapped_line_point_preview_end = None  # [5208]
                    self.update()  # [5209]
                if self.current_snap_angle is not None:  # [5210]
                    self.current_snap_angle = None  # [5211]
                    self.update()  # [5212]
            elif self.current_drawing_shape and self.current_drawing_shape.type in [
                "line",
                "arrow",
            ]:  # [5213]
                if self.current_snap_angle is not None:  # [5214]
                    self.current_snap_angle = None  # [5215]
                    self.update()  # [5216]

        if key == Qt.Key.Key_Control and self.is_lasso_selecting:  # [5217]
            print("Ctrl released during Lasso Select. Cancelling.")  # [5218]
            self.is_lasso_selecting = False  # [5219]
            self.polygon_points = []  # [5220]
            self.update()  # [5221]
            event.accept()
            return  # [5222]

        if (
            key == Qt.Key.Key_Alt and self.selected_shapes and self.drawing_mode
        ):  # [5223]
            self.update()  # [5224]
            event.accept()
            return  # [5225]
        super().keyReleaseEvent(event)  # [5226]

    def closeEvent(self, event):  # [5227]
        """Ensure hotkey is unregistered on close."""  # [5228]
        print("Overlay closeEvent called.")  # [5229]
        self._unregister_global_hotkey()  # [5230]
        self.save_mpoint_label_style()  # [5231]
        self.save_dimension_text_defaults()  # [5232]
        self.save_dimension_preview_line_color()  # [5233]
        self.save_angle_tool_settings()  # [5234]
        self.save_hatch_fill_settings()  # [5235]
        self.save_division_point_settings()  # [5236]
        self.save_snap_settings()  # [5237]
        if self.control_panel and self.control_panel.zoom_enabled:  # [5238]
            self.control_panel.toggle_zoom(False)  # [5239]
        super().closeEvent(event)  # [5240]

    def save_all_settings(self):
        """Saves all relevant settings for DesktopOverlayRgn."""
        print("DesktopOverlayRGN: Saving all settings...")
        self.save_board_settings()
        self.save_mpoint_label_style()
        self.save_dimension_text_defaults()
        self.save_dimension_preview_line_color()
        self.save_angle_tool_settings()
        self.save_hatch_fill_settings()
        self.save_division_point_settings()
        self.save_snap_settings()
        # Other DesktopOverlayRgn specific settings can be added here
        # e.g. self.settings.setValue("overlay/someOtherSetting", self.some_other_setting_value)
        self.settings.sync()
        print("DesktopOverlayRGN: All settings saved.")

    def copy_shapes(self):  # [5241]
        """Copies selected shapes to the internal clipboard."""  # [5242]
        if not self.selected_shapes:
            return  # [5243]
        shapes_to_copy_set = set()  # [5244]
        for s in self.selected_shapes:  # [5245]
            if (
                s.type == "text"
                and s.text_properties
                and s.text_properties.get("is_angle_display")
                and s.group_id
            ):  # [5246]
                shapes_to_copy_set.add(s)  # [5247]
                marker_shape = next(
                    (
                        m_s
                        for m_s in self.shapes
                        if m_s.group_id == s.group_id
                        and m_s.type == "angle_marker"
                        and m_s in self.selected_shapes
                    ),
                    None,
                )  # [5248]
                if marker_shape:  # [5249]
                    shapes_to_copy_set.add(marker_shape)  # [5250]
                continue  # [5251]

            elif (
                (s.is_dimension_part or s.type == "angle_marker")
                and not s.group_id
                and s not in self.selected_shapes
            ):  # [5252]
                continue  # [5253]
            shapes_to_copy_set.add(s)  # [5254]
            if s.group_id:  # [5255]
                group_members = {
                    shape for shape in self.shapes if shape.group_id == s.group_id
                }  # [5256]
                shapes_to_copy_set.update(group_members)  # [5257]

        final_shapes_to_copy = []  # [5258]
        processed_groups = set()  # [5259]
        for s_to_add in list(shapes_to_copy_set):  # [5260]
            if s_to_add.group_id:  # [5261]
                if s_to_add.group_id not in processed_groups:  # [5262]
                    all_group_members_in_scene = {
                        sm for sm in self.shapes if sm.group_id == s_to_add.group_id
                    }  # [5263]
                    if all_group_members_in_scene.issubset(
                        shapes_to_copy_set
                    ):  # [5264]
                        final_shapes_to_copy.extend(
                            list(all_group_members_in_scene)
                        )  # [5265]
                    else:  # [5266]
                        selected_parts_of_group = {
                            sm_part
                            for sm_part in all_group_members_in_scene
                            if sm_part in shapes_to_copy_set
                        }  # [5267]
                        final_shapes_to_copy.extend(
                            list(selected_parts_of_group)
                        )  # [5268]
                    processed_groups.add(s_to_add.group_id)  # [5269]
            elif s_to_add not in final_shapes_to_copy:  # [5270]
                final_shapes_to_copy.append(s_to_add)  # [5271]

        self.clipboard_shapes = [deepcopy(s) for s in final_shapes_to_copy]  # [5272]
        print(
            f"Copied {len(self.clipboard_shapes)} shapes (incl. complete groups and individual parts)."
        )  # [5273]

    def paste_shapes(self):  # [5274]
        """Pastes shapes from the internal clipboard at the cursor position."""  # [5275]
        if not self.clipboard_shapes:
            return  # [5276]
        mouse_pos_local = self.mapFromGlobal(QCursor.pos())  # [5277]
        pasted_shapes_for_undo = []  # [5278]
        new_indices = []  # [5279]
        group_id_map = {}  # [5280]

        all_points = []
        all_rects = []  # [5281]
        for shape in self.clipboard_shapes:  # [5282]
            if isinstance(shape.geometry, QRectF) and shape.geometry.isValid():
                all_rects.append(shape.geometry)  # [5283]
            elif isinstance(shape.geometry, QPointF):
                all_points.append(shape.geometry)  # [5284]
            elif isinstance(shape.geometry, list):
                all_points.extend(
                    [p for p in shape.geometry if isinstance(p, QPointF)]
                )  # [5285]

        clip_center = QPointF()  # [5286]
        if all_rects or all_points:  # [5287]
            min_x, min_y = float("inf"), float("inf")
            max_x, max_y = float("-inf"), float("-inf")  # [5288]
            for r in all_rects:  # [5289]
                min_x = min(min_x, r.left())  # [5290]
                min_y = min(min_y, r.top())  # [5291]
                max_x = max(max_x, r.right())  # [5292]
                max_y = max(max_y, r.bottom())  # [5293]
            for p in all_points:  # [5294]
                min_x = min(min_x, p.x())  # [5295]
                min_y = min(min_y, p.y())  # [5296]
                max_x = max(max_x, p.x())  # [5297]
                max_y = max(max_y, p.y())  # [5298]

            if min_x != float("inf"):
                clip_center = QPointF(
                    (min_x + max_x) / 2.0, (min_y + max_y) / 2.0
                )  # [5299]
            else:
                clip_center = mouse_pos_local  # [5300]
        else:  # [5301]
            clip_center = mouse_pos_local  # [5302]

        paste_offset = QPointF(mouse_pos_local) - clip_center  # [5303]
        self.save_state(
            "paste", previous_geometries=len(self.clipboard_shapes)
        )  # [5304]

        for shape in self.clipboard_shapes:  # [5305]
            new_shape = deepcopy(shape)  # [5306]
            if isinstance(new_shape.geometry, QRectF) and new_shape.geometry.isValid():
                new_shape.geometry.translate(paste_offset)  # [5307]
            elif isinstance(new_shape.geometry, QPointF):
                new_shape.geometry += paste_offset  # [5308]
            elif isinstance(new_shape.geometry, list):
                new_shape.geometry = [
                    p + paste_offset
                    for p in new_shape.geometry
                    if isinstance(p, QPointF)
                ]  # [5309]

            if new_shape.group_id:  # [5310]
                is_solo_angle_text = (  # [5311]
                    new_shape.type == "text"  # [5312]
                    and new_shape.text_properties  # [5313]
                    and new_shape.text_properties.get("is_angle_display")  # [5314]
                    and not any(
                        s.group_id == new_shape.group_id and s.type == "angle_marker"
                        for s in self.clipboard_shapes
                        if s != new_shape
                    )  # [5315]
                )  # [5316]
                if not is_solo_angle_text:  # [5317]
                    original_group_id = new_shape.group_id  # [5318]
                    if original_group_id not in group_id_map:  # [5319]
                        group_id_map[original_group_id] = (
                            f"group_{uuid.uuid4()}"  # [5320]
                        )
                    new_shape.group_id = group_id_map[original_group_id]  # [5321]
                else:  # [5322]
                    new_shape.group_id = None  # [5323]

            self.shapes.append(new_shape)  # [5324]
            pasted_shapes_for_undo.append(new_shape)  # [5325]
            new_indices.append(len(self.shapes) - 1)  # [5326]

            if self.temp_mode:  # [5327]
                self.schedule_shape_removal(new_shape)  # [5328]

        self.selected_shapes = self.shapes[-len(self.clipboard_shapes) :]  # [5329]

        if self.show_angle_offset:  # [5330]
            print("Paste finished, recalculating angle offsets.")  # [5331]
            self.recalculate_and_update_angle_offsets()  # [5332]
        else:
            self.update()  # [5333]

        self._configure_mode()  # [5334]
        print(f"Pasted {len(self.clipboard_shapes)} shapes.")  # [5335]

    def capture_screenshot(self):  # [5336]
        """Initiates the screenshot capture process."""  # [5337]
        try:  # [5338]
            self._do_capture_screenshot()  # [5339]
        except Exception as e:  # [5340]
            print(f"Error preparing screenshot: {e}")  # [5341]
            traceback.print_exc()  # [5342]
            QMessageBox.critical(
                self,
                "Screenshot Error",
                f"An unexpected error occurred during screenshot preparation:\n{e}",
            )  # [5343]

    def _do_capture_screenshot(self):  # [5344]
        """Actual screenshot capture and save logic."""  # [5345]
        try:  # [5346]
            screen = QGuiApplication.primaryScreen()  # [5347]
            if not screen:  # [5348]
                print("Error: Could not get primary screen.")  # [5349]
                QMessageBox.warning(
                    self, "Screenshot Error", "Could not access primary screen."
                )  # [5350]
                return  # [5351]

            desktop_wid = 0  # [5352]
            pixmap = screen.grabWindow(desktop_wid)  # [5353]
            if pixmap.isNull():  # [5354]
                print(
                    "Whole screen grab failed, grabbing primary screen geometry."
                )  # [5355]
                geom = screen.geometry()  # [5356]
                pixmap = screen.grabWindow(
                    0, geom.x(), geom.y(), geom.width(), geom.height()
                )  # [5357]

            if pixmap.isNull():  # [5358]
                print("Error: Failed to capture screenshot.")  # [5359]
                QMessageBox.warning(
                    self, "Screenshot Error", "Failed to capture screen content."
                )  # [5360]
                return  # [5361]

            default_save_path = self.settings.value(
                "paths/lastScreenshotSaveDir",
                QStandardPaths.writableLocation(
                    QStandardPaths.StandardLocation.PicturesLocation
                ),
            )  # [5362]
            filename, selected_filter = QFileDialog.getSaveFileName(  # [5363]
                self,  # [5364]
                "Save Screenshot As",  # [5365]
                default_save_path,  # [5366]
                "JPEG Image (*.jpg *.jpeg);;PNG Image (*.png)",  # [5367]
            )  # [5368]

            if filename:  # [5369]
                self.settings.setValue(
                    "paths/lastScreenshotSaveDir", os.path.dirname(filename)
                )  # [5370]
                file_format = None  # [5371]
                quality = -1  # [5372]
                low_filename = filename.lower()  # [5373]
                if "png" in selected_filter.lower() or low_filename.endswith(
                    ".png"
                ):  # [5374]
                    file_format = "png"  # [5375]
                    quality = -1  # [5376]
                elif (
                    "jp" in selected_filter.lower()
                    or low_filename.endswith(".jpg")
                    or low_filename.endswith(".jpeg")
                ):  # [5377]
                    file_format = "jpg"  # [5378]
                    quality = 95  # [5379]
                else:  # [5380]
                    file_format = "jpg"  # [5381]
                    quality = 95  # [5382]
                    if not (
                        low_filename.endswith(".jpg") or low_filename.endswith(".jpeg")
                    ):  # [5383]
                        filename += ".jpg"  # [5384]

                if pixmap.save(filename, file_format, quality):  # [5385]
                    print(
                        f"Screenshot saved to: {filename} (Format: {file_format}, Quality: {quality})"
                    )  # [5386]
                else:  # [5387]
                    print(f"Error: Failed to save screenshot to {filename}.")  # [5388]
                    QMessageBox.warning(
                        self, "Save Error", f"Could not save screenshot to:\n{filename}"
                    )  # [5389]
            else:  # [5390]
                print("Screenshot cancelled.")  # [5391]

        except Exception as e:  # [5392]
            print(f"Error capturing or saving screenshot: {e}")  # [5393]
            traceback.print_exc()  # [5394]
            QMessageBox.critical(
                self,
                "Screenshot Error",
                f"An unexpected error occurred during screenshot:\n{e}",
            )  # [5395]

    def _perform_delayed_screenshot_and_exit(self, filename):  # [5396]
        """Performs a screenshot and exits loadimg mode after saving."""  # [5397]
        print(f"Performing delayed screenshot to: {filename}")  # [5398]
        screen = QGuiApplication.primaryScreen()  # [5399]
        shapes_cleared_after_save = False  # [5400]
        if screen:  # [5401]
            pixmap = screen.grabWindow(0)  # [5402]
            if not pixmap.isNull():  # [5403]
                if pixmap.save(filename, "jpg", 95):  # [5404]
                    print(f"View saved as JPG: {filename}")  # [5405]
                    self.background_pixmap = None  # [5406]
                    print("Background image cleared after saving.")  # [5407]
                    print("Clearing shapes after saving view.")  # [5408]
                    self.clear_scene(save_undo=False)  # [5409]
                    shapes_cleared_after_save = True  # [5410]
                else:  # [5411]
                    QMessageBox.warning(
                        self, "Save Error", f"Failed to save JPG image to:\n{filename}"
                    )  # [5412]
            else:  # [5413]
                QMessageBox.warning(
                    self, "Save Error", "Failed to grab screen content for saving."
                )  # [5414]
        else:  # [5415]
            QMessageBox.warning(
                self, "Save Error", "Could not access screen for saving."
            )  # [5416]

        self.exit_board_mode(
            ask_save=False, configure=True, skip_shape_clear_question=True
        )  # [5417]

    def show_text_dialog(
        self,
        pos_or_origin,
        shape_to_edit=None,
        initial_props=None,
        initial_rect=None,
        is_mpoint_label_style=False,
        is_angle_text_style_edit=False,
        is_angle_text_edit=False,
    ):  # [5418]
        """Displays the text dialog for editing or creating text shapes."""  # [5419]
        if shape_to_edit:  # [5420]
            shape_index = -1  # [5421]
            try:  # [5422]
                shape_index = self.shapes.index(shape_to_edit)  # [5423]
            except ValueError:  # [5424]
                print("Warning: Shape to edit not found in list.")  # [5425]
                return  # [5426]

            print(
                f"Editing text shape at index {shape_index} (is_dimension={shape_to_edit.is_dimension_part}, is_angle_display={shape_to_edit.text_properties.get('is_angle_display', False) if shape_to_edit.text_properties else False})"
            )  # [5427]
            current_props_copy = (
                deepcopy(initial_props) if initial_props else {}
            )  # [5428]

            if not current_props_copy:  # [5429]
                if (
                    shape_to_edit.is_dimension_part
                    and shape_to_edit.dimension_type == "text"
                ):  # [5430]
                    current_props_copy = deepcopy(
                        self.dimension_default_text_properties
                    )  # [5431]
                elif (
                    shape_to_edit.text_properties
                    and shape_to_edit.text_properties.get("is_angle_display", False)
                ):  # [5432]
                    current_props_copy = {  # [5433]
                        "font": "Arial",
                        "size": self.current_angle_tool_text_size,
                        "bold": False,
                        "italic": False,
                        "underline": False,
                        "strikeout": False,
                        "color": self.current_angle_tool_line_color.name(),
                        "background_color": None,
                        "alignment": "center",
                        "curve_angle": 0,
                        "is_angle_display": True,
                        "text": shape_to_edit.text_properties.get("text", ""),  # [5434]
                    }  # [5435]
                elif self.edit_mode or self.board_mode:  # [5436]
                    current_props_copy = deepcopy(
                        self.board_default_text_properties
                    )  # [5437]
                elif self.temp_mode:  # [5438]
                    current_props_copy = deepcopy(
                        self.default_text_properties
                    )  # [5439]
                else:  # [5440]
                    current_props_copy = deepcopy(
                        self.default_text_properties
                    )  # [5441]

            current_props_copy.setdefault("curve_angle", 0)  # [5442]
            current_props_copy.setdefault("is_angle_display", False)  # [5443]

            dialog = TextInputDialog(
                self,
                existing_properties=current_props_copy,
                is_angle_text_edit=(
                    shape_to_edit.text_properties
                    and shape_to_edit.text_properties.get("is_angle_display", False)
                ),
            )  # [5444]
            original_shape_copy_for_undo = deepcopy(shape_to_edit)  # [5445]

            if dialog.exec():  # [5446]
                new_props = dialog.get_properties()  # [5447]
                text = new_props.get("text", "")  # [5448]

                if (
                    hasattr(dialog, "text_cleared") and dialog.text_cleared and not text
                ):  # [5449]
                    print(
                        f"Deleting text shape {shape_index} due to Clear+OK."
                    )  # [5450]
                    try:  # [5451]
                        shapes_to_delete = [shape_to_edit]  # [5452]
                        indices_to_delete = [shape_index]  # [5453]
                        copies_for_undo = [deepcopy(shape_to_edit)]  # [5454]
                        if (
                            shape_to_edit.is_dimension_part
                            and shape_to_edit.dimension_type == "text"
                        ) or (
                            shape_to_edit.text_properties
                            and shape_to_edit.text_properties.get("is_angle_display")
                        ):  # [5455]
                            undo_action = "delete"  # [5456]
                        elif shape_to_edit.group_id:  # [5457]
                            for i, s_item in enumerate(self.shapes):  # [5458]
                                if (
                                    s_item.group_id == shape_to_edit.group_id
                                    and s_item != shape_to_edit
                                ):  # [5459]
                                    if i not in indices_to_delete:  # [5460]
                                        indices_to_delete.append(i)  # [5461]
                                        shapes_to_delete.append(s_item)  # [5462]
                                        copies_for_undo.append(
                                            deepcopy(s_item)
                                        )  # [5463]
                            undo_action = "delete_group"  # [5464]
                        else:  # [5465]
                            undo_action = "delete"  # [5466]
                        self.save_state(
                            undo_action,  # [5467]
                            shapes_involved=copies_for_undo,  # [5468]
                            indices=sorted(indices_to_delete, reverse=False),
                        )  # [5469]

                        for index in indices_to_delete:  # [5470]
                            if 0 <= index < len(self.shapes):
                                self.shapes.pop(index)  # [5471]

                        selection_was_cleared = False  # [5472]
                        new_selection = []  # [5473]
                        for s_sel in self.selected_shapes:  # [5474]
                            if s_sel not in shapes_to_delete:
                                new_selection.append(s_sel)  # [5475]
                            else:
                                selection_was_cleared = True  # [5476]
                        self.selected_shapes = new_selection  # [5477]

                        if selection_was_cleared and self.show_angle_offset:  # [5478]
                            print(
                                "Text shape deleted (Clear+OK), recalculating angle offsets."
                            )  # [5479]
                            self.recalculate_and_update_angle_offsets()  # [5480]
                        else:
                            self.update()  # [5481]
                        self._configure_mode()  # [5482]
                        return  # [5483]
                    except Exception as e:
                        print(f"Error deleting shape: {e}")  # [5484]
                    return  # [5485]

                if (
                    shape_to_edit.is_dimension_part
                    and shape_to_edit.dimension_type == "text"
                ):  # [5486]
                    prev_dim_defaults = deepcopy(
                        self.dimension_default_text_properties
                    )  # [5487]
                    self.dimension_default_text_properties = deepcopy(
                        new_props
                    )  # [5488]
                    self.dimension_default_text_properties["text"] = ""  # [5489]
                    self.save_state(
                        "change_dimension_text_defaults",
                        previous_geometries={
                            "dimension_text_defaults": prev_dim_defaults
                        },
                    )  # [5490]
                    print("Updated DIMENSION text defaults.")  # [5491]
                elif (
                    shape_to_edit.text_properties
                    and shape_to_edit.text_properties.get("is_angle_display", False)
                ):  # [5492]
                    prev_angle_config = {  # [5493]
                        "color": deepcopy(self.current_angle_tool_line_color),  # [5494]
                        "textSize": self.current_angle_tool_text_size,  # [5495]
                    }  # [5496]
                    self.current_angle_tool_line_color = QColor(
                        new_props["color"]
                    )  # [5497]
                    self.current_angle_tool_text_size = new_props["size"]  # [5498]
                    self.save_state(
                        "change_angle_tool_config",
                        previous_geometries={"angle_tool_config": prev_angle_config},
                    )  # [5499]
                    self.angle_tool_config_changed.emit(
                        {  # [5500]
                            "color": self.current_angle_tool_line_color,  # [5501]
                            "textSize": self.current_angle_tool_text_size,  # [5502]
                            "showInner": self.current_angle_tool_show_inner,  # [5503]
                            "showOuter": self.current_angle_tool_show_outer,  # [5504]
                        }
                    )  # [5505]
                    print("Updated ANGLE tool text defaults (color/size).")  # [5506]
                elif (
                    not self.board_mode and not self.edit_mode and not self.temp_mode
                ):  # [5507]
                    self.default_text_properties = deepcopy(new_props)
                    self.default_text_properties["text"] = ""  # [5508]
                    self.defaults_changed.emit()  # [5509]
                elif self.board_mode or self.edit_mode:  # [5510]
                    prev_defaults_for_undo = deepcopy(
                        self.board_default_text_properties
                    )  # [5511]
                    self.board_default_text_properties = deepcopy(new_props)
                    self.board_default_text_properties["text"] = ""  # [5512]
                    self.save_state(
                        "change_board_text_defaults",
                        previous_geometries={
                            "board_text_defaults": prev_defaults_for_undo
                        },
                    )  # [5513]
                elif self.temp_mode:  # [5514]
                    print(
                        "Not updating defaults when editing text in TEMP mode."
                    )  # [5515]

                if text:  # [5516]
                    shape_to_edit.text_properties = new_props  # [5517]
                    font = QFont(
                        new_props.get("font", "Arial"), new_props.get("size", 12)
                    )
                    font.setBold(new_props.get("bold", False))
                    font.setItalic(new_props.get("italic", False))
                    font.setUnderline(new_props.get("underline", False))
                    font.setStrikeOut(new_props.get("strikeout", False))  # [5518]
                    metrics = QFontMetrics(font)  # [5519]

                    flags = Qt.TextFlag.TextWordWrap  # [5520]
                    align_str = new_props.get("alignment", "left")  # [5521]
                    align_flag = {
                        "left": Qt.AlignmentFlag.AlignLeft,
                        "center": Qt.AlignmentFlag.AlignCenter,
                        "right": Qt.AlignmentFlag.AlignRight,
                        "justify": Qt.AlignmentFlag.AlignJustify,
                    }.get(align_str, Qt.AlignmentFlag.AlignLeft)  # [5522]
                    flags |= align_flag | Qt.AlignmentFlag.AlignVCenter  # [5523]
                    bounding_rect_text = metrics.boundingRect(
                        QRect(0, 0, 10000, 10000), int(flags), text
                    )  # [5524]

                    current_geom = shape_to_edit.geometry  # [5525]
                    new_width = max(bounding_rect_text.width() + 10, 30)
                    new_height = max(bounding_rect_text.height() + 6, 20)  # [5526]
                    shape_to_edit.geometry = QRectF(
                        current_geom.topLeft(), QSizeF(new_width, new_height)
                    )  # [5527]

                    if (
                        shape_to_edit.is_label
                        and shape_to_edit.group_id
                        and not (
                            shape_to_edit.text_properties
                            and shape_to_edit.text_properties.get("is_angle_display")
                        )
                    ):  # [5528]
                        marker_shape = next(
                            (
                                s
                                for s in self.shapes
                                if s.group_id == shape_to_edit.group_id
                                and s.is_mpoint_marker
                            ),
                            None,
                        )  # [5529]
                        if marker_shape:  # [5530]
                            self._position_mpoint_label(
                                shape_to_edit,
                                marker_shape.geometry,
                                self.mpoint_settings["label_pos"],
                            )  # [5531]
                        else:
                            print(
                                f"Warning: Could not find marker for label {shape_to_edit.group_id} during edit."
                            )  # [5532]
                    elif (
                        shape_to_edit.is_dimension_part
                        and shape_to_edit.dimension_type == "text"
                        and shape_to_edit.group_id
                    ):  # [5533]
                        self.update_dimension_text_position(
                            shape_to_edit.group_id
                        )  # [5534]
                    elif (
                        shape_to_edit.text_properties
                        and shape_to_edit.text_properties.get("is_angle_display")
                        and shape_to_edit.group_id
                    ):  # [5535]
                        self.update_angle_marker_text(
                            shape_to_edit.group_id, update_text_only=True
                        )  # [5536]

                    self.save_state(
                        "edit_text",  # [5537]
                        shapes_involved=[shape_to_edit],  # [5538]
                        previous_geometries={
                            shape_index: original_shape_copy_for_undo
                        },  # [5539]
                        indices=[shape_index],
                    )  # [5540]
                    self._configure_mode()
                    self.update()  # [5541]

                    if (
                        not self.board_mode
                        and not self.edit_mode
                        and not self.temp_mode
                    ):  # [5542]
                        self.set_drawing_mode(False)  # [5543]
                else:  # [5544]
                    print(
                        "Text edit resulted in empty text. Defaults possibly saved, shape not changed."
                    )  # [5545]
                    self.update()  # [5546]
            else:
                print("Text edit dialog cancelled")  # [5547]

        else:  # [5548]
            origin_pos = (
                pos_or_origin if isinstance(pos_or_origin, QPointF) else QPointF(0, 0)
            )  # [5549]
            if self.current_tool == "dimension":  # [5550]
                current_props_copy = deepcopy(
                    self.dimension_default_text_properties
                )  # [5551]
            elif is_angle_text_style_edit:  # [5552]
                current_props_copy = {  # [5553]
                    "font": "Arial",
                    "size": self.current_angle_tool_text_size,
                    "bold": False,
                    "italic": False,  # [5554]
                    "underline": False,
                    "strikeout": False,
                    "color": self.current_angle_tool_line_color.name(),  # [5555]
                    "background_color": None,
                    "alignment": "center",
                    "curve_angle": 0,  # [5556]
                    "is_angle_display": True,  # [5557]
                }  # [5558]
            else:  # [5559]
                current_props_copy = (
                    deepcopy(initial_props)
                    if initial_props
                    else deepcopy(self.default_text_properties)
                )  # [5560]

            current_props_copy.setdefault("curve_angle", 0)  # [5561]
            current_props_copy.setdefault("is_angle_display", False)  # [5562]

            dialog = TextInputDialog(
                self,
                existing_properties=current_props_copy,
                is_mpoint_label_style=is_mpoint_label_style,
                is_angle_text_style_edit=is_angle_text_style_edit,
            )  # [5563]
            if is_mpoint_label_style:  # [5564]
                dialog.setWindowTitle("MPoint Label Style")  # [5565]
            elif is_angle_text_style_edit:  # [5566]
                dialog.setWindowTitle("Angle Text Style")  # [5567]

            if dialog.exec():  # [5568]
                if hasattr(dialog, "text_cleared") and dialog.text_cleared:
                    print("Text creation cancelled via Clear+OK.")
                    return  # [5569]

                props = dialog.get_properties()  # [5570]
                text = props.get("text", "")  # [5571]

                if is_mpoint_label_style:  # [5572]
                    style_props = {
                        k: v for k, v in props.items() if k != "text"
                    }  # [5573]
                    self.mpoint_label_text_properties = style_props  # [5574]
                    print(f"MPoint label style updated: {style_props}")  # [5575]
                    self.overlay.save_mpoint_label_style()  # [5576]
                    return  # [5577]
                elif is_angle_text_style_edit:  # [5578]
                    style_props = {
                        k: v for k, v in props.items() if k != "text"
                    }  # [5579]
                    self.current_angle_tool_line_color = QColor(
                        style_props.get(
                            "color", self.current_angle_tool_line_color.name()
                        )
                    )  # [5580]
                    self.current_angle_tool_text_size = style_props.get(
                        "size", self.current_angle_tool_text_size
                    )  # [5581]
                    print(
                        f"Angle text style updated: Color={self.current_angle_tool_line_color.name()}, Size={self.current_angle_tool_text_size}"
                    )  # [5582]
                    self.save_angle_tool_settings()  # [5583]
                    self.angle_tool_config_changed.emit(
                        {  # [5584]
                            "color": self.current_angle_tool_line_color,  # [5585]
                            "textSize": self.current_angle_tool_text_size,  # [5586]
                            "showInner": self.current_angle_tool_show_inner,  # [5587]
                            "showOuter": self.current_angle_tool_show_outer,  # [5588]
                        }
                    )  # [5589]
                    return  # [5590]

                if self.current_tool == "dimension":  # [5591]
                    pass  # [5592]
                elif (
                    not self.board_mode and not self.edit_mode and not self.temp_mode
                ):  # [5593]
                    self.default_text_properties = deepcopy(props)
                    self.default_text_properties["text"] = ""  # [5594]
                    self.defaults_changed.emit()  # [5595]
                elif self.board_mode or self.edit_mode:  # [5596]
                    prev_defaults_for_undo = deepcopy(
                        self.board_default_text_properties
                    )  # [5597]
                    self.board_default_text_properties = deepcopy(props)
                    self.board_default_text_properties["text"] = ""  # [5598]
                    self.save_state(
                        "change_board_text_defaults",
                        previous_geometries={
                            "board_text_defaults": prev_defaults_for_undo
                        },
                    )  # [5599]
                elif self.temp_mode:  # [5600]
                    print(
                        "Not updating defaults when creating text in TEMP mode."
                    )  # [5601]

                if text:  # [5602]
                    font = QFont(props.get("font", "Arial"), props.get("size", 12))
                    font.setBold(props.get("bold", False))
                    font.setItalic(props.get("italic", False))
                    font.setUnderline(props.get("underline", False))
                    font.setStrikeOut(props.get("strikeout", False))  # [5603]
                    metrics = QFontMetrics(font)  # [5604]

                    flags = Qt.TextFlag.TextWordWrap  # [5605]
                    align_str = props.get("alignment", "left")  # [5606]
                    align_flag = {
                        "left": Qt.AlignmentFlag.AlignLeft,
                        "center": Qt.AlignmentFlag.AlignCenter,
                        "right": Qt.AlignmentFlag.AlignRight,
                        "justify": Qt.AlignmentFlag.AlignJustify,
                    }.get(align_str, Qt.AlignmentFlag.AlignLeft)  # [5607]
                    flags |= align_flag | Qt.AlignmentFlag.AlignVCenter  # [5608]
                    bounding_rect_text = metrics.boundingRect(
                        QRect(0, 0, 10000, 10000), int(flags), text
                    )  # [5609]

                    text_width = max(bounding_rect_text.width() + 10, 50)  # [5610]
                    text_height = max(bounding_rect_text.height() + 6, 20)  # [5611]

                    final_rect = (
                        initial_rect
                        if initial_rect and initial_rect.isValid()
                        else QRectF(origin_pos, QSizeF(text_width, text_height))
                    )  # [5612]
                    final_rect.setSize(QSizeF(text_width, text_height))  # [5613]

                    text_color = QColor(props["color"])  # [5614]
                    if not text_color.isValid():
                        text_color = Qt.GlobalColor.black  # [5615]
                    text_alpha = self.current_alpha  # [5616]

                    text_shape = Shape(
                        "text",
                        final_rect,
                        text_color,
                        filled=False,
                        alpha=text_alpha,
                        line_thickness=0,
                        line_style=Qt.PenStyle.SolidLine,
                        text_properties=props,
                        gradient_properties=None,
                    )  # [5617]
                    self.shapes.append(text_shape)  # [5618]
                    self.save_state("draw", indices=[len(self.shapes) - 1])  # [5619]

                    if self.temp_mode:  # [5620]
                        self.schedule_shape_removal(text_shape)  # [5621]

                    self._configure_mode()
                    self.update()  # [5622]

                    if (
                        not self.board_mode
                        and not self.edit_mode
                        and not self.temp_mode
                    ):  # [5623]
                        self.set_drawing_mode(False)  # [5624]
                else:  # [5625]
                    print(
                        "Text input empty, shape not created (defaults possibly saved)."
                    )  # [5626]
            else:
                print("Text dialog cancelled")  # [5627]

    def save_scene(self, filename):  # [5628]
        """Saves the current scene (list of shapes) to a JSON file."""  # [5629]
        print(f"Saving scene to {filename}")  # [5630]
        try:  # [5631]
            mpoint_save_data = {  # [5632]
                "settings": self.mpoint_settings,  # [5633]
                "next_label": self.next_mpoint_label,  # [5634]
            }  # [5635]
            dimension_text_defaults_save = (
                self.dimension_default_text_properties
            )  # [5636]
            dimension_preview_line_color_save = self.dimension_preview_line_color.name(
                QColor.NameFormat.HexArgb
            )  # [5637]
            dimension_preview_color_explicitly_set_save = (
                self.dimension_preview_color_explicitly_set
            )  # [5638]
            angle_tool_settings_save = {  # [5639]
                "lineColor": self.current_angle_tool_line_color.name(
                    QColor.NameFormat.HexArgb
                ),  # [5640]
                "textSize": self.current_angle_tool_text_size,  # [5641]
                "showInner": self.current_angle_tool_show_inner,  # [5642]
                "showOuter": self.current_angle_tool_show_outer,  # [5643]
            }  # [5644]
            hatch_fill_settings_save = {  # [5645]
                "style": self.current_hatch_style,  # [5646]
                "color": self.current_hatch_color.name(
                    QColor.NameFormat.HexArgb
                ),  # [5647]
                "thickness": self.current_hatch_thickness,  # [5648]
            }  # [5649]
            division_point_settings_save = {  # [5650]
                "color": self.division_point_color.name(
                    QColor.NameFormat.HexArgb
                ),  # [5651]
                "size": self.division_point_size,  # [5652]
            }  # [5653]

            scene_data = []  # [5654]
            for i, shape in enumerate(self.shapes):  # [5655]
                if shape:  # [5656]
                    try:  # [5657]
                        shape_dict = shape.to_dict()  # [5658]
                        if shape_dict:  # [5659]
                            scene_data.append(shape_dict)  # [5660]
                        else:  # [5661]
                            print(
                                f"Warning: Failed to serialize shape {i} (returned None)"
                            )  # [5662]
                    except Exception as e:
                        print(f"Error serializing shape {i}: {e}")  # [5663]
                else:
                    print(
                        f"Warning: Found None shape at index {i} during save."
                    )  # [5664]

            full_data = {  # [5665]
                "shapes": scene_data,  # [5666]
                "mpoint_data": mpoint_save_data,  # [5667]
                "dimension_text_defaults": dimension_text_defaults_save,  # [5668]
                "dimension_preview_line_color": dimension_preview_line_color_save,  # [5669]
                "dimension_preview_color_explicitly_set": dimension_preview_color_explicitly_set_save,  # [5670]
                "angle_tool_settings": angle_tool_settings_save,  # [5671]
                "hatch_fill_settings": hatch_fill_settings_save,  # [5672]
                "division_point_settings": division_point_settings_save,  # [5673]
            }  # [5674]
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(full_data, f, indent=4)  # [5675]
            print(f"Scene saved successfully ({len(scene_data)} shapes).")  # [5676]
        except Exception as e:
            print(f"Error saving scene: {e}")
            traceback.print_exc()  # [5677]

    def load_scene(self, filename, join=False, animation_tag=None):  # [5678]
        """Loads a scene from a JSON file, optionally joining with the current scene."""  # [5679]
        loaded_count = 0  # [5680]
        try:  # [5681]
            with open(filename, "r", encoding="utf-8") as f:
                full_data = json.load(f)  # [5682]

            scene_data = []  # [5683]
            mpoint_load_data = None  # [5684]
            dimension_text_defaults_load = None  # [5685]
            dimension_preview_line_color_load_str = None  # [5686]
            dimension_preview_color_explicitly_set_load = None  # [5687]
            angle_tool_settings_load = None  # [5688]
            hatch_fill_settings_load = None  # [5689]
            division_point_settings_load = None  # [5690]

            if isinstance(full_data, list):  # [5691]
                print("Loading old scene format (list of shapes).")  # [5692]
                scene_data = full_data  # [5693]
            elif isinstance(full_data, dict):  # [5694]
                scene_data = full_data.get("shapes", [])  # [5695]
                mpoint_load_data = full_data.get("mpoint_data")  # [5696]
                dimension_text_defaults_load = full_data.get(
                    "dimension_text_defaults"
                )  # [5697]
                dimension_preview_line_color_load_str = full_data.get(
                    "dimension_preview_line_color"
                )  # [5698]
                dimension_preview_color_explicitly_set_load = full_data.get(
                    "dimension_preview_color_explicitly_set"
                )  # [5699]
                angle_tool_settings_load = full_data.get(
                    "angle_tool_settings"
                )  # [5700]
                hatch_fill_settings_load = full_data.get(
                    "hatch_fill_settings"
                )  # [5701]
                division_point_settings_load = full_data.get(
                    "division_point_settings"
                )  # [5702]
                if not isinstance(scene_data, list):  # [5703]
                    print(
                        f"Error: 'shapes' key in loaded data is not a list. Aborting load for file {filename}."
                    )  # [5704]
                    return 0  # [5705]
            else:  # [5706]
                print(
                    f"Error: Loaded data is not a list or dictionary. Aborting load for file {filename}."
                )  # [5707]
                return 0  # [5708]

            if not join:  # [5709]
                print("Replacing current scene.")  # [5710]
                self.save_state(
                    "load",
                    all_shapes_before=deepcopy(self.shapes),
                    selected_shapes_before=deepcopy(self.selected_shapes),
                )  # [5711]
                self.shapes.clear()
                self.selected_shapes.clear()
                self.current_drawing_shape = None  # [5712]
                self.polygon_points.clear()
                self.angle_points.clear()
                self.brush_points.clear()
                self.spline_points.clear()  # [5713]
                self.show_angle_offset = False  # [5714]
                self.angle_offsets.clear()  # [5715]
                if self.input_mode:  # [5716]
                    print(
                        f"Cancelling input mode '{self.input_mode}' due to load scene."
                    )  # [5717]
                    self.input_mode = None  # [5718]
                self.dimension_points.clear()  # [5719]
                self.dimension_preview_shapes.clear()  # [5720]
                self.angle_points.clear()  # [5721]
                self.active_angle_shape_for_point_drag = None  # [5722]
                self.active_angle_point_handle = None  # [5723]

                if mpoint_load_data:  # [5724]
                    self.mpoint_settings = mpoint_load_data.get(
                        "settings", self.mpoint_settings
                    )  # [5725]
                    self.next_mpoint_label = mpoint_load_data.get(
                        "next_label", self.next_mpoint_label
                    )  # [5726]
                    if self.control_panel:  # [5727]
                        self.control_panel.update_mpoint_controls(
                            self.mpoint_settings
                        )  # [5728]
                    print(
                        f"Loaded MPoint settings: Size={self.mpoint_settings.get('size')}, Label={self.mpoint_settings.get('label_enabled')}, Next='{self.next_mpoint_label}'"
                    )  # [5729]
                else:  # [5730]
                    print("No MPoint data found in save file.")  # [5731]
                    self._reset_next_mpoint_label()  # [5732]
                    self.mpoint_settings = {  # [5733]
                        "style": "circle",
                        "size": 10,
                        "label_enabled": False,
                        "label_pos": "Up",
                        "label_start": "1",  # [5734]
                    }  # [5735]
                    if self.control_panel:  # [5736]
                        self.control_panel.update_mpoint_controls(
                            self.mpoint_settings
                        )  # [5737]
                if dimension_text_defaults_load:  # [5738]
                    self.dimension_default_text_properties = (
                        dimension_text_defaults_load  # [5739]
                    )
                    print("Loaded dimension text defaults from scene file.")  # [5740]
                else:  # [5741]
                    self.dimension_default_text_properties = {  # [5742]
                        "text": "",
                        "font": "Arial",
                        "size": 10,
                        "bold": False,
                        "italic": False,  # [5743]
                        "underline": False,
                        "strikeout": False,
                        "color": "#000000",  # [5744]
                        "background_color": None,
                        "alignment": "center",
                        "curve_angle": 0,  # [5745]
                        "dimension_suffix": "",  # [5746]
                    }  # [5747]
                    print(
                        "No dimension text defaults found in scene file, reset to defaults."
                    )  # [5748]

                if dimension_preview_line_color_load_str:  # [5749]
                    loaded_preview_color = QColor(
                        dimension_preview_line_color_load_str
                    )  # [5750]
                    if loaded_preview_color.isValid():  # [5751]
                        self.dimension_preview_line_color = (
                            loaded_preview_color  # [5752]
                        )
                        if (
                            dimension_preview_color_explicitly_set_load is not None
                        ):  # [5753]
                            self.dimension_preview_color_explicitly_set = (
                                dimension_preview_color_explicitly_set_load  # [5754]
                            )
                        else:  # [5755]
                            default_preview_color = QColor(self.current_pen_color)
                            default_preview_color.setAlpha(100)  # [5756]
                            self.dimension_preview_color_explicitly_set = (
                                self.dimension_preview_line_color
                                != default_preview_color
                            )  # [5757]
                    else:  # [5758]
                        self.dimension_preview_line_color = QColor(
                            0, 255, 255, 100
                        )  # [5759]
                        self.dimension_preview_color_explicitly_set = False  # [5760]
                        print(
                            "Warning: Invalid dimension preview line color in scene file, using default."
                        )  # [5761]
                else:  # [5762]
                    self.dimension_preview_line_color = QColor(
                        0, 255, 255, 100
                    )  # [5763]
                    self.dimension_preview_color_explicitly_set = False  # [5764]
                self.dimension_preview_color_changed.emit(
                    self.dimension_preview_line_color
                )  # [5765]

                if angle_tool_settings_load:  # [5766]
                    color_str = angle_tool_settings_load.get(
                        "lineColor",
                        self.current_angle_tool_line_color.name(
                            QColor.NameFormat.HexArgb
                        ),
                    )  # [5767]
                    loaded_color = QColor(color_str)  # [5768]
                    self.current_angle_tool_line_color = (
                        loaded_color if loaded_color.isValid() else QColor(255, 165, 0)
                    )  # [5769]
                    self.current_angle_tool_text_size = angle_tool_settings_load.get(
                        "textSize", self.current_angle_tool_text_size
                    )  # [5770]
                    self.current_angle_tool_show_inner = angle_tool_settings_load.get(
                        "showInner", self.current_angle_tool_show_inner
                    )  # [5771]
                    self.current_angle_tool_show_outer = angle_tool_settings_load.get(
                        "showOuter", self.current_angle_tool_show_outer
                    )  # [5772]
                    self.angle_tool_config_changed.emit(
                        angle_tool_settings_load
                    )  # [5773]
                    print("Loaded angle tool settings from scene file.")  # [5774]
                else:  # [5775]
                    self.current_angle_tool_line_color = QColor(255, 165, 0)  # [5776]
                    self.current_angle_tool_text_size = 10  # [5777]
                    self.current_angle_tool_show_inner = True  # [5778]
                    self.current_angle_tool_show_outer = False  # [5779]
                    self.angle_tool_config_changed.emit(
                        {  # [5780]
                            "color": self.current_angle_tool_line_color,  # [5781]
                            "textSize": self.current_angle_tool_text_size,  # [5782]
                            "showInner": self.current_angle_tool_show_inner,  # [5783]
                            "showOuter": self.current_angle_tool_show_outer,  # [5784]
                        }
                    )  # [5785]
                    print("No angle tool settings found, reset to defaults.")  # [5786]

                if hatch_fill_settings_load:  # [5787]
                    try:  # [5788]
                        style_list = hatch_fill_settings_load.get("style", [])  # [5789]
                        self.current_hatch_style = (
                            style_list if isinstance(style_list, list) else []
                        )  # [5790]
                    except:
                        self.current_hatch_style = []  # [5791]

                    color_str = hatch_fill_settings_load.get(
                        "color",
                        self.current_hatch_color.name(QColor.NameFormat.HexArgb),
                    )  # [5792]
                    loaded_color = QColor(color_str)  # [5793]
                    self.current_hatch_color = (
                        loaded_color
                        if loaded_color.isValid()
                        else QColor(128, 128, 128)
                    )  # [5794]
                    self.current_hatch_thickness = hatch_fill_settings_load.get(
                        "thickness", self.current_hatch_thickness
                    )  # [5795]
                    if self.control_panel:
                        self.control_panel.update_hatch_fill_controls()  # [5796]
                    print("Loaded hatch fill settings from scene file.")  # [5797]
                else:  # [5798]
                    self.current_hatch_style = []  # [5799]
                    self.current_hatch_color = QColor(128, 128, 128)  # [5800]
                    self.current_hatch_thickness = 1  # [5801]
                    if self.control_panel:
                        self.control_panel.update_hatch_fill_controls()  # [5802]
                    print("No hatch fill settings found, reset to defaults.")  # [5803]

                if division_point_settings_load:  # [5804]
                    color_str = division_point_settings_load.get(
                        "color",
                        QColor(Qt.GlobalColor.yellow).name(QColor.NameFormat.HexArgb),
                    )  # [5805]
                    loaded_color = QColor(color_str)  # [5806]
                    self.division_point_color = (
                        loaded_color
                        if loaded_color.isValid()
                        else QColor(Qt.GlobalColor.yellow)
                    )  # [5807]
                    self.division_point_size = division_point_settings_load.get(
                        "size", 5.0
                    )  # [5808]
                    print("Loaded division point settings from scene file.")  # [5809]
                else:  # [5810]
                    self.division_point_color = QColor(Qt.GlobalColor.yellow)  # [5811]
                    self.division_point_size = 5.0  # [5812]
                    print(
                        "No division point settings found, reset to defaults."
                    )  # [5813]
                self.division_point_color_changed.emit(
                    self.division_point_color
                )  # [5814]
                self.division_point_size_changed.emit(
                    self.division_point_size
                )  # [5815]

                self.background_pixmap = None  # [5816]
            else:  # [5817]
                print(
                    f"Joining loaded scene from {filename} with current scene."
                )  # [5818]
                self.save_state("load_join", previous_geometries=0)  # [5819]
                pass  # [5820]

            loaded_shapes = []  # [5821]
            for i, shape_data in enumerate(scene_data):  # [5822]
                if isinstance(shape_data, dict):  # [5823]
                    shape = Shape.from_dict(shape_data)  # [5824]
                    if shape:  # [5825]
                        if animation_tag:  # [5826]
                            shape.animation_tag = animation_tag  # [5827]
                        loaded_shapes.append(shape)  # [5828]
                    else:
                        print(
                            f"Warning: Failed to load shape {i} from dict in {filename}: {shape_data}"
                        )  # [5829]
                else:
                    print(
                        f"Warning: Invalid shape data format (not a dict) at index {i} in {filename}: {shape_data}"
                    )  # [5830]

            if loaded_shapes:  # [5831]
                start_index = len(self.shapes)  # [5832]
                self.shapes.extend(loaded_shapes)  # [5833]
                loaded_count = len(loaded_shapes)  # [5834]
                if join and self.undo_stack:  # [5835]
                    if self.undo_stack[-1]["action"] == "load_join":  # [5836]
                        self.undo_stack[-1]["action_data"]["load_join_count"] = (
                            loaded_count  # [5837]
                        )

                if self.temp_mode:  # [5838]
                    print(
                        f"Scheduling removal for {loaded_count} shapes loaded in TEMP mode."
                    )  # [5839]
                    for shape in loaded_shapes:  # [5840]
                        self.schedule_shape_removal(shape)  # [5841]

            self._configure_mode()  # [5842]

            if self.show_angle_offset:  # [5843]
                print("Load/Join finished, recalculating angle offsets.")  # [5844]
                self.recalculate_and_update_angle_offsets()  # [5845]
            else:
                self.update()  # [5846]

            print(
                f"Finished loading {filename}. Added {loaded_count} shapes. Total shapes now: {len(self.shapes)}."
            )  # [5847]
            return loaded_count  # [5848]

        except json.JSONDecodeError as e:  # [5849]
            print(f"Error decoding JSON from {filename}: {e}")  # [5850]
            QMessageBox.warning(
                self, "Load Error", f"Could not decode JSON file:\n{filename}\n\n{e}"
            )  # [5851]
            return 0  # [5852]
        except Exception as e:  # [5853]
            print(f"Error loading scene from {filename}: {e}")
            traceback.print_exc()  # [5854]
            QMessageBox.warning(
                self,
                "Load Error",
                f"An unexpected error occurred loading the scene from:\n{filename}\n\n{e}",
            )  # [5855]
            return 0  # [5856]

    def clear_scene(self, save_undo=True, keep_background_image=False):  # [5857]
        """Clears all shapes from the scene."""  # [5858]
        print("Clearing scene...")  # [5859]
        if self.shapes or (
            self.background_pixmap and not keep_background_image
        ):  # [5860]
            if save_undo:  # [5861]
                bg_pixmap_copy = (
                    QPixmap(self.background_pixmap)
                    if self.background_pixmap and not self.background_pixmap.isNull()
                    else None
                )  # [5862]
                state_data = {  # [5863]
                    "background_pixmap_before": bg_pixmap_copy,  # [5864]
                    "shapes_before_clear": deepcopy(self.shapes),  # [5865]
                }  # [5866]
                self.save_state(
                    "clear_scene",
                    previous_geometries=state_data,
                    all_shapes_before=deepcopy(self.shapes),
                )  # [5867]

            self.shapes.clear()
            self.current_drawing_shape = None
            self.selected_shapes.clear()  # [5868]
            self.polygon_points.clear()
            self.angle_points.clear()
            self.brush_points.clear()
            self.spline_points.clear()  # [5869]
            self.dragging = False
            self.resizing = False  # [5870]
            self.is_lasso_selecting = False  # [5871]
            self.show_angle_offset = False  # [5872]
            self.angle_offsets.clear()  # [5873]
            self._reset_next_mpoint_label()  # [5874]
            if self.input_mode:  # [5875]
                print(
                    f"Cancelling input mode '{self.input_mode}' due to clear scene."
                )  # [5876]
                self.input_mode = None  # [5877]
            self.dimension_points.clear()  # [5878]
            self.dimension_preview_shapes.clear()  # [5879]
            if not keep_background_image:  # [5880]
                self.background_pixmap = None  # [5881]
            self.active_angle_shape_for_point_drag = None  # [5882]
            self.active_angle_point_handle = None  # [5883]

            self._configure_mode()
            self.update()  # [5884]
            if keep_background_image:  # [5885]
                print("Scene cleared (shapes only, background image kept).")  # [5886]
            else:  # [5887]
                print("Scene cleared (including background image if any).")  # [5888]
        else:
            print("Scene already empty or only background image to keep.")  # [5889]

    def send_selection_to_back(self):  # [5890]
        """Moves selected shapes to the beginning of the shapes list (drawn first)."""  # [5891]
        if not self.selected_shapes:
            return  # [5892]

        selected_group_ids = {
            s.group_id for s in self.selected_shapes if s.group_id
        }  # [5893]
        shapes_to_move = set(self.selected_shapes)  # [5894]
        for s in self.shapes:  # [5895]
            if s.group_id in selected_group_ids:  # [5896]
                shapes_to_move.add(s)  # [5897]

        selected_in_current_order = [
            s for s in self.shapes if s in shapes_to_move
        ]  # [5898]

        if not selected_in_current_order:
            return  # [5899]

        self.save_state("send_to_back")  # [5900]

        new_shapes_list = [
            s for s in self.shapes if s not in selected_in_current_order
        ]  # [5901]

        self.shapes = selected_in_current_order + new_shapes_list  # [5902]

        print(f"Sent {len(selected_in_current_order)} shapes to back.")  # [5903]
        self.update()  # [5904]

    def recalculate_and_update_angle_offsets(self):  # [5905]
        """Clears, recalculates, and stores angle offsets for currently selected valid shapes."""  # [5906]
        self.angle_offsets.clear()  # [5907]
        if not self.show_angle_offset:  # [5908]
            self.update()  # [5909]
            return  # [5910]

        for shape in self.selected_shapes:  # [5911]
            if (
                shape.type in ["line", "arrow", "angle_marker", "spline"]
                and isinstance(shape.geometry, list)
                and len(shape.geometry) >= 2
            ):  # [5912]
                p1, p2 = shape.geometry[0], shape.geometry[1]  # [5913]
                if shape.type == "angle_marker" and len(shape.geometry) == 3:  # [5914]
                    p1, p2 = shape.geometry[1], shape.geometry[2]  # [5915]
                elif shape.type == "spline" and len(shape.geometry) >= 4:  # [5916]
                    p2 = shape.geometry[3]  # [5917]
                elif shape.type == "spline" and len(shape.geometry) >= 2:  # [5918]
                    p2 = shape.geometry[1]  # [5919]

                if not isinstance(p1, QPointF) or not isinstance(p2, QPointF):  # [5920]
                    continue  # [5921]

                delta = p2 - p1  # [5922]
                if delta.manhattanLength() < 1e-6:  # [5923]
                    continue  # [5924]

                delta_x = delta.x()  # [5925]
                delta_y = delta.y()  # [5926]

                base_angle = math.degrees(math.atan2(delta_x, -delta_y))  # [5927]
                rotation_angle = shape.rotation  # [5928]
                final_angle = (base_angle + rotation_angle) % 360.0  # [5929]
                self.angle_offsets[shape] = final_angle  # [5930]
        self.update()  # [5931]

    @Slot()  # [5932]
    def toggle_shapes_visibility(self):  # [5933]
        """Toggles the visibility of all drawn shapes."""  # [5934]
        self.shapes_visible = not self.shapes_visible  # [5935]
        print(f"Shapes visibility toggled to: {self.shapes_visible}")  # [5936]
        self.save_state("toggle_visibility", previous_geometries="shapes")  # [5937]
        for shape in self.shapes:  # [5938]
            shape.visible = self.shapes_visible  # [5939]
        self.shapes_visibility_changed.emit(self.shapes_visible)  # [5940]
        self.update()  # [5941]

    @Slot()  # [5942]
    def toggle_mpoint_label_visibility(self):  # [5943]
        """Toggles the visibility of MPoint labels."""  # [5944]
        self.mpoint_label_visible = not self.mpoint_label_visible  # [5945]
        print(
            f"MPoint label visibility toggled to: {self.mpoint_label_visible}"
        )  # [5946]
        self.save_state("toggle_visibility", previous_geometries="labels")  # [5947]
        for shape in self.shapes:  # [5948]
            if shape.is_label and not (
                shape.text_properties and shape.text_properties.get("is_angle_display")
            ):  # [5949]
                shape.visible = self.mpoint_label_visible  # [5950]
        self.update()  # [5951]

    @Slot()  # [5952]
    def toggle_mpoint_marker_visibility(self):  # [5953]
        """Toggles the visibility of MPoint markers."""  # [5954]
        self.mpoint_marker_visible = not self.mpoint_marker_visible  # [5955]
        print(
            f"MPoint marker visibility toggled to: {self.mpoint_marker_visible}"
        )  # [5956]
        self.save_state("toggle_visibility", previous_geometries="markers")  # [5957]
        for shape in self.shapes:  # [5958]
            if shape.is_mpoint_marker:  # [5959]
                shape.visible = self.mpoint_marker_visible  # [5960]
        self.update()  # [5961]

    @Slot()  # [5962]
    def toggle_mpoint_group_visibility(self):  # [5963]
        """Toggles the visibility of MPoint markers and labels together."""  # [5964]
        new_visibility = not self.mpoint_marker_visible  # [5965]
        self.mpoint_label_visible = new_visibility  # [5966]
        self.mpoint_marker_visible = new_visibility  # [5967]
        print(f"MPoint group visibility toggled to: {new_visibility}")  # [5968]
        self.save_state("toggle_visibility", previous_geometries="all")  # [5969]
        for shape in self.shapes:  # [5970]
            if (
                shape.is_label
                and not (
                    shape.text_properties
                    and shape.text_properties.get("is_angle_display")
                )
            ) or shape.is_mpoint_marker:  # [5971]
                shape.visible = new_visibility  # [5972]
        self.update()  # [5973]

    @Slot(dict)  # [5974]
    def update_mpoint_settings(self, settings):
        """Updates MPoint settings from the control panel."""
        if "label_start" in settings and settings[
            "label_start"
        ] != self.mpoint_settings.get("label_start"):
            self.next_mpoint_label = settings.get("label_start", "1")
            print(f"MPoint next label reset to: {self.next_mpoint_label}")
        self.mpoint_settings.update(settings)
        print(f"MPoint settings updated: {self.mpoint_settings}")
        self.update()  # Added

    def _generate_next_label(self):
        """Generates the next label based on the current self.next_mpoint_label."""
        current_label = self.next_mpoint_label  # [5975]
        base_part = ""  # [5976]
        num_part_str = ""  # [5977]

        match = re.match(r"^(.*?)(\d+)$", current_label)  # [5978]
        if match:  # [5979]
            base_part = match.group(1)  # [5980]
            num_part_str = match.group(2)  # [5981]
        else:  # [5982]
            if current_label.isdigit():  # [5983]
                num_part_str = current_label  # [5984]
            else:  # [5985]
                base_part = current_label  # [5986]

        next_label = current_label  # [5987]

        if num_part_str:  # [5988]
            try:  # [5989]
                num = int(num_part_str)  # [5990]
                next_label = f"{base_part}{num + 1}"  # [5991]
            except ValueError:
                pass  # [5992]
        elif (
            base_part and len(base_part) == 1 and "A" <= base_part.upper() <= "Z"
        ):  # [5993]
            char_code = ord(base_part.upper())  # [5994]
            if char_code < ord("Z"):  # [5995]
                next_label = chr(char_code + 1)  # [5996]
                if base_part.islower():
                    next_label = next_label.lower()  # [5997]
            else:  # [5998]
                next_label = base_part + "1"  # [5999]

        self.next_mpoint_label = next_label  # [6000]
        return current_label  # [6001]

    def _reset_next_mpoint_label(self):  # [6002]
        """Resets the internal next label counter based on current settings."""  # [6003]
        self.next_mpoint_label = self.mpoint_settings.get("label_start", "1")  # [6004]
        print(f"MPoint next label reset to: {self.next_mpoint_label}")  # [6005]

    def create_mpoint_with_label(self, center_pos):  # [6006]
        """Creates an MPoint marker and potentially a label shape."""  # [6007]
        marker_style = self.mpoint_settings.get("style", "circle")  # [6008]
        marker_size = self.mpoint_settings.get("size", 10)  # [6009]
        label_enabled = self.mpoint_settings.get("label_enabled", False)  # [6010]
        label_pos = self.mpoint_settings.get("label_pos", "Up")  # [6011]

        pen_color = self._get_current_mode_pen_color()  # [6012]
        alpha = self.current_alpha  # [6013]
        thickness = self.current_line_thickness  # [6014]
        fill = (
            self.control_panel.fill_check.isChecked() if self.control_panel else True
        )  # [6015]
        hatch_props = None  # [6016]
        if self.control_panel and self.control_panel.hatch_fill_enabled():  # [6017]
            hatch_props = {  # [6018]
                "style": self.control_panel.get_hatch_style(),  # [6019]
                "color": self.current_hatch_color,  # [6020]
                "thickness": self.current_hatch_thickness,  # [6021]
            }  # [6022]

        marker_type = "ellipse" if marker_style == "circle" else "rect"  # [6023]
        marker_geometry = QPointF(center_pos)  # [6024]

        group_id = f"group_{uuid.uuid4()}"  # [6025]
        shapes_in_group = []  # [6026]

        marker_shape = Shape(  # [6027]
            shape_type=marker_type,  # [6028]
            geometry=marker_geometry,  # [6029]
            color=pen_color,  # [6030]
            filled=fill,  # [6031]
            alpha=alpha,  # [6032]
            line_thickness=thickness,  # [6033]
            is_mpoint_marker=True,  # [6034]
            group_id=group_id,  # [6035]
            visible=self.mpoint_marker_visible,  # [6036]
            mpoint_size=marker_size,  # [6037]
            hatch_properties=hatch_props,  # [6038]
        )  # [6039]
        shapes_in_group.append(marker_shape)  # [6040]

        if label_enabled:  # [6041]
            label_text = self._generate_next_label()  # [6042]

            if not hasattr(self, "mpoint_label_text_properties"):  # [6043]
                self.load_mpoint_label_style()  # [6044]
            label_props = deepcopy(self.mpoint_label_text_properties)  # [6045]
            label_props["text"] = label_text  # [6046]
            label_props.setdefault("color", "#000000")  # [6047]
            label_props.setdefault("background_color", None)  # [6048]
            label_props.setdefault("alignment", "center")  # [6049]
            label_props.setdefault("curve_angle", 0)  # [6050]

            font = QFont(label_props.get("font", "Arial"), label_props.get("size", 12))
            font.setBold(label_props.get("bold", False))
            font.setItalic(label_props.get("italic", False))
            font.setUnderline(label_props.get("underline", False))
            font.setStrikeOut(label_props.get("strikeout", False))  # [6051]
            metrics = QFontMetrics(font)  # [6052]
            text_rect = metrics.boundingRect(label_text)  # [6053]
            label_width = max(text_rect.width() + 6, 10)  # [6054]
            label_height = max(text_rect.height() + 4, 10)  # [6055]
            label_geom = QRectF(
                center_pos - QPointF(label_width / 2, label_height / 2),
                QSizeF(label_width, label_height),
            )  # [6056]

            label_shape = Shape(  # [6057]
                shape_type="text",  # [6058]
                geometry=label_geom,  # [6059]
                color=QColor(label_props["color"]),  # [6060]
                filled=False,  # [6061]
                alpha=alpha,  # [6062]
                line_thickness=0,  # [6063]
                text_properties=label_props,  # [6064]
                is_label=True,  # [6065]
                group_id=group_id,  # [6066]
                visible=self.mpoint_label_visible,  # [6067]
            )  # [6068]
            self._position_mpoint_label(
                label_shape, marker_geometry, label_pos
            )  # [6069]
            shapes_in_group.append(label_shape)  # [6070]

        self.shapes.extend(shapes_in_group)  # [6071]
        self.save_state(
            "draw_group", indices=[self.shapes.index(s) for s in shapes_in_group]
        )  # [6072]

        if self.temp_mode:  # [6073]
            for shape in shapes_in_group:  # [6074]
                self.schedule_shape_removal(shape)  # [6075]

        self._configure_mode()  # [6076]
        self.update()  # [6077]

        if not self.board_mode and not self.edit_mode and not self.temp_mode:  # [6078]
            print("Auto-exiting DRAW mode after MPoint placement.")  # [6079]
            self.set_drawing_mode(False)  # [6080]

    def _position_mpoint_label(self, label_shape, marker_pos, position_str):  # [6081]
        """Calculates and sets the geometry for an MPoint label shape."""  # [6082]
        if not isinstance(label_shape.geometry, QRectF):
            return  # [6083]
        label_rect = label_shape.geometry  # [6084]
        label_width = label_rect.width()  # [6085]
        label_height = label_rect.height()  # [6086]
        marker_size = 0  # [6087]
        marker = next(
            (
                s
                for s in self.shapes
                if s.group_id == label_shape.group_id and s.is_mpoint_marker
            ),
            None,
        )  # [6088]
        if marker and marker.mpoint_size:  # [6089]
            marker_size = marker.mpoint_size  # [6090]
        else:  # [6091]
            marker_size = self.mpoint_settings.get("size", 10)  # [6092]

        offset_distance = 5 + (marker_size / 2.0)  # [6093]

        new_center = QPointF(marker_pos)  # [6094]
        if position_str == "Up":  # [6095]
            new_center.setY(
                marker_pos.y() - offset_distance - label_height / 2
            )  # [6096]
        elif position_str == "Down":  # [6097]
            new_center.setY(
                marker_pos.y() + offset_distance + label_height / 2
            )  # [6098]
        elif position_str == "Left":  # [6099]
            new_center.setX(
                marker_pos.x() - offset_distance - label_width / 2
            )  # [6100]
        elif position_str == "Right":  # [6101]
            new_center.setX(
                marker_pos.x() + offset_distance + label_width / 2
            )  # [6102]

        label_shape.geometry = QRectF(  # [6103]
            new_center.x() - label_width / 2,  # [6104]
            new_center.y() - label_height / 2,  # [6105]
            label_width,  # [6106]
            label_height,  # [6107]
        )  # [6108]

    def select_shapes_in_lasso(self, invert_selection=False):  # [6109]
        """# [6110]
        Selects shapes whose centers are inside (or outside, if invert_selection=True) # [6111]
        the finalized lasso polygon. # [6112]
        """  # [6113]
        if not self.is_lasso_selecting or len(self.polygon_points) < 3:  # [6114]
            print("Lasso select cancelled or not enough points.")  # [6115]
            self.is_lasso_selecting = False  # [6116]
            self.polygon_points = []  # [6117]
            return  # [6118]

        lasso_polygon = QPolygonF(self.polygon_points)  # [6119]
        newly_selected = []  # [6120]
        selected_before_lasso = deepcopy(self.selected_shapes)  # [6121]

        for shape in self.shapes:  # [6122]
            if not shape.visible:
                continue  # [6123]

            center = self._get_shape_center(shape)  # [6124]
            if not center.isNull():  # [6125]
                is_inside = lasso_polygon.containsPoint(
                    center, Qt.FillRule.OddEvenFill
                )  # [6126]
                should_select = (
                    is_inside if not invert_selection else not is_inside
                )  # [6127]

                if should_select:  # [6128]
                    if shape.group_id:  # [6129]
                        group_members = [
                            s
                            for s in self.shapes
                            if s.group_id == shape.group_id and s.visible
                        ]  # [6130]
                        for member in group_members:  # [6131]
                            if member not in newly_selected:  # [6132]
                                newly_selected.append(member)  # [6133]
                    elif shape not in newly_selected:  # [6134]
                        newly_selected.append(shape)  # [6135]

        if set(newly_selected) != set(self.selected_shapes):  # [6136]
            self.save_state(
                "lasso_select",
                selected_shapes_before=selected_before_lasso,
                selected_shapes_after=newly_selected,
            )  # [6137]
            self.selected_shapes = newly_selected  # [6138]
            print(
                f"Lasso selected {len(self.selected_shapes)} shapes (Inverted: {invert_selection})."
            )  # [6139]
            if self.show_angle_offset:  # [6140]
                self.recalculate_and_update_angle_offsets()  # [6141]
            else:  # [6142]
                self.update()  # [6143]
        else:  # [6144]
            print(
                f"Lasso selection (Inverted: {invert_selection}) did not change the current selection."
            )  # [6145]

        self.is_lasso_selecting = False  # [6146]
        self.polygon_points = []  # [6147]

    def _get_shape_center(self, shape):  # [6148]
        """Helper method to get the visual center of a shape for lasso testing."""  # [6149]
        if not shape or not shape.geometry:  # [6150]
            return QPointF()  # [6151]

        geo = shape.geometry  # [6152]
        center = QPointF()  # [6153]

        if shape.type == "arc":  # [6154]
            center = self._get_arc_visual_center(shape)  # [6155]
        elif isinstance(geo, QRectF) and geo.isValid():  # [6156]
            center = geo.center()  # [6157]
        elif isinstance(geo, QPointF):  # [6158]
            center = geo  # [6159]
        elif isinstance(geo, list):  # [6160]
            valid_points = [p for p in geo if isinstance(p, QPointF)]  # [6161]
            if valid_points:  # [6162]
                center = QPointF(
                    sum(p.x() for p in valid_points) / len(valid_points),  # [6163]
                    sum(p.y() for p in valid_points) / len(valid_points),
                )  # [6164]

        if shape.rotation != 0 and not center.isNull():  # [6165]
            rot_center = QPointF()  # [6166]
            if shape.type == "arc":  # [6167]
                rot_center = self._get_arc_visual_center(shape)  # [6168]
            elif (
                shape.type in ["line", "arrow"]
                and isinstance(geo, list)
                and len(geo) > 0
                and isinstance(geo[0], QPointF)
            ):  # [6169]
                rot_center = geo[0]  # [6170]
            elif (
                shape.type == "angle_marker" and isinstance(geo, list) and len(geo) == 3
            ):  # [6171]
                rot_center = geo[1]  # [6172]
            elif isinstance(geo, QRectF):
                rot_center = geo.center()  # [6173]
            elif isinstance(geo, QPointF):
                rot_center = geo  # [6174]
            elif isinstance(geo, list):  # [6175]
                valid_points_rot = [p for p in geo if isinstance(p, QPointF)]  # [6176]
                if valid_points_rot:  # [6177]
                    rot_center = QPointF(
                        sum(p.x() for p in valid_points_rot)
                        / len(valid_points_rot),  # [6178]
                        sum(p.y() for p in valid_points_rot) / len(valid_points_rot),
                    )  # [6179]

            if not rot_center.isNull():  # [6180]
                transform = (
                    QTransform()
                    .translate(rot_center.x(), rot_center.y())
                    .rotate(shape.rotation)
                    .translate(-rot_center.x(), -rot_center.y())
                )  # [6181]
                center = transform.map(center)  # [6182]

        return center  # [6183]

    @Slot()  # [6184]
    def select_all_shapes(self):  # [6185]
        """Selects all visible shapes."""  # [6186]
        print("Selecting all visible shapes (Ctrl+A).")  # [6187]
        new_selection = [shape for shape in self.shapes if shape.visible]  # [6188]
        if set(new_selection) != set(self.selected_shapes):  # [6189]
            self.save_state(
                "select_all",
                selected_shapes_before=deepcopy(self.selected_shapes),
                selected_shapes_after=new_selection,
            )  # [6190]
            self.selected_shapes = new_selection  # [6191]
            if self.show_angle_offset:  # [6192]
                self.recalculate_and_update_angle_offsets()  # [6193]
            else:  # [6194]
                self.update()  # [6195]
        else:  # [6196]
            print("All visible shapes already selected.")  # [6197]

    @Slot(str)  # [6198]
    def set_background_image(self, filepath):  # [6199]
        """Loads an image file to be used as background."""  # [6200]
        if not filepath:  # [6201]
            self.background_pixmap = None  # [6202]
            print("Background image cleared.")  # [6203]
            self.update()  # [6204]
            return  # [6205]

        pixmap = QPixmap(filepath)  # [6206]
        if pixmap.isNull():  # [6207]
            print(f"Error loading background image: {filepath}")  # [6208]
            QMessageBox.warning(
                self, "Image Load Error", f"Could not load image file:\n{filepath}"
            )  # [6209]
            self.background_pixmap = None  # [6210]
        else:  # [6211]
            self.background_pixmap = pixmap  # [6212]
            print(f"Background image loaded: {filepath}")  # [6213]
            self._indicator_state_before_image_load = self.show_tool_text  # [6214]
            self._entered_edit_via_loadimg = True  # [6215]
            self.set_show_tool_text(False)  # [6216]
            self.enter_edit_mode()  # [6217]
            print(
                "Switched to EDIT mode and turned off indicators after loading background image."
            )  # [6218]

    def _calculate_dimension_shapes(
        self, p1, p2, offset_point, is_preview=False, suffix=""
    ):  # [6219]
        """Calculates the geometry for dimension arrow, text, and guides."""  # [6220]
        delta_mouse_offset = offset_point - ((p1 + p2) / 2.0)  # [6221]
        abs_dx_mouse = abs(delta_mouse_offset.x())
        abs_dy_mouse = abs(delta_mouse_offset.y())  # [6222]
        threshold_ratio = 2.0
        min_movement = 10  # [6223]
        dim_orientation = "parallel"  # [6224]

        if max(abs_dx_mouse, abs_dy_mouse) > min_movement:  # [6225]
            if abs_dy_mouse > abs_dx_mouse * threshold_ratio:
                dim_orientation = "vertical"  # [6226]
            elif abs_dx_mouse > abs_dy_mouse * threshold_ratio:
                dim_orientation = "horizontal"  # [6227]

        arrow_p1, arrow_p2 = QPointF(), QPointF()
        guide1_p1, guide1_p2 = QPointF(), QPointF()  # [6228]
        guide2_p1, guide2_p2 = QPointF(), QPointF()
        dimension_value = 0.0  # [6229]
        text_mid_point = QPointF()
        perp_vec_norm = QPointF()  # [6230]

        if dim_orientation == "vertical":  # [6231]
            arrow_p1 = QPointF(p1.x(), offset_point.y())
            arrow_p2 = QPointF(p2.x(), offset_point.y())  # [6232]
            guide1_p1 = p1
            guide1_p2 = QPointF(p1.x(), offset_point.y())
            guide2_p1 = p2
            guide2_p2 = QPointF(p2.x(), offset_point.y())  # [6233]
            dimension_value = abs(p2.x() - p1.x())  # [6234]
            text_mid_point = (arrow_p1 + arrow_p2) / 2.0  # [6235]
            perp_vec_norm = QPointF(
                0, -1 if offset_point.y() < (guide1_p1.y() + guide2_p1.y()) / 2 else 1
            )  # [6236]
        elif dim_orientation == "horizontal":  # [6237]
            arrow_p1 = QPointF(offset_point.x(), p1.y())
            arrow_p2 = QPointF(offset_point.x(), p2.y())  # [6238]
            guide1_p1 = p1
            guide1_p2 = QPointF(offset_point.x(), p1.y())
            guide2_p1 = p2
            guide2_p2 = QPointF(offset_point.x(), p2.y())  # [6239]
            dimension_value = abs(p2.y() - p1.y())  # [6240]
            text_mid_point = (arrow_p1 + arrow_p2) / 2.0  # [6241]
            perp_vec_norm = QPointF(
                -1 if offset_point.x() < (guide1_p1.x() + guide2_p1.x()) / 2 else 1, 0
            )  # [6242]
        else:  # [6243]
            delta_base = p2 - p1
            length_base = math.sqrt(delta_base.x() ** 2 + delta_base.y() ** 2)  # [6244]
            if length_base < 1e-6:
                return None, None, []  # [6245]
            mid_point_base = (p1 + p2) / 2.0  # [6246]
            perp_vec_norm_base = (
                QPointF(delta_base.y(), -delta_base.x()) / length_base
            )  # [6247]
            offset_vec_from_base = offset_point - mid_point_base  # [6248]
            offset_dist_from_base = QPointF.dotProduct(
                offset_vec_from_base, perp_vec_norm_base
            )  # [6249]
            arrow_p1 = p1 + perp_vec_norm_base * offset_dist_from_base  # [6250]
            arrow_p2 = p2 + perp_vec_norm_base * offset_dist_from_base  # [6251]
            guide1_p1 = p1
            guide1_p2 = arrow_p1
            guide2_p1 = p2
            guide2_p2 = arrow_p2  # [6252]
            dimension_value = length_base
            text_mid_point = (arrow_p1 + arrow_p2) / 2.0  # [6253]
            perp_vec_norm = perp_vec_norm_base  # [6254]

        arrow_color = QColor()  # [6255]
        if is_preview:  # [6256]
            arrow_color = self.dimension_preview_line_color  # [6257]
        else:  # [6258]
            if self.dimension_preview_color_explicitly_set:  # [6259]
                arrow_color = self.dimension_preview_line_color  # [6260]
            else:  # [6261]
                arrow_color = self.current_pen_color  # [6262]

        arrow_shape = Shape(
            "arrow",
            [arrow_p1, arrow_p2],
            arrow_color,  # [6263]
            arrow_head_size=max(5, self.current_line_thickness * 2.5),
            double_headed=True,  # [6264]
            line_thickness=1,
            alpha=arrow_color.alpha() if is_preview else self.current_alpha,  # [6265]
            is_dimension_part=True,
            dimension_type="arrow",
        )  # [6266]

        text_props = deepcopy(self.dimension_default_text_properties)  # [6267]
        text_value_str = (
            f"{round(dimension_value)}{suffix}" if dimension_value > 0 else f"0{suffix}"
        )  # [6268]
        text_props["text"] = text_value_str
        text_props["color"] = arrow_color.name()  # [6269]
        text_props["dimension_suffix"] = suffix  # [6270]
        font = QFont(text_props["font"], text_props["size"])
        metrics = QFontMetrics(font)  # [6271]
        text_bound_rect = metrics.boundingRect(text_value_str)  # [6272]
        text_width = text_bound_rect.width() + 10
        text_height = text_bound_rect.height() + 4  # [6273]
        text_offset_val = text_height / 2.0 + 5.0  # [6274]
        original_mid_point_base = (p1 + p2) / 2.0
        original_offset_vector = offset_point - original_mid_point_base  # [6275]
        text_offset_direction_sign = 1.0  # [6276]
        if QPointF.dotProduct(original_offset_vector, perp_vec_norm) < 0:
            text_offset_direction_sign = -1.0  # [6277]
        text_center_pos = (
            text_mid_point
            + perp_vec_norm * text_offset_val * text_offset_direction_sign
        )  # [6278]
        text_geom = QRectF(
            text_center_pos.x() - text_width / 2,
            text_center_pos.y() - text_height / 2,
            text_width,
            text_height,
        )  # [6279]
        text_shape = Shape(
            "text",
            text_geom,
            arrow_color,
            text_properties=text_props,  # [6280]
            alpha=arrow_color.alpha() if is_preview else self.current_alpha,  # [6281]
            is_dimension_part=True,
            dimension_type="text",
        )  # [6282]

        guide_shapes = []  # [6283]
        if guide1_p1 != guide1_p2:  # [6284]
            guide1_shape = Shape(
                "line",
                [guide1_p1, guide1_p2],
                arrow_color,
                line_thickness=1,
                line_style=Qt.PenStyle.DotLine,
                alpha=arrow_color.alpha() if is_preview else self.current_alpha,
                is_dimension_part=True,
                dimension_type="guide",
            )  # [6285]
            guide_shapes.append(guide1_shape)  # [6286]
        if guide2_p1 != guide2_p2:  # [6287]
            guide2_shape = Shape(
                "line",
                [guide2_p1, guide2_p2],
                arrow_color,
                line_thickness=1,
                line_style=Qt.PenStyle.DotLine,
                alpha=arrow_color.alpha() if is_preview else self.current_alpha,
                is_dimension_part=True,
                dimension_type="guide",
            )  # [6288]
            guide_shapes.append(guide2_shape)  # [6289]
        return arrow_shape, text_shape, guide_shapes  # [6290]

    def finalize_dimension(self):  # [6291]
        """Creates the final dimension shapes and adds them to the scene."""  # [6292]
        if len(self.dimension_points) != 3:  # [6293]
            print(
                "Error: Cannot finalize dimension, incorrect number of points."
            )  # [6294]
            self.dimension_points.clear()
            self.update()
            return  # [6295]

        p1, p2, offset_point = self.dimension_points  # [6296]
        current_suffix = ""  # [6297]
        if self.control_panel and hasattr(
            self.control_panel, "dimension_suffix_edit"
        ):  # [6298]
            current_suffix = self.control_panel.dimension_suffix_edit.text()  # [6299]

        arrow_shape, text_shape, guide_shapes = self._calculate_dimension_shapes(
            p1, p2, offset_point, is_preview=False, suffix=current_suffix
        )  # [6300]

        if not arrow_shape or not text_shape:  # [6301]
            print("Error: Failed to calculate dimension shapes.")  # [6302]
            self.dimension_points.clear()
            self.update()
            return  # [6303]

        group_id = f"dim_{uuid.uuid4()}"
        arrow_shape.group_id = group_id
        text_shape.group_id = group_id  # [6304]
        for guide in guide_shapes:
            guide.group_id = group_id  # [6305]
        dimension_group = [arrow_shape, text_shape] + guide_shapes
        start_index = len(self.shapes)  # [6306]
        self.shapes.extend(dimension_group)  # [6307]
        added_indices = list(
            range(start_index, start_index + len(dimension_group))
        )  # [6308]
        self.save_state("draw_dimension", indices=added_indices)  # [6309]
        self.dimension_points.clear()
        self.dimension_preview_shapes.clear()  # [6310]
        print(f"Dimension created (Group ID: {group_id})")
        self._configure_mode()
        self.update()  # [6311]

    def update_dimension_text_position(self, group_id):  # [6312]
        """Updates the dimension text position based on its group."""  # [6313]
        arrow_shape = next(
            (
                s
                for s in self.shapes
                if s.group_id == group_id and s.dimension_type == "arrow"
            ),
            None,
        )  # [6314]
        text_shape = next(
            (
                s
                for s in self.shapes
                if s.group_id == group_id and s.dimension_type == "text"
            ),
            None,
        )  # [6315]
        guide1 = next(
            (
                s
                for s in self.shapes
                if s.group_id == group_id
                and s.dimension_type == "guide"
                and isinstance(s.geometry, list)
                and len(s.geometry) == 2
            ),
            None,
        )  # [6316]

        if (
            not arrow_shape
            or not text_shape
            or not isinstance(arrow_shape.geometry, list)
            or len(arrow_shape.geometry) != 2
            or not guide1
        ):
            return  # [6317]

        arrow_p1, arrow_p2 = arrow_shape.geometry  # [6318]
        text_suffix = text_shape.text_properties.get("dimension_suffix", "")  # [6319]
        text_to_measure = text_shape.text_properties.get("text", "")  # [6320]
        guide_base_p1, guide_arrow_p1 = guide1.geometry  # [6321]
        text_props = text_shape.text_properties
        font = QFont(text_props["font"], text_props["size"])
        metrics = QFontMetrics(font)  # [6322]
        text_bound_rect = metrics.boundingRect(text_props["text"])
        text_width = text_bound_rect.width() + 10
        text_height = text_bound_rect.height() + 4  # [6323]
        delta_arrow = arrow_p2 - arrow_p1
        length_arrow = math.sqrt(delta_arrow.x() ** 2 + delta_arrow.y() ** 2)  # [6324]
        if length_arrow < 1e-6:
            return  # [6325]
        offset_vector_guide = guide_arrow_p1 - guide_base_p1
        perp_vec_norm = QPointF()  # [6326]
        if offset_vector_guide.manhattanLength() < 1e-6:  # [6327]
            if abs(delta_arrow.x()) > abs(delta_arrow.y()):
                perp_vec_norm = QPointF(
                    0,
                    -1
                    if arrow_p1.y() < (guide_base_p1.y() + guide1.geometry[1].y()) / 2
                    else 1,
                )  # [6328]
            else:
                perp_vec_norm = QPointF(
                    -1
                    if arrow_p1.x() < (guide_base_p1.x() + guide1.geometry[1].x()) / 2
                    else 1,
                    0,
                )  # [6329]
        else:
            perp_vec_norm = offset_vector_guide / math.sqrt(
                offset_vector_guide.x() ** 2 + offset_vector_guide.y() ** 2
            )  # [6330]
        text_mid_point_on_arrow = (arrow_p1 + arrow_p2) / 2.0
        text_offset_val = text_height / 2.0 + 5.0  # [6331]
        text_center_pos = (
            text_mid_point_on_arrow + perp_vec_norm * text_offset_val
        )  # [6332]

        font = QFont(text_props["font"], text_props["size"])  # [6333]
        metrics = QFontMetrics(font)  # [6334]
        actual_text_rect = metrics.boundingRect(text_to_measure)  # [6335]
        text_width = actual_text_rect.width() + 10
        text_height = actual_text_rect.height() + 4  # [6336]
        text_geom = QRectF(
            text_center_pos.x() - text_width / 2,
            text_center_pos.y() - text_height / 2,
            text_width,
            text_height,
        )  # [6337]
        text_shape.geometry = text_geom  # [6338]

    def draw_dimension_preview(self, painter):  # [6339]
        """Draws the dimensioning preview."""  # [6340]
        if not self.dimension_points:
            return  # [6341]
        p1 = self.dimension_points[0]  # [6342]
        temp_pen = QPen(self.dimension_preview_line_color, 1, Qt.PenStyle.DashLine)
        painter.save()
        painter.setPen(temp_pen)  # [6343]
        if len(self.dimension_points) == 1:
            painter.drawLine(p1, self.current_mouse_pos)  # [6344]
        elif len(self.dimension_points) >= 2:  # [6345]
            p2 = self.dimension_points[1]  # [6346]
            offset_point = (
                self.current_mouse_pos
                if len(self.dimension_points) == 2
                else self.dimension_points[2]
            )  # [6347]
            preview_suffix = ""  # [6348]
            if self.control_panel and hasattr(
                self.control_panel, "dimension_suffix_edit"
            ):  # [6349]
                preview_suffix = (
                    self.control_panel.dimension_suffix_edit.text()
                )  # [6350]
            arrow_preview, text_preview, guides_preview = (
                self._calculate_dimension_shapes(
                    p1, p2, offset_point, is_preview=True, suffix=preview_suffix
                )
            )  # [6351]
            if arrow_preview:
                self.draw_shape(painter, arrow_preview, is_preview=True)  # [6352]
            if text_preview:
                self.draw_shape(painter, text_preview, is_preview=True)  # [6353]
            for guide in guides_preview:
                self.draw_shape(painter, guide, is_preview=True)  # [6354]
        painter.restore()  # [6355]

    def draw_angle_tool_preview(self, painter):  # [6356]
        """Draws the preview for the Angle tool."""  # [6357]
        if not self.angle_points:
            return  # [6358]
        p_color = self.current_angle_tool_line_color
        temp_pen = QPen(p_color, 1, Qt.PenStyle.DashLine)
        painter.save()
        painter.setPen(temp_pen)  # [6359]
        if len(self.angle_points) == 1:
            painter.drawLine(self.angle_points[0], self.current_mouse_pos)  # [6360]
        elif len(self.angle_points) == 2:
            painter.drawLine(self.angle_points[0], self.angle_points[1])
            painter.drawLine(self.angle_points[1], self.current_mouse_pos)  # [6361]
        painter.restore()  # [6362]

    def finalize_angle_marker(self):  # [6363]
        """Creates the final angle shape and associated text."""  # [6364]
        if len(self.angle_points) != 3:
            print("Error: Cannot finalize angle_marker, incorrect number of points.")
            self.angle_points.clear()
            self.update()
            return  # [6365]
        pA, pO, pB = self.angle_points  # [6366]
        angle_shape = Shape(
            shape_type="angle_marker",
            geometry=[pA, pO, pB],
            color=self.current_angle_tool_line_color,
            line_thickness=self.current_line_thickness,
            alpha=self.current_alpha,
            is_dimension_part=False,
        )  # [6367]
        group_id = f"angle_{uuid.uuid4()}"
        angle_shape.group_id = group_id  # [6368]
        text_props = {
            "font": "Arial",
            "size": self.current_angle_tool_text_size,
            "bold": False,
            "italic": False,
            "underline": False,
            "strikeout": False,
            "color": self.current_angle_tool_line_color.name(),
            "background_color": None,
            "alignment": "center",
            "curve_angle": 0,
            "is_angle_display": True,
        }  # [6369]
        angle_text_value, text_geom = self._calculate_and_position_angle_text(
            pA, pO, pB, text_props
        )
        text_props["text"] = angle_text_value  # [6370]
        angle_text_shape = Shape(
            shape_type="text",
            geometry=text_geom,
            color=self.current_angle_tool_line_color,
            alpha=self.current_alpha,
            text_properties=text_props,
            group_id=group_id,
            is_label=True,
        )  # [6371]
        angle_group = [angle_shape, angle_text_shape]
        start_index = len(self.shapes)
        self.shapes.extend(angle_group)  # [6372]
        added_indices = list(range(start_index, start_index + len(angle_group)))
        self.save_state("draw_angle_marker", indices=added_indices)  # [6373]
        self.angle_points.clear()
        self.current_drawing_shape = None
        print(f"Angle marker created (Group ID: {group_id})")
        self._configure_mode()
        self.update()  # [6374]

    def _calculate_angle_values(self, pA, pO, pB):  # [6375]
        """Calculates the convex (0-180 degrees) and concave (360-convex) angle for AOB."""  # [6376]
        vec_OA = pA - pO  # [6377]
        vec_OB = pB - pO  # [6378]
        dot_product = QPointF.dotProduct(vec_OA, vec_OB)  # [6379]
        len_OA = math.sqrt(vec_OA.x() ** 2 + vec_OA.y() ** 2)  # [6380]
        len_OB = math.sqrt(vec_OB.x() ** 2 + vec_OB.y() ** 2)  # [6381]

        if len_OA < 1e-6 or len_OB < 1e-6:  # [6382]
            return 0.0, 0.0  # [6383]

        cos_angle = dot_product / (len_OA * len_OB)  # [6384]
        cos_angle = max(-1.0, min(1.0, cos_angle))

        convex_angle_deg = math.degrees(math.acos(cos_angle))  # [6385]
        concave_angle_deg = 360.0 - convex_angle_deg  # [6386]
        if convex_angle_deg == 0.0 and concave_angle_deg == 360.0:  # [6387]
            pass  # [6388]
        elif abs(convex_angle_deg - 360.0) < 1e-9:  # [6389]
            concave_angle_deg = 0.0  # [6390]

        return convex_angle_deg, concave_angle_deg  # [6391]

    def _calculate_and_position_angle_text(self, pA, pO, pB, text_props):  # [6392]
        """Calculates angle text and its position."""  # [6393]
        inner_angle_deg, outer_angle_deg = self._calculate_angle_values(
            pA, pO, pB
        )  # [6394]
        angle_text_value = ""  # [6395]

        show_in = self.current_angle_tool_show_inner  # [6396]
        show_out = self.current_angle_tool_show_outer  # [6397]

        if show_in and show_out:  # [6398]
            angle_text_value = (
                f"IN {inner_angle_deg:.2f}°\nOUT {outer_angle_deg:.2f}°"  # [6399]
            )
        elif show_in:  # [6400]
            angle_text_value = f"IN {inner_angle_deg:.2f}°"  # [6401]
        elif show_out:  # [6402]
            angle_text_value = f"OUT {outer_angle_deg:.2f}°"  # [6403]
        else:  # [6404]
            angle_text_value = ""  # [6405]

        font = QFont(text_props["font"], text_props["size"])  # [6406]
        metrics = QFontMetrics(font)  # [6407]
        text_rect_for_calc = metrics.boundingRect(
            QRect(0, 0, 1000, 1000),
            int(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop),
            angle_text_value,
        )  # [6408]
        text_width = text_rect_for_calc.width() + 10  # [6409]
        text_height = text_rect_for_calc.height() + 4  # [6410]

        vec_OA_orig = pA - pO  # [6411]
        vec_OB_orig = pB - pO  # [6412]
        len_OA = math.sqrt(vec_OA_orig.x() ** 2 + vec_OA_orig.y() ** 2)  # [6413]
        len_OB = math.sqrt(vec_OB_orig.x() ** 2 + vec_OB_orig.y() ** 2)  # [6414]

        if len_OA < 1e-6 or len_OB < 1e-6:  # [6415]
            return angle_text_value, QRectF(
                pO.x() - text_width / 2,
                pO.y() - text_height / 2 - 20,
                text_width,
                text_height,
            )  # [6416]

        vec_OA_norm = vec_OA_orig / len_OA  # [6417]
        vec_OB_norm = vec_OB_orig / len_OB  # [6418]

        bisector_sum_norm = vec_OA_norm + vec_OB_norm  # [6419]
        text_center_pos = QPointF()  # [6420]
        bisector_to_use = QPointF()  # [6421]

        if bisector_sum_norm.manhattanLength() < 1e-6:  # [6422]
            bisector_to_use = QPointF(-vec_OA_norm.y(), vec_OA_norm.x())  # [6423]
        else:  # [6424]
            bisector_to_use = bisector_sum_norm / math.sqrt(
                bisector_sum_norm.x() ** 2 + bisector_sum_norm.y() ** 2
            )  # [6425]

        dynamic_text_offset = 60.0  # [6426]
        text_center_pos = pO - (bisector_to_use * dynamic_text_offset)  # [6427]

        text_geom = QRectF(
            text_center_pos.x() - text_width / 2,
            text_center_pos.y() - text_height / 2,
            text_width,
            text_height,
        )  # [6428]

        return angle_text_value, text_geom  # [6429]

    def update_angle_marker_text(self, group_id, update_text_only=False):  # [6430]
        """Updates the text and position of an angle label for a given group."""  # [6431]
        angle_shape = next(
            (
                s
                for s in self.shapes
                if s.group_id == group_id and s.type == "angle_marker"
            ),
            None,
        )  # [6432]
        text_shape = next(
            (
                s
                for s in self.shapes
                if s.group_id == group_id
                and s.type == "text"
                and s.text_properties
                and s.text_properties.get("is_angle_display")
            ),
            None,
        )  # [6433]
        if (
            not angle_shape
            or not text_shape
            or not isinstance(angle_shape.geometry, list)
            or len(angle_shape.geometry) != 3
        ):
            return  # [6434]

        pA, pO, pB = angle_shape.geometry  # [6435]

        angle_text_value, new_text_geom = self._calculate_and_position_angle_text(
            pA, pO, pB, text_shape.text_properties
        )  # [6436]

        text_shape.text_properties["text"] = angle_text_value  # [6437]
        text_shape.geometry = new_text_geom  # [6438]

        text_shape.text_properties["color"] = (
            self.current_angle_tool_line_color.name()
        )  # [6439]
        text_shape.text_properties["size"] = self.current_angle_tool_text_size  # [6440]

        self.update()  # [6441]

    def _draw_arrow_head_at_point(
        self,
        painter: QPainter,
        tip_point: QPointF,
        direction_from_tip: QPointF,
        size: float,
        color: QColor,
        alpha: int,
    ):  # [6442]
        """# [6443]
        Draws an arrowhead at the given point. # [6444]
        """  # [6445]
        if direction_from_tip.manhattanLength() < 1e-6 or size <= 0:  # [6446]
            return  # [6447]

        angle_rad_base = math.atan2(
            direction_from_tip.y(), direction_from_tip.x()
        )  # [6448]

        wing_angle_offset_rad = math.radians(30)  # [6449]

        a1_rad = angle_rad_base + wing_angle_offset_rad  # [6450]
        a2_rad = angle_rad_base - wing_angle_offset_rad  # [6451]

        p_wing1 = tip_point + QPointF(
            math.cos(a1_rad) * size, math.sin(a1_rad) * size
        )  # [6452]
        p_wing2 = tip_point + QPointF(
            math.cos(a2_rad) * size, math.sin(a2_rad) * size
        )  # [6453]

        painter.save()  # [6454]
        head_brush_color = QColor(color)  # [6455]
        head_brush_color.setAlpha(alpha)  # [6456]
        painter.setBrush(QBrush(head_brush_color))  # [6457]
        painter.setPen(Qt.PenStyle.NoPen)  # [6458]
        painter.drawPolygon(QPolygonF([tip_point, p_wing1, p_wing2]))  # [6459]
        painter.restore()  # [6460]

    def group_selected_shapes(self):  # [6461]
        """Groups selected shapes."""  # [6462]
        if len(self.selected_shapes) < 2:  # [6463]
            print("Select at least two shapes to group.")  # [6464]
            return  # [6465]

        can_group = True  # [6466]
        for shape in self.selected_shapes:  # [6467]
            if shape.group_id and not (
                shape.is_mpoint_marker
                or shape.is_label
                or shape.is_dimension_part
                or shape.type == "angle_marker"
            ):  # [6468]
                print(
                    f"Cannot group: Shape {shape.type} (ID: {shape.group_id}) is already part of a custom group."
                )  # [6469]
                can_group = False  # [6470]
                break  # [6471]
        if not can_group:
            return  # [6472]

        new_group_id = f"group_{uuid.uuid4()}"  # [6473]
        print(
            f"Grouping {len(self.selected_shapes)} shapes with new group ID: {new_group_id}"
        )  # [6474]

        shapes_involved = []  # [6475]
        previous_group_ids = {}  # [6476]
        indices = []  # [6477]

        for shape in self.selected_shapes:  # [6478]
            try:  # [6479]
                idx = self.shapes.index(shape)  # [6480]
                previous_group_ids[idx] = shape.group_id  # [6481]
                shape.group_id = new_group_id  # [6482]
                shapes_involved.append(shape)  # [6483]
                indices.append(idx)  # [6484]
            except ValueError:  # [6485]
                continue  # [6486]

        if shapes_involved:  # [6487]
            self.save_state(
                "group_shapes",
                shapes_involved=shapes_involved,
                previous_geometries=previous_group_ids,
                indices=indices,
            )  # [6488]
            self.update()  # [6489]

    def ungroup_selected_shapes(self):  # [6490]
        """Ungroups selected shapes."""  # [6491]
        if not self.selected_shapes:  # [6492]
            print("No shapes selected to ungroup.")  # [6493]
            return  # [6494]

        shapes_to_ungroup = []  # [6495]
        previous_group_ids = {}  # [6496]
        indices = []  # [6497]
        group_ids_in_selection = set()  # [6498]

        for shape in self.selected_shapes:  # [6499]
            if shape.group_id:  # [6500]
                if not (
                    shape.is_mpoint_marker
                    or shape.is_label
                    or shape.is_dimension_part
                    or shape.type == "angle_marker"
                ):  # [6501]
                    group_ids_in_selection.add(shape.group_id)  # [6502]

        if not group_ids_in_selection:  # [6503]
            print("No user-created groups selected to ungroup.")  # [6504]
            return  # [6505]

        print(
            f"Ungrouping shapes from groups: {list(group_ids_in_selection)}"
        )  # [6506]

        for i, shape in enumerate(self.shapes):  # [6507]
            if shape.group_id in group_ids_in_selection:  # [6508]
                previous_group_ids[i] = shape.group_id  # [6509]
                shape.group_id = None  # [6510]
                shapes_to_ungroup.append(shape)  # [6511]
                indices.append(i)  # [6512]

        if shapes_to_ungroup:  # [6513]
            self.save_state(
                "ungroup_shapes",
                shapes_involved=shapes_to_ungroup,
                previous_geometries=previous_group_ids,
                indices=indices,
            )  # [6514]
            self.update()  # [6515]
            self.selected_shapes = shapes_to_ungroup  # [6516]

    def _get_snapped_point(
        self, original_point: QPointF
    ) -> Optional[QPointF]:  # [6517]
        """# [6518]
        Tries to snap the given point to guide lines or grid, # [6519]
        if the respective snapping mode is active. # [6520]
        Updates self.snapped_point_preview or self.snapped_line_preview. # [6521]
        Returns the snapped point or None if no snapping occurred. # [6522]
        """  # [6523]
        self.snapped_point_preview = None  # [6524]
        self.snapped_line_preview = None  # [6525]
        snapped_x = original_point.x()  # [6526]
        snapped_y = original_point.y()  # [6527]
        point_was_snapped = False  # [6528]
        snap_threshold = float(self.snap_sensitivity)  # [6529]

        # Snap to Guide Lines (Lines) # [6530]
        if (
            self.snap_mode in ["lines", "all"]
            and lines_app_instance
            and lines_app_instance.linijki_widoczne
        ):  # [6531]
            active_guide_lines = lines_app_instance.get_active_guide_lines()  # [6532]

            # Check horizontal lines # [6533]
            best_h_snap_dist = snap_threshold + 1  # [6534]
            snapped_to_h_line = None  # [6535]
            for line_type, line_pos in active_guide_lines:  # [6536]
                if line_type == "h":  # [6537]
                    dist_y = abs(original_point.y() - line_pos)  # [6538]
                    if dist_y <= snap_threshold and dist_y < best_h_snap_dist:  # [6539]
                        best_h_snap_dist = dist_y  # [6540]
                        snapped_y = float(line_pos)  # [6541]
                        snapped_to_h_line = ("h", snapped_y)  # [6542]
                        point_was_snapped = True  # [6543]

            # Check vertical lines # [6544]
            best_v_snap_dist = snap_threshold + 1  # [6545]
            snapped_to_v_line = None  # [6546]
            for line_type, line_pos in active_guide_lines:  # [6547]
                if line_type == "v":  # [6548]
                    dist_x = abs(original_point.x() - line_pos)  # [6549]
                    if dist_x <= snap_threshold and dist_x < best_v_snap_dist:  # [6550]
                        best_v_snap_dist = dist_x  # [6551]
                        snapped_x = float(line_pos)  # [6552]
                        snapped_to_v_line = ("v", snapped_x)  # [6553]
                        point_was_snapped = True  # [6554]

            # Prefer intersection snap if both directions are snapped # [6555]
            if snapped_to_h_line and snapped_to_v_line:  # [6556]
                self.snapped_point_preview = QPointF(snapped_x, snapped_y)  # [6557]
                self.snapped_line_preview = (
                    None  # Don't show lines if point is snapped # [6558]
                )
            elif snapped_to_h_line:  # [6559]
                self.snapped_line_preview = snapped_to_h_line  # [6560]
            elif snapped_to_v_line:  # [6561]
                self.snapped_line_preview = snapped_to_v_line  # [6562]

        # Snap to Grid # [6563]
        # This logic will execute if no guide line snapping occurred, or if snap_mode is "grid" or "all" # [6564]
        # and guide lines are not active. # [6565]
        if (
            self.snap_mode in ["grid", "all"]
            and grid_overlay_instance
            and grid_overlay_instance.visible
        ):  # [6566]
            if not (
                self.snap_mode == "all" and point_was_snapped
            ):  # If "all" and already snapped to a guide line, don't snap to grid # [6567]
                grid_h_lines, grid_v_lines = (
                    grid_overlay_instance.get_visible_grid_lines()
                )  # [6568]

                best_h_grid_snap_dist = snap_threshold + 1  # [6569]
                snapped_to_h_grid_line_coord = None  # [6570]
                for line_y in grid_h_lines:  # [6571]
                    dist_y = abs(original_point.y() - line_y)  # [6572]
                    if (
                        dist_y <= snap_threshold and dist_y < best_h_grid_snap_dist
                    ):  # [6573]
                        best_h_grid_snap_dist = dist_y  # [6574]
                        snapped_y = float(line_y)  # [6575]
                        snapped_to_h_grid_line_coord = snapped_y  # [6576]
                        point_was_snapped = True  # [6577]

                best_v_grid_snap_dist = snap_threshold + 1  # [6578]
                snapped_to_v_grid_line_coord = None  # [6579]
                for line_x in grid_v_lines:  # [6580]
                    dist_x = abs(original_point.x() - line_x)  # [6581]
                    if (
                        dist_x <= snap_threshold and dist_x < best_v_grid_snap_dist
                    ):  # [6582]
                        best_v_grid_snap_dist = dist_x  # [6583]
                        snapped_x = float(line_x)  # [6584]
                        snapped_to_v_grid_line_coord = snapped_x  # [6585]
                        point_was_snapped = True  # [6586]

                # If snapped to grid, update feedback # [6587]
                if (
                    snapped_to_h_grid_line_coord is not None
                    and snapped_to_v_grid_line_coord is not None
                ):  # [6588]
                    self.snapped_point_preview = QPointF(snapped_x, snapped_y)  # [6589]
                    self.snapped_line_preview = None  # [6590]
                elif snapped_to_h_grid_line_coord is not None:  # [6591]
                    # If already snapped to a guide line X, don't overwrite # [6592]
                    if (
                        self.snapped_line_preview is None
                        or self.snapped_line_preview[0] != "v"
                    ):  # [6593]
                        self.snapped_line_preview = ("h", snapped_y)  # [6594]
                elif snapped_to_v_grid_line_coord is not None:  # [6595]
                    # If already snapped to a guide line Y, don't overwrite # [6596]
                    if (
                        self.snapped_line_preview is None
                        or self.snapped_line_preview[0] != "h"
                    ):  # [6597]
                        self.snapped_line_preview = ("v", snapped_x)  # [6598]

        # Snap to key points of other shapes (Snap to All Shapes)
        if self.snap_mode == "all" and not (
            self.snapped_point_preview or self.snapped_line_preview
        ):  # Only if not snapped to lines/grid
            key_points_on_screen = []
            for shape in self.shapes:
                if not shape.visible or not shape.geometry:
                    continue

                # Gather key points for the shape # [6599]
                shape_key_points = self._get_key_points_for_shape(shape)
                key_points_on_screen.extend(shape_key_points)

            # Snap to division points (if active)
            if self.divide_enabled and self.number_of_divisions >= 2:
                for shape in self.shapes:
                    if not shape.visible or not shape.geometry:
                        continue
                    division_points = self._get_division_points_for_shape(
                        shape
                    )  # New method needed
                    key_points_on_screen.extend(division_points)  # [6600]

            if key_points_on_screen:
                best_dist_sq = (snap_threshold + 1) ** 2
                closest_snap_point = None

                for key_point in key_points_on_screen:
                    dist_sq = (original_point.x() - key_point.x()) ** 2 + (
                        original_point.y() - key_point.y()
                    ) ** 2
                    if dist_sq <= snap_threshold**2 and dist_sq < best_dist_sq:
                        best_dist_sq = dist_sq
                        closest_snap_point = key_point  # [6601]

                if closest_snap_point:
                    snapped_x = closest_snap_point.x()
                    snapped_y = closest_snap_point.y()
                    self.snapped_point_preview = QPointF(snapped_x, snapped_y)
                    point_was_snapped = True

        if point_was_snapped:
            return QPointF(snapped_x, snapped_y)  # [6602]

        return None  # Nothing was snapped

    def _get_key_points_for_shape(self, shape: Shape) -> List[QPointF]:
        """Returns a list of key points for the given shape (vertices, center)."""
        key_points = []
        geo = shape.geometry
        center_transform = QPointF()

        # Determine transformation center (if rotated) # [6603]
        if shape.rotation != 0:
            if shape.type == "arc":
                center_transform = self._get_arc_visual_center(shape)
            elif (
                shape.type in ["line", "arrow", "angle_marker"]
                and isinstance(geo, list)
                and len(geo) > 0
                and isinstance(geo[0], QPointF)
            ):
                center_transform = geo[0]
                if shape.type == "angle_marker" and len(geo) == 3:
                    center_transform = geo[1]
            elif isinstance(geo, QRectF) and geo.isValid():
                center_transform = geo.center()  # [6604]
            elif isinstance(geo, QPointF):
                center_transform = geo
            elif isinstance(geo, list):
                valid_points_for_center = [p for p in geo if isinstance(p, QPointF)]
                if valid_points_for_center:
                    center_transform = QPointF(
                        sum(p.x() for p in valid_points_for_center)
                        / len(valid_points_for_center),
                        sum(p.y() for p in valid_points_for_center)
                        / len(valid_points_for_center),
                    )

        transform = QTransform()  # [6605]
        if shape.rotation != 0 and not center_transform.isNull():
            transform.translate(center_transform.x(), center_transform.y())
            transform.rotate(shape.rotation)
            transform.translate(-center_transform.x(), -center_transform.y())

        # Points for different shape types
        if isinstance(geo, QRectF) and geo.isValid():
            if shape.type in ["rect", "ellipse", "text"]:
                key_points.extend(
                    [
                        geo.topLeft(),
                        geo.topRight(),
                        geo.bottomLeft(),
                        geo.bottomRight(),
                        geo.center(),
                    ]
                )  # [6606]
            elif shape.type == "arc":
                # Start, end, and mid points of the arc
                rx, ry = geo.width() / 2.0, geo.height() / 2.0
                arc_center_calc = geo.center()
                key_points.append(
                    arc_center_calc
                    + QPointF(
                        rx * math.cos(math.radians(shape.startAngle)),
                        -ry * math.sin(math.radians(shape.startAngle)),
                    )
                )
                key_points.append(
                    arc_center_calc
                    + QPointF(
                        rx * math.cos(math.radians(shape.startAngle + shape.spanAngle)),
                        -ry
                        * math.sin(math.radians(shape.startAngle + shape.spanAngle)),
                    )
                )
                key_points.append(
                    arc_center_calc
                    + QPointF(
                        rx
                        * math.cos(
                            math.radians(shape.startAngle + shape.spanAngle / 2.0)
                        ),
                        -ry
                        * math.sin(
                            math.radians(shape.startAngle + shape.spanAngle / 2.0)
                        ),
                    )
                )
                key_points.append(arc_center_calc)  # Also add center of bounding rect

        elif isinstance(geo, QPointF):  # For MPoint # [6607]
            key_points.append(geo)

        elif isinstance(geo, list):
            valid_points = [p for p in geo if isinstance(p, QPointF)]
            key_points.extend(valid_points)  # Vertices
            if len(valid_points) > 1:  # Geometric center of the point list
                cx = sum(p.x() for p in valid_points) / len(valid_points)
                cy = sum(p.y() for p in valid_points) / len(valid_points)
                key_points.append(QPointF(cx, cy))  # [6608]
            # Midpoints of segments for lines, arrows, polygons
            if shape.type in [
                "line",
                "arrow",
                "polygon",
                "triangle",
                "trapeze",
                "regular_polygon",
                "line_point",
                "spline",
                "angle_marker",
            ]:
                num_pts = len(valid_points)
                if (
                    shape.type == "angle_marker" and num_pts == 3
                ):  # Treat AO and OB as segments
                    key_points.append((valid_points[0] + valid_points[1]) / 2.0)
                    key_points.append((valid_points[1] + valid_points[2]) / 2.0)
                else:
                    for i in range(num_pts):
                        p1_segment = valid_points[i]  # [6609]
                        p2_segment = valid_points[
                            (i + 1) % num_pts
                            if shape.type
                            not in ["line", "arrow", "line_point", "spline"]
                            else (i + 1 if i + 1 < num_pts else i)
                        ]
                        if (
                            p1_segment != p2_segment
                        ):  # Avoid division by zero or adding same point
                            key_points.append((p1_segment + p2_segment) / 2.0)

        # Apply rotation transform (if any)
        if shape.rotation != 0 and not center_transform.isNull():
            key_points = [transform.map(p) for p in key_points]

        # Remove duplicates that might have formed # [6610]
        unique_key_points = []
        seen_points_coords = set()
        for p in key_points:
            coord_tuple = (
                round(p.x(), 3),
                round(p.y(), 3),
            )  # Round to avoid float precision issues
            if coord_tuple not in seen_points_coords:
                unique_key_points.append(p)
                seen_points_coords.add(coord_tuple)

        return unique_key_points  # [6611]

    def _get_division_points_for_shape(self, shape: Shape) -> List[QPointF]:
        """Returns a list of division points for the given shape, without drawing them."""
        division_points = []
        if (
            not self.divide_enabled
            or self.number_of_divisions < 2
            or not shape.visible
            or not shape.geometry
        ):
            return division_points

        geo = shape.geometry
        center_transform = QPointF()
        # Determine transformation center (if rotated) # [6612]
        if shape.rotation != 0:
            # (Logic similar to _get_key_points_for_shape to calculate center_transform)
            if shape.type == "arc":
                center_transform = self._get_arc_visual_center(shape)
            elif isinstance(geo, QRectF):
                center_transform = geo.center()
            elif isinstance(geo, QPointF):
                center_transform = geo
            elif isinstance(geo, list):
                valid_points_for_center = [p for p in geo if isinstance(p, QPointF)]
                if valid_points_for_center:
                    center_transform = QPointF(
                        sum(p.x() for p in valid_points_for_center)
                        / len(valid_points_for_center),  # [6613]
                        sum(p.y() for p in valid_points_for_center)
                        / len(valid_points_for_center),
                    )
        transform = QTransform()
        if shape.rotation != 0 and not center_transform.isNull():
            transform.translate(center_transform.x(), center_transform.y())
            transform.rotate(shape.rotation)
            transform.translate(-center_transform.x(), -center_transform.y())

        # Generate division points (logic similar to _draw_division_points, but without drawing)
        if (
            shape.type in ["line", "arrow", "line_point"]
            and isinstance(geo, list)
            and len(geo) >= 2
        ):  # [6614]
            for i in range(len(geo) - 1):
                p_start, p_end = geo[i], geo[i + 1]
                if isinstance(p_start, QPointF) and isinstance(p_end, QPointF):
                    segment_vector = p_end - p_start
                    segment_length = math.sqrt(
                        QPointF.dotProduct(segment_vector, segment_vector)
                    )
                    if segment_length < 1e-6:
                        continue
                    step_vector = segment_vector / self.number_of_divisions
                    for j in range(
                        1, self.number_of_divisions
                    ):  # Skip start and end of segment
                        division_points.append(p_start + step_vector * j)  # [6615]
        # ... (implementation for other shape types, analogous to _draw_division_points) ...
        elif shape.type == "rect" and isinstance(geo, QRectF) and geo.isValid():
            corners = [
                geo.topLeft(),
                geo.topRight(),
                geo.bottomRight(),
                geo.bottomLeft(),
            ]
            for i in range(4):
                p_start, p_end = corners[i], corners[(i + 1) % 4]
                segment_vector = p_end - p_start
                segment_length = math.sqrt(
                    QPointF.dotProduct(segment_vector, segment_vector)
                )
                if segment_length < 1e-6:
                    continue
                step_vector = segment_vector / self.number_of_divisions  # [6616]
                for j in range(1, self.number_of_divisions):
                    division_points.append(p_start + step_vector * j)
        elif (
            shape.type in ["triangle", "polygon", "trapeze", "regular_polygon"]
            and isinstance(geo, list)
            and len(geo) >= 3
        ):
            num_vertices = len(geo)
            for i in range(num_vertices):
                p_start, p_end = geo[i], geo[(i + 1) % num_vertices]
                if isinstance(p_start, QPointF) and isinstance(p_end, QPointF):
                    segment_vector = p_end - p_start
                    segment_length = math.sqrt(
                        QPointF.dotProduct(segment_vector, segment_vector)
                    )  # [6617]
                    if segment_length < 1e-6:
                        continue
                    step_vector = segment_vector / self.number_of_divisions
                    for j in range(1, self.number_of_divisions):
                        division_points.append(p_start + step_vector * j)
        elif (
            shape.type == "ellipse" and isinstance(geo, QRectF) and geo.isValid()
        ):  # Approximation for ellipse, e.g., on bounding box
            corners = [
                geo.topLeft(),
                geo.topRight(),
                geo.bottomRight(),
                geo.bottomLeft(),
            ]
            for i in range(4):
                p_start, p_end = corners[i], corners[(i + 1) % 4]
                segment_vector = p_end - p_start  # [6618]
                segment_length = math.sqrt(
                    QPointF.dotProduct(segment_vector, segment_vector)
                )
                if segment_length < 1e-6:
                    continue
                step_vector = segment_vector / self.number_of_divisions
                for j in range(1, self.number_of_divisions):
                    division_points.append(p_start + step_vector * j)
        elif shape.type == "arc" and isinstance(geo, QRectF) and geo.isValid():
            center_arc, rx, ry = geo.center(), geo.width() / 2.0, geo.height() / 2.0
            if rx < 1e-6 or ry < 1e-6:
                return []
            start_angle_rad, span_angle_rad = (
                math.radians(shape.startAngle),
                math.radians(shape.spanAngle),
            )  # [6619]
            for i in range(1, self.number_of_divisions):
                current_angle_rad = start_angle_rad + (
                    span_angle_rad * i / self.number_of_divisions
                )
                division_points.append(
                    QPointF(
                        center_arc.x() + rx * math.cos(current_angle_rad),
                        center_arc.y() - ry * math.sin(current_angle_rad),
                    )
                )
        elif (
            shape.type == "spline"
            and isinstance(geo, list)
            and len(geo) >= 4
            and (len(geo) - 1) % 3 == 0
        ):
            for i in range(1, len(geo) - 1, 3):
                if i + 2 < len(geo):
                    p_start_segment = geo[i - 1] if i > 0 else geo[0]
                    c1, c2, p_end_segment = geo[i], geo[i + 1], geo[i + 2]
                    temp_path_segment = QPainterPath(p_start_segment)  # [6620]
                    temp_path_segment.cubicTo(c1, c2, p_end_segment)
                    for j in range(1, self.number_of_divisions):
                        division_points.append(
                            temp_path_segment.pointAtPercent(
                                float(j) / self.number_of_divisions
                            )
                        )

        # Apply rotation transform (if any)
        if shape.rotation != 0 and not center_transform.isNull():
            division_points = [transform.map(p) for p in division_points]

        return division_points  # [6621]


class TextInputDialog(QDialog):
    def __init__(
        self,
        parent,
        existing_properties=None,
        is_mpoint_label_style=False,
        is_angle_text_style_edit=False,
        is_angle_text_edit=False,
    ):
        """Initializes the Text Input Dialog."""
        super().__init__(parent)
        self.setWindowTitle("Text Properties")
        self.setModal(True)
        props = deepcopy(existing_properties) if existing_properties is not None else {}
        props.setdefault("curve_angle", 0)  # [6622]
        props.setdefault("is_angle_display", False)
        self.text_cleared = False
        layout = QVBoxLayout(self)
        self.is_mpoint_label_style_edit = is_mpoint_label_style
        self.is_angle_text_style_edit = is_angle_text_style_edit
        self.is_angle_text_content_edit = is_angle_text_edit

        self.text_edit = QTextEdit()
        self.text_edit.setPlainText(props.get("text", ""))
        if is_mpoint_label_style:  # [6623]
            self.text_edit.setPlaceholderText(
                "Label text is generated automatically (e.g., '1', 'A', 'A1'...)"
            )
            self.text_edit.setReadOnly(True)
        elif is_angle_text_style_edit:
            self.text_edit.setPlaceholderText(
                "Angle text is generated automatically (e.g., 'IN 45.00°')"
            )
            self.text_edit.setReadOnly(True)
        elif is_angle_text_edit:
            self.text_edit.setToolTip(
                "Edit the format of the angle text. Values will be recalculated."
            )

        layout.addWidget(QLabel("Text:"))
        layout.addWidget(self.text_edit)  # [6624]

        font_layout = QHBoxLayout()
        self.font_combo = QFontComboBox()
        try:
            font = QFont(props.get("font", "Arial"))
            self.font_combo.setCurrentFont(font)
        except Exception as e:
            print(
                f"Warning: Could not set font '{props.get('font', 'Arial')}', using default. Error: {e}"
            )
            self.font_combo.setCurrentFont(QFont("Arial"))
        font_layout.addWidget(QLabel("Font:"))
        font_layout.addWidget(self.font_combo)  # [6625]

        self.size_spin = QSpinBox()
        self.size_spin.setRange(6, 120)
        self.size_spin.setValue(props.get("size", 12))
        self.size_spin.setSuffix(" pt")
        font_layout.addWidget(QLabel("Size:"))
        font_layout.addWidget(self.size_spin)
        layout.addLayout(font_layout)

        style_layout = QHBoxLayout()
        self.bold_check = QCheckBox("B")
        f = self.bold_check.font()
        f.setBold(True)
        self.bold_check.setFont(f)
        self.bold_check.setChecked(props.get("bold", False))
        self.italic_check = QCheckBox("I")
        f = self.italic_check.font()
        f.setItalic(True)
        self.italic_check.setFont(f)
        self.italic_check.setChecked(props.get("italic", False))
        self.underline_check = QCheckBox("U")
        f = self.underline_check.font()
        f.setUnderline(True)
        self.underline_check.setFont(f)
        self.underline_check.setChecked(props.get("underline", False))  # [6626]
        self.strikeout_check = QCheckBox("S")
        f = self.strikeout_check.font()
        f.setStrikeOut(True)
        self.strikeout_check.setFont(f)
        self.strikeout_check.setChecked(props.get("strikeout", False))
        style_layout.addWidget(self.bold_check)
        style_layout.addWidget(self.italic_check)
        style_layout.addWidget(self.underline_check)
        style_layout.addWidget(self.strikeout_check)
        style_layout.addStretch()
        layout.addLayout(style_layout)

        color_layout = QHBoxLayout()
        try:
            text_color_str = props.get("color", "#000000")
            self.text_color = QColor(text_color_str)
            if not self.text_color.isValid():
                self.text_color = QColor("#000000")  # [6627]
        except Exception:
            self.text_color = QColor("#000000")
        self.text_color_button = QPushButton("Text Color")
        self.text_color_button.clicked.connect(self.choose_text_color)
        color_layout.addWidget(self.text_color_button)

        bg_color_str = props.get("background_color")
        self.bg_color = None
        if bg_color_str:
            try:
                temp_color = QColor(bg_color_str)
                if temp_color.isValid() and temp_color.alpha() > 0:  # [6628]
                    self.bg_color = temp_color
            except Exception:
                self.bg_color = None
        self.bg_color_button = QPushButton()
        self.bg_color_button.clicked.connect(self.choose_bg_color)
        self.bg_color_button.setText("BG Color")
        color_layout.addWidget(self.bg_color_button)

        self.transparent_bg_button = QPushButton("Transparent")
        self.transparent_bg_button.setSizePolicy(
            QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )
        self.transparent_bg_button.clicked.connect(self.set_bg_transparent)
        color_layout.addWidget(self.transparent_bg_button)
        color_layout.addStretch()
        layout.addLayout(color_layout)  # [6629]
        self.update_text_color_button_style()
        self.update_bg_color_button_style()
        self.update_transparent_button_style()

        align_layout = QHBoxLayout()
        self.align_combo = QComboBox()
        self.align_combo.addItems(["left", "center", "right", "justify"])
        current_align = props.get("alignment", "left")
        current_align = (
            current_align
            if current_align in ["left", "center", "right", "justify"]
            else "left"
        )
        self.align_combo.setCurrentText(current_align)
        align_layout.addWidget(QLabel("Alignment:"))
        align_layout.addWidget(self.align_combo)
        align_layout.addStretch()
        layout.addLayout(align_layout)

        curve_layout = QHBoxLayout()
        curve_layout.addWidget(QLabel("Curve Angle:"))
        self.curve_angle_spin = QSpinBox()  # [6630]
        self.curve_angle_spin.setRange(-360, 360)
        self.curve_angle_spin.setValue(props.get("curve_angle", 0))
        self.curve_angle_spin.setToolTip(
            "Text curve angle (-360 to 360°, 0 = straight)"
        )
        self.curve_angle_spin.setSuffix("°")
        curve_layout.addWidget(self.curve_angle_spin)
        curve_layout.addStretch()
        if props.get("is_angle_display", False):
            self.curve_angle_spin.setVisible(False)
            curve_layout.itemAt(0).widget().setVisible(False)  # [6631]
        layout.addLayout(curve_layout)

        button_layout = QHBoxLayout()
        info_label = QLabel(
            "<small><i>Clear & OK = DELETE Shape (if empty)</i></small>"
        )
        info_label.setAlignment(
            Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
        )
        button_layout.addWidget(info_label)
        button_layout.addStretch()
        clear_button = QPushButton("Clear")
        clear_button.clicked.connect(self.on_clear_button_clicked)
        if is_mpoint_label_style or is_angle_text_style_edit:
            clear_button.setVisible(False)
            info_label.setVisible(False)
        clear_button.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)
        button_layout.addWidget(clear_button)  # [6632]
        ok_button = QPushButton("OK")
        ok_button.clicked.connect(self.accept)
        ok_button.setDefault(True)
        ok_button.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.reject)
        cancel_button.setSizePolicy(
            QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)

        self.setMinimumWidth(400)
        if is_mpoint_label_style or is_angle_text_style_edit:
            self.font_combo.setFocus()
        else:
            self.text_edit.setFocus()  # [6633]

    @Slot()
    def on_clear_button_clicked(self):
        """Handles the 'Clear' button click, clearing the text and marking."""
        self.text_edit.clear()
        self.text_cleared = True

    @Slot()
    def set_bg_transparent(self):
        """Sets the background color to None (transparent)."""
        self.bg_color = None
        self.update_bg_color_button_style()
        self.update_transparent_button_style()

    def update_text_color_button_style(self):  # [6634]
        """Updates the style of the text color preview button."""
        if not hasattr(self, "text_color") or not self.text_color.isValid():
            bg_color_css = "#000000"
            text_color_css = "white"
        else:
            bg_color_css = self.text_color.name(QColor.NameFormat.HexRgb)
            text_color_css = "white" if self.text_color.lightnessF() < 0.5 else "black"
        self.text_color_button.setStyleSheet(
            f"background-color: {bg_color_css}; color: {text_color_css}; border: 1px solid grey; padding: 3px;"
        )
        self.text_color_button.setSizePolicy(
            QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )

    def update_bg_color_button_style(self):
        """Updates the style of the background color preview button."""
        if (
            hasattr(self, "bg_color")
            and self.bg_color
            and self.bg_color.isValid()
            and self.bg_color.alpha() > 0
        ):
            color_name = self.bg_color.name(QColor.NameFormat.HexArgb)
            text_color = "white" if self.bg_color.lightnessF() < 0.5 else "black"
            self.bg_color_button.setText("BG Color")  # [6635]
            self.bg_color_button.setStyleSheet(
                f"background-color: {color_name}; color: {text_color}; border: 1px solid grey; padding: 3px;"
            )
            self.bg_color_button.setToolTip(f"Current BG: {color_name}")
        else:
            self.bg_color_button.setText("BG Color")
            self.bg_color_button.setStyleSheet(
                "background-color: none; color: black; border: 1px dashed grey; padding: 3px;"
            )
            self.bg_color_button.setToolTip("Current BG: None")
        self.bg_color_button.setSizePolicy(
            QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )

    def update_transparent_button_style(self):
        """Updates the style of the 'Transparent' button."""
        is_transparent = not (
            hasattr(self, "bg_color")
            and self.bg_color
            and self.bg_color.isValid()
            and self.bg_color.alpha() > 0
        )
        self.transparent_bg_button.setStyleSheet(
            f"border: {'2px solid red' if is_transparent else '1px solid grey'}; padding: 3px;"
        )  # [6636]

    def choose_text_color(self):
        """Opens a color dialog to choose the text color."""
        initial_text_color = (
            self.text_color
            if hasattr(self, "text_color") and self.text_color.isValid()
            else QColor(Qt.GlobalColor.black)
        )
        color = QColorDialog.getColor(initial_text_color, self, "Choose Text Color")
        if color.isValid():
            self.text_color = color
            self.update_text_color_button_style()

    def choose_bg_color(self):
        """Opens a color dialog to choose the background color."""
        initial_color = (
            self.bg_color
            if hasattr(self, "bg_color") and self.bg_color and self.bg_color.isValid()
            else QColor(Qt.GlobalColor.white)
        )  # [6637]
        if initial_color.alpha() == 0:
            initial_color.setAlpha(255)
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Background Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )
        if color.isValid():
            self.bg_color = None if color.alpha() == 0 else color
        self.update_bg_color_button_style()
        self.update_transparent_button_style()

    def get_properties(self):
        """Returns the current properties set in the dialog as a dictionary."""
        bg_color_val = (
            self.bg_color.name(QColor.NameFormat.HexArgb)
            if hasattr(self, "bg_color") and self.bg_color and self.bg_color.isValid()
            else None
        )
        text_color_val = (
            self.text_color.name(QColor.NameFormat.HexRgb)
            if hasattr(self, "text_color") and self.text_color.isValid()
            else "#000000"
        )

        props = {  # [6638]
            "font": self.font_combo.currentFont().family(),
            "size": self.size_spin.value(),
            "bold": self.bold_check.isChecked(),
            "italic": self.italic_check.isChecked(),
            "underline": self.underline_check.isChecked(),
            "strikeout": self.strikeout_check.isChecked(),
            "color": text_color_val,
            "background_color": bg_color_val,
            "alignment": self.align_combo.currentText(),  # [6639]
            "curve_angle": self.curve_angle_spin.value(),
            "is_angle_display": self.is_angle_text_style_edit
            or self.is_angle_text_content_edit,
        }
        if not self.is_mpoint_label_style_edit and not self.is_angle_text_style_edit:
            props["text"] = self.text_edit.toPlainText()

        return deepcopy(props)


class AuthorInfoDialog(QDialog):
    def __init__(self, parent=None):
        """Initializes the Author Information Dialog."""  # [6640]
        super().__init__(parent)
        self.setWindowTitle("Author Information")
        self.setWindowFlags(
            self.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint
        )

        layout = QVBoxLayout(self)

        info_label = QLabel()
        info_label.setTextInteractionFlags(
            Qt.TextInteractionFlag.TextSelectableByMouse
            | Qt.TextInteractionFlag.TextSelectableByKeyboard
            | Qt.TextInteractionFlag.LinksAccessibleByMouse
        )
        info_label.setOpenExternalLinks(True)
        info_label.setTextFormat(Qt.TextFormat.RichText)  # [6641]
        info_label.setText("""
        <p style="margin-bottom: 10px;"><b>Author:</b> marek7400</p>
        <p style="margin-bottom: 10px;"><b>YouTube:</b> <a style="color: #007BFF;" href="https://www.youtube.com/@marek7400/">https://www.youtube.com/@marek7400/</a></p>
        <p style="margin-bottom: 0px;"><b>Email:</b> fbox3tv33@gmail.com</p>
        """)
        info_label.setSizePolicy(
            QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum
        )
        info_label.setWordWrap(True)

        layout.addWidget(info_label)  # [6642]

        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
        button_box.accepted.connect(self.accept)
        layout.addWidget(button_box)

        self.adjustSize()


class AnimationConfigDialog(QDialog):
    """Dialog for configuring scene animation parameters."""

    def __init__(self, scene_files, parent=None):  # [6643]
        super().__init__(parent)
        self.settings = QSettings("MyCompany", "DesktopOverlayRGN")
        self.setWindowTitle("Animation Configuration")
        self.setMinimumWidth(650)
        self.scene_files = scene_files
        self.control_panel = parent

        layout = QVBoxLayout(self)
        grid_layout = QGridLayout()

        row = 0  # [6644]
        grid_layout.addWidget(QLabel("Start Delay (s):"), row, 0)
        self.start_delay_spin = QDoubleSpinBox()
        self.start_delay_spin.setRange(0.0, 300.0)
        self.start_delay_spin.setDecimals(3)
        self.start_delay_spin.setValue(
            self.settings.value("animation/startDelay", 1.0, type=float)
        )
        grid_layout.addWidget(self.start_delay_spin, row, 1)
        row += 1

        time_mode_layout = QHBoxLayout()
        self.time_mode_auto_check = QCheckBox("Automatic Time")  # [6645]
        self.time_mode_auto_check.setToolTip(
            "Use 'Interval' and 'Default Time' for all scenes."
        )
        self.time_mode_auto_check.setChecked(
            self.settings.value("animation/timeModeAuto", True, type=bool)
        )
        self.time_mode_auto_check.toggled.connect(self._on_time_mode_changed)
        time_mode_layout.addWidget(self.time_mode_auto_check)
        time_mode_layout.addStretch()
        grid_layout.addLayout(time_mode_layout, row, 0, 1, 2)
        row += 1

        self.interval_label = QLabel("Interval Between Scenes (s):")
        grid_layout.addWidget(self.interval_label, row, 0)  # [6646]
        self.interval_spin = QDoubleSpinBox()
        self.interval_spin.setRange(0.0, 60.0)
        self.interval_spin.setDecimals(4)
        self.interval_spin.setValue(
            self.settings.value("animation/interval", 0.5, type=float)
        )
        grid_layout.addWidget(self.interval_spin, row, 1)
        row += 1

        self.default_time_label = QLabel("Default Scene Display Time (s):")
        grid_layout.addWidget(self.default_time_label, row, 0)
        self.default_time_spin = QDoubleSpinBox()  # [6647]
        self.default_time_spin.setRange(0.001, 300.0)
        self.default_time_spin.setDecimals(4)
        self.default_time_spin.setValue(
            self.settings.value("animation/defaultTime", 2.0, type=float)
        )
        self.default_time_spin.valueChanged.connect(self._update_default_times_in_list)
        grid_layout.addWidget(self.default_time_spin, row, 1)
        row += 1

        grid_layout.addWidget(QLabel("Load Mode:"), row, 0)
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["EDIT", "BOARD"])
        self.mode_combo.setCurrentText(
            self.settings.value("animation/mode", "EDIT")
        )  # [6648]
        grid_layout.addWidget(self.mode_combo, row, 1)
        row += 1

        self.play_mode_group = QButtonGroup(self)
        self.play_mode_group.setExclusive(True)
        play_layout = QVBoxLayout()
        play_layout.setSpacing(2)
        self.play_front_check = QCheckBox("Play from front")
        self.play_back_check = QCheckBox("Play from back")
        self.play_pingpong_front_check = QCheckBox(
            "Play from front then back (Ping-Pong)"
        )
        self.play_pingpong_back_check = QCheckBox(
            "Play from back then forward (Ping-Pong)"
        )  # [6649]
        self.play_mode_group.addButton(self.play_front_check)
        self.play_mode_group.addButton(self.play_back_check)
        self.play_mode_group.addButton(self.play_pingpong_front_check)
        self.play_mode_group.addButton(self.play_pingpong_back_check)
        play_layout.addWidget(self.play_front_check)
        play_layout.addWidget(self.play_back_check)
        play_layout.addWidget(self.play_pingpong_front_check)
        play_layout.addWidget(self.play_pingpong_back_check)
        self.play_loop_check = QCheckBox("Loop")
        self.play_loop_check.setToolTip("Repeat the sequence after finishing")
        play_layout.addWidget(self.play_loop_check)
        grid_layout.addWidget(
            QLabel("Playback Type:"), row, 0, alignment=Qt.AlignmentFlag.AlignTop
        )
        grid_layout.addLayout(play_layout, row, 1)
        row += 1  # [6650]

        self.play_front_check.setChecked(
            self.settings.value("animation/playFront", True, type=bool)
        )
        self.play_back_check.setChecked(
            self.settings.value("animation/playBack", False, type=bool)
        )
        self.play_pingpong_front_check.setChecked(
            self.settings.value("animation/pingpongFront", False, type=bool)
        )
        self.play_pingpong_back_check.setChecked(
            self.settings.value("animation/pingpongBack", False, type=bool)
        )
        self.play_loop_check.setChecked(
            self.settings.value("animation/loop", False, type=bool)
        )
        if not self.play_mode_group.checkedButton():
            self.play_front_check.setChecked(True)

        layout.addLayout(grid_layout)  # [6651]

        header_layout = QHBoxLayout()
        header_layout.setContentsMargins(2, 2, 2, 2)
        header_layout.setSpacing(5)

        self.select_all_include_check = QCheckBox("All Incl.")
        self.select_all_include_check.setToolTip(
            "Toggle all 'Include Scene' checkboxes"
        )
        self.select_all_include_check.stateChanged.connect(
            lambda state, col_idx=0: self._toggle_all_column_checkboxes(col_idx, state)
        )
        header_layout.addWidget(self.select_all_include_check)

        self.select_all_sh_check = QCheckBox("All S/H")  # [6652]
        self.select_all_sh_check.setToolTip("Toggle all 'Show/Hide Preview' checkboxes")
        self.select_all_sh_check.stateChanged.connect(
            lambda state, col_idx=1: self._toggle_all_column_checkboxes(col_idx, state)
        )
        header_layout.addWidget(self.select_all_sh_check)

        self.select_all_clr_check = QCheckBox("All Clr?")
        self.select_all_clr_check.setToolTip("Toggle all 'Clear After' checkboxes")
        self.select_all_clr_check.stateChanged.connect(
            lambda state, col_idx=2: self._toggle_all_column_checkboxes(col_idx, state)
        )
        header_layout.addWidget(self.select_all_clr_check)

        header_layout.addStretch()  # [6653]

        self.select_all_t_check = QCheckBox("All T>")
        self.select_all_t_check.setToolTip(
            "Toggle all 'Enable custom interval' checkboxes"
        )
        self.select_all_t_check.stateChanged.connect(
            lambda state, col_idx=3: self._toggle_all_column_checkboxes(col_idx, state)
        )
        header_layout.insertStretch(3, 150)
        header_layout.insertStretch(4, 80)
        header_layout.addWidget(self.select_all_t_check)
        header_layout.addSpacing(80)

        layout.addWidget(QLabel("Scenes (Edit times per scene, 0=Default):"))  # [6654]
        layout.addLayout(header_layout)

        self.scene_list_widget = QListWidget()
        self.scene_list_widget.setStyleSheet("QListWidget::item { padding: 3px; }")
        self.scene_item_widgets = []

        for i, filepath in enumerate(self.scene_files):
            item_widget = QWidget()
            item_layout = QHBoxLayout(item_widget)
            item_layout.setContentsMargins(2, 2, 2, 2)  # [6655]
            item_layout.setSpacing(5)

            include_scene_checkbox = QCheckBox("")
            include_scene_checkbox.setToolTip("Include this scene in the animation")
            include_scene_checkbox.setChecked(
                self.settings.value(
                    f"animation/scene_{i}_include_in_animation", True, type=bool
                )
            )
            item_layout.addWidget(include_scene_checkbox)

            show_hide_checkbox = QCheckBox("S/H")
            show_hide_checkbox.setToolTip(
                "Show/Hide this scene in the preview overlay (loads/unloads shapes)"
            )
            show_hide_checkbox.setChecked(
                self.settings.value(
                    f"animation/scene_{i}_preview_sh_checked", False, type=bool
                )
            )  # [6656]
            show_hide_checkbox.toggled.connect(
                functools.partial(
                    self.control_panel.toggle_preview_animation_scene, filepath
                )
            )
            item_layout.addWidget(show_hide_checkbox)

            clear_checkbox = QCheckBox("Clr?")
            clear_checkbox.setToolTip("Clear this scene before loading the next one")
            clear_checkbox.setChecked(
                self.settings.value(
                    f"animation/scene_{i}_clear_after", False, type=bool
                )
            )
            item_layout.addWidget(clear_checkbox)

            filename_label = QLabel(os.path.basename(filepath))  # [6657]
            filename_label.setToolTip(filepath)
            item_layout.addWidget(filename_label)
            item_layout.addStretch()

            start_time_spin = QDoubleSpinBox()
            start_time_spin.setRange(0.0, 9999.0)
            start_time_spin.setDecimals(3)
            start_time_spin.setValue(
                self.settings.value(
                    f"animation/scene_{i}_individual_start_time", 0.0, type=float
                )
            )
            start_time_spin.setToolTip(
                "Individual start time from animation beginning (s).\n0 = sequential after previous scene."
            )
            start_time_spin.setFixedWidth(80)  # [6658]
            start_time_spin.setSpecialValueText("Seq.")
            item_layout.addWidget(start_time_spin)

            time_spin = QDoubleSpinBox()
            time_spin.setRange(0.0, 300.0)
            time_spin.setDecimals(4)
            time_spin.setValue(
                self.settings.value(
                    f"animation/scene_{i}_individual_time", 1.0, type=float
                )
            )
            time_spin.setToolTip("Individual display time (0 = use Default)")
            time_spin.setFixedWidth(80)
            item_layout.addWidget(time_spin)  # [6659]

            between_time_check = QCheckBox("T>")
            between_time_check.setToolTip("Enable custom interval after this scene")
            between_time_check.setChecked(
                self.settings.value(
                    f"animation/scene_{i}_use_between_time", False, type=bool
                )
            )
            item_layout.addWidget(between_time_check)

            between_time_spin = QDoubleSpinBox()
            between_time_spin.setRange(0.0, 60.0)
            between_time_spin.setDecimals(4)
            default_between_time_for_scene = self.settings.value(
                f"animation/scene_{i}_between_time_explicit", 1.0, type=float
            )  # [6660]
            if not self.settings.contains(f"animation/scene_{i}_between_time_explicit"):
                default_between_time_for_scene = self.interval_spin.value()
            between_time_spin.setValue(
                self.settings.value(
                    f"animation/scene_{i}_between_time",
                    default_between_time_for_scene,
                    type=float,
                )
            )
            between_time_spin.setToolTip("Interval after this scene (if 'T>' checked)")
            between_time_spin.setFixedWidth(80)
            between_time_spin.setEnabled(between_time_check.isChecked())
            item_layout.addWidget(between_time_spin)

            between_time_check.toggled.connect(between_time_spin.setEnabled)

            list_item = QListWidgetItem(self.scene_list_widget)  # [6661]
            list_item.setSizeHint(item_widget.sizeHint())
            self.scene_list_widget.addItem(list_item)
            self.scene_list_widget.setItemWidget(list_item, item_widget)

            self.scene_item_widgets.append(
                {
                    "widget": item_widget,
                    "include_scene_checkbox": include_scene_checkbox,
                    "show_hide_checkbox": show_hide_checkbox,
                    "clear_checkbox": clear_checkbox,
                    "start_time_spin": start_time_spin,  # [6662]
                    "time_spin": time_spin,
                    "between_time_check": between_time_check,
                    "between_time_spin": between_time_spin,
                    "filepath": filepath,
                }
            )
        self._on_time_mode_changed(self.time_mode_auto_check.isChecked())

        layout.addWidget(self.scene_list_widget)

        button_box = QDialogButtonBox()
        start_button = button_box.addButton(
            "Start", QDialogButtonBox.ButtonRole.AcceptRole
        )  # [6663]
        cancel_button = button_box.addButton(
            "Cancel", QDialogButtonBox.ButtonRole.RejectRole
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        self.adjust_dialog_height()

    def adjust_dialog_height(self):
        """Adjusts the dialog height to show all list items."""
        if not self.scene_list_widget.count():  # [6664]
            return

        min_sensible_height = 400
        max_sensible_height = (
            QGuiApplication.primaryScreen().availableGeometry().height() * 0.8
        )

        list_height = 0
        for i in range(self.scene_list_widget.count()):
            list_height += self.scene_list_widget.sizeHintForRow(i)
        list_height += self.scene_list_widget.spacing() * (
            self.scene_list_widget.count() - 1
        )
        list_height += (
            self.scene_list_widget.contentsMargins().top()
            + self.scene_list_widget.contentsMargins().bottom()
        )  # [6665]
        list_height += self.scene_list_widget.frameWidth() * 2

        other_widgets_height = 0
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and item.widget() != self.scene_list_widget:
                other_widgets_height += item.widget().sizeHint().height()
            elif item.layout():
                other_widgets_height += (
                    item.layout().sizeHint().height()
                    if item.layout().sizeHint().height() > 0
                    else 30
                )  # [6666]

        preferred_height = (
            list_height
            + other_widgets_height
            + self.layout().spacing() * (self.layout().count())
            + 20
        )

        final_height = max(
            min_sensible_height, min(preferred_height, max_sensible_height)
        )
        self.resize(self.width(), int(final_height))

    @Slot(int, int)
    def _toggle_all_column_checkboxes(self, column_index, check_state):
        """Toggles all checkboxes in a given column of the scene list."""
        is_checked = check_state == Qt.CheckState.Checked.value  # [6667]

        for item_data in self.scene_item_widgets:
            checkbox_to_toggle = None
            if column_index == 0:
                checkbox_to_toggle = item_data["include_scene_checkbox"]
            elif column_index == 1:
                checkbox_to_toggle = item_data["show_hide_checkbox"]
            elif column_index == 2:
                checkbox_to_toggle = item_data["clear_checkbox"]
            elif column_index == 3:  # [6668]
                checkbox_to_toggle = item_data["between_time_check"]

            if checkbox_to_toggle:
                checkbox_to_toggle.blockSignals(True)
                checkbox_to_toggle.setChecked(is_checked)
                checkbox_to_toggle.blockSignals(False)
                if column_index == 1:
                    self.control_panel.toggle_preview_animation_scene(
                        item_data["filepath"], is_checked
                    )
                elif column_index == 3:
                    item_data["between_time_spin"].setEnabled(is_checked)  # [6669]

    @Slot(bool)
    def _on_time_mode_changed(self, checked):
        is_auto = checked
        self.interval_label.setEnabled(is_auto)
        self.interval_spin.setEnabled(is_auto)
        self.default_time_label.setEnabled(is_auto)
        self.default_time_spin.setEnabled(is_auto)

        for item_data in self.scene_item_widgets:
            item_data["time_spin"].setEnabled(not is_auto)  # [6670]
            item_data["between_time_check"].setEnabled(not is_auto)
            item_data["between_time_spin"].setEnabled(
                not is_auto and item_data["between_time_check"].isChecked()
            )
            item_data["start_time_spin"].setEnabled(not is_auto)

    @Slot()
    def accept(self):
        self.control_panel.clear_all_previewed_animation_scenes()
        self.save_settings()
        super().accept()

    @Slot()  # [6671]
    def reject(self):
        self.control_panel.clear_all_previewed_animation_scenes()
        super().reject()

    def closeEvent(self, event):
        self.control_panel.clear_all_previewed_animation_scenes()
        super().closeEvent(event)

    def save_settings(self):
        self.settings.setValue("animation/startDelay", self.start_delay_spin.value())
        self.settings.setValue(
            "animation/timeModeAuto", self.time_mode_auto_check.isChecked()
        )  # [6672]
        self.settings.setValue("animation/interval", self.interval_spin.value())
        self.settings.setValue("animation/defaultTime", self.default_time_spin.value())
        self.settings.setValue("animation/mode", self.mode_combo.currentText())
        self.settings.setValue("animation/playFront", self.play_front_check.isChecked())
        self.settings.setValue("animation/playBack", self.play_back_check.isChecked())
        self.settings.setValue("animation/loop", self.play_loop_check.isChecked())
        self.settings.setValue(
            "animation/pingpongFront", self.play_pingpong_front_check.isChecked()
        )
        self.settings.setValue(
            "animation/pingpongBack", self.play_pingpong_back_check.isChecked()
        )

        for i, item_data in enumerate(self.scene_item_widgets):  # [6673]
            self.settings.setValue(
                f"animation/scene_{i}_individual_start_time",
                item_data["start_time_spin"].value(),
            )
            self.settings.setValue(
                f"animation/scene_{i}_individual_time", item_data["time_spin"].value()
            )
            self.settings.setValue(
                f"animation/scene_{i}_clear_after",
                item_data["clear_checkbox"].isChecked(),
            )
            self.settings.setValue(
                f"animation/scene_{i}_use_between_time",
                item_data["between_time_check"].isChecked(),
            )
            self.settings.setValue(
                f"animation/scene_{i}_between_time",
                item_data["between_time_spin"].value(),
            )
            self.settings.setValue(
                f"animation/scene_{i}_include_in_animation",
                item_data["include_scene_checkbox"].isChecked(),
            )
            self.settings.setValue(
                f"animation/scene_{i}_preview_sh_checked",
                item_data["show_hide_checkbox"].isChecked(),
            )
        print("Animation settings saved.")

    def _update_default_times_in_list(self, new_default_time):  # [6674]
        if self.time_mode_auto_check.isChecked():
            for item_data in self.scene_item_widgets:
                item_data["time_spin"].blockSignals(True)
                item_data["time_spin"].setValue(0)
                item_data["time_spin"].blockSignals(False)
                item_data["start_time_spin"].blockSignals(True)
                item_data["start_time_spin"].setValue(0)
                item_data["start_time_spin"].blockSignals(False)

    def get_parameters(self):  # [6675]
        return {
            "start_delay": self.start_delay_spin.value(),
            "time_mode_auto": self.time_mode_auto_check.isChecked(),
            "interval": self.interval_spin.value(),
            "default_time": self.default_time_spin.value(),
            "mode": self.mode_combo.currentText(),
            "play_front": self.play_front_check.isChecked(),
            "play_back": self.play_back_check.isChecked(),
            "loop": self.play_loop_check.isChecked(),  # [6676]
            "pingpong_front": self.play_pingpong_front_check.isChecked(),
            "pingpong_back": self.play_pingpong_back_check.isChecked(),
        }

    def get_scene_data(self):
        scene_data_list = []
        for item_data in self.scene_item_widgets:
            scene_data_list.append(
                {
                    "filepath": item_data["filepath"],
                    "individual_start_time": item_data[
                        "start_time_spin"
                    ].value(),  # [6677]
                    "display_time": item_data["time_spin"].value(),
                    "clear_after": item_data["clear_checkbox"].isChecked(),
                    "use_between_time": item_data["between_time_check"].isChecked(),
                    "between_time": item_data["between_time_spin"].value(),
                    "include_in_animation": item_data[
                        "include_scene_checkbox"
                    ].isChecked(),
                }
            )
        return scene_data_list


class ControlPanel(QDockWidget):
    def __init__(self, overlay):
        """Initializes the Control Panel dock widget."""  # [6678]
        super().__init__("Draw Desktop")
        self.overlay = overlay
        # self.main_app_parent = None
        self.setAllowedAreas(
            Qt.DockWidgetArea.LeftDockWidgetArea
            | Qt.DockWidgetArea.RightDockWidgetArea
            | Qt.DockWidgetArea.TopDockWidgetArea
            | Qt.DockWidgetArea.BottomDockWidgetArea
        )
        self.setFeatures(
            QDockWidget.DockWidgetFeature.DockWidgetMovable
            | QDockWidget.DockWidgetFeature.DockWidgetFloatable
            | QDockWidget.DockWidgetFeature.DockWidgetClosable
        )
        self.setFloating(True)
        self.setWindowFlags(
            Qt.WindowType.Window
            | Qt.WindowType.CustomizeWindowHint
            | Qt.WindowType.WindowTitleHint
            | Qt.WindowType.WindowMinimizeButtonHint
            | Qt.WindowType.WindowCloseButtonHint
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.WindowSystemMenuHint
        )
        self.shortcuts_window = None
        self.info_dialog = None  # [6679]
        self._initial_position_set = False  # [6680]
        self.settings = QSettings("MyCompany", "DesktopOverlayRGN")  # [6681]
        self.fixed_size_widgets = {}  # [6682]
        self.mpoint_widget_group = {}  # [6683]
        self.angle_tool_widget_group = {}  # [6684]
        self.hatch_fill_widget_group = {}  # [6685]
        self.division_settings_group = {}  # [6686]
        self._anim_dialog_previewed_scene_tags = {}  # [6687]
        self.zoom_enabled = False  # [6688]
        self._zoom_first_use_info_shown = False  # [6689]

        self._dragging_window = False  # [6690]
        self._drag_window_offset = QPoint()  # [6691]

        widget = QWidget()
        self.setWidget(widget)  # [6692]
        layout = QVBoxLayout(widget)
        layout.setSpacing(5)
        layout.setContentsMargins(5, 5, 5, 5)  # [6693]

        # Change 3: Transparency and Thickness in one row
        top_row1_layout = QHBoxLayout()  # [6694]
        alpha_layout = QHBoxLayout()
        alpha_layout.addWidget(QLabel("Transparency:"))  # [6695]
        self.alpha_spin = QSpinBox()
        self.alpha_spin.setRange(0, 100)
        self.alpha_spin.setSuffix("%")
        self.alpha_spin.setToolTip(
            "Shape Opacity (0%=Transparent, 100%=Opaque)\nShortcut: Shift + PageUp/Down"
        )  # [6696]
        alpha_layout.addWidget(self.alpha_spin)
        top_row1_layout.addLayout(alpha_layout)  # [6697]

        thickness_layout = QHBoxLayout()
        thickness_layout.addWidget(QLabel("Thickness:"))  # [6698]
        self.thickness_spin = QSpinBox()
        self.thickness_spin.setRange(1, 50)
        self.thickness_spin.setToolTip("Line/Outline Thickness (px)")  # [6699]
        thickness_layout.addWidget(self.thickness_spin)
        top_row1_layout.addLayout(thickness_layout)  # [6700]

        self.exit_button = QPushButton("EXIT")
        self.exit_button.setToolTip("Save settings and exit application")
        self.exit_button.setObjectName("ExitButton")  # Can be used for styling
        self.exit_button.setFixedSize(
            60, self.thickness_spin.sizeHint().height()
        )  # Adjust size
        top_row1_layout.addWidget(self.exit_button)

        top_row1_layout.addStretch()  # [6701]
        layout.addLayout(top_row1_layout)  # [6702]

        # Change 3: Arrow Head and Brush Size in one row # [6703]
        top_row2_layout = QHBoxLayout()  # [6704]
        arrow_size_layout = QHBoxLayout()
        arrow_size_layout.addWidget(QLabel("Arrow Head:"))  # [6705]
        self.arrow_size_spin = QSpinBox()
        self.arrow_size_spin.setRange(1, 100)
        self.arrow_size_spin.setToolTip(
            "Arrow Head Size (px)\nShortcut: Ctrl + PageUp/Down"
        )  # [6706]
        arrow_size_layout.addWidget(self.arrow_size_spin)
        top_row2_layout.addLayout(arrow_size_layout)  # [6707]

        brush_size_layout = QHBoxLayout()
        brush_size_layout.addWidget(QLabel("Brush Size:"))  # [6708]
        self.brush_size_spin = QSpinBox()
        self.brush_size_spin.setRange(1, 100)
        self.brush_size_spin.setToolTip(
            "Brush Size (px)\nShortcut: Alt + PageUp/Down"
        )  # [6709]
        brush_size_layout.addWidget(self.brush_size_spin)
        top_row2_layout.addLayout(brush_size_layout)  # [6710]
        top_row2_layout.addStretch()  # [6711]
        layout.addLayout(top_row2_layout)  # [6712]

        # Change 3: Time and Style in one row
        top_row3_layout = QHBoxLayout()  # [6713]
        temp_time_layout = QHBoxLayout()
        temp_time_layout.addWidget(QLabel("Time (s):"))  # [6714]
        self.time_spin = QDoubleSpinBox()
        self.time_spin.setRange(0.1, 60.0)  # [6715]
        self.time_spin.setDecimals(3)  # [6716]
        self.time_spin.setToolTip(
            "Duration for shapes in TEMP mode (seconds)"
        )  # [6717]
        temp_time_layout.addWidget(self.time_spin)
        top_row3_layout.addLayout(temp_time_layout)  # [6718]

        self._create_line_style_combo(top_row3_layout)  # Pass QHBoxLayout # [6719]
        top_row3_layout.addStretch()  # [6720]
        layout.addLayout(top_row3_layout)  # [6721]

        fill_back_layout = QHBoxLayout()  # [6722]
        self.fill_check = QCheckBox("Fill Shapes")
        self.fill_check.setToolTip(
            "Fill Rects, Ellipses, Triangles, Polygons, Trapezes, Reg. Polygons, Arcs, MPoints (Toggle Selected: Numpad /)"
        )  # [6723]
        fill_back_layout.addWidget(self.fill_check)  # [6724]
        # Change 3: HIDE button next to ZOOM
        self.zoom_button = QPushButton("ZOOM")  # [6725]
        self.zoom_button.setCheckable(True)  # [6726]
        self.zoom_button.setToolTip(
            "Toggle Windows Magnifier (Win + '+') / (Win + 'Esc')"
        )  # [6727]
        self.zoom_button.clicked.connect(self.toggle_zoom_button_handler)  # [6728]
        fill_back_layout.addWidget(self.zoom_button)  # [6729]

        self.hide_shapes_button = QPushButton("HIDE")
        self.hide_shapes_button.setCheckable(True)
        self.hide_shapes_button.setToolTip(
            "Toggle visibility of all shapes (H)"
        )  # [6730]
        self.hide_shapes_button.clicked.connect(
            self.overlay.toggle_shapes_visibility
        )  # [6731]
        fill_back_layout.addWidget(self.hide_shapes_button)  # [6732]

        self.dark_mode_button = QPushButton("DARK")  # [6733] # NEW LINE
        self.dark_mode_button.setCheckable(True)  # [6734] # NEW LINE
        self.dark_mode_button.setToolTip("Toggle Dark/Light Theme")  # [6735] # NEW LINE
        self.dark_mode_button.clicked.connect(
            self.toggle_dark_mode
        )  # [6736] # NEW LINE
        fill_back_layout.addWidget(self.dark_mode_button)  # [6737] # NEW LINE

        fill_back_layout.addStretch()  # [6738]
        layout.addLayout(fill_back_layout)  # [6739]

        hatch_group_box = QGroupBox("Hatch Fill")  # [6740]
        hatch_layout_outer = QVBoxLayout(hatch_group_box)  # [6741]
        hatch_layout_inner = QHBoxLayout()  # [6742]

        self.hatch_forward_slash_check = QCheckBox("/")  # [6743]
        self.hatch_forward_slash_check.setToolTip(
            "Forward Slash Hatch (/) \nShortcut: /"
        )  # [6744]
        hatch_layout_inner.addWidget(self.hatch_forward_slash_check)  # [6745]

        self.hatch_backward_slash_check = QCheckBox("\\")  # [6746]
        self.hatch_backward_slash_check.setToolTip(
            "Backward Slash Hatch (\\) \nShortcut: \\"
        )  # [6747]
        hatch_layout_inner.addWidget(self.hatch_backward_slash_check)  # [6748]

        self.hatch_horizontal_check = QCheckBox("—")  # [6749]
        self.hatch_horizontal_check.setToolTip(
            "Horizontal Hatch (-) \nShortcut: _ (Shift + -)"
        )  # [6750]
        hatch_layout_inner.addWidget(self.hatch_horizontal_check)  # [6751]

        self.hatch_vertical_check = QCheckBox("|")  # [6752]
        self.hatch_vertical_check.setToolTip(
            "Vertical Hatch (|) \nShortcut: | (Shift + \\)"
        )  # [6753]
        hatch_layout_inner.addWidget(self.hatch_vertical_check)  # [6754]

        hatch_layout_inner.addSpacing(10)  # [6755]

        self.hatch_thickness_spin = QSpinBox()  # [6756]
        self.hatch_thickness_spin.setRange(1, 10)  # [6757]
        self.hatch_thickness_spin.setValue(
            self.overlay.current_hatch_thickness
        )  # [6758]
        self.hatch_thickness_spin.setToolTip("Hatch Line Thickness")  # [6759]
        self.hatch_thickness_spin.setSuffix("px")  # [6760]
        hatch_layout_inner.addWidget(QLabel("T:"))  # [6761]
        hatch_layout_inner.addWidget(self.hatch_thickness_spin)  # [6762]

        hatch_layout_inner.addSpacing(5)  # [6763]

        self.hatch_color_button = QPushButton("")  # [6764]
        self.hatch_color_button.setFixedSize(20, 20)  # [6765]
        self.hatch_color_button.setToolTip("Hatch Line Color")  # [6766]
        self.hatch_color_button.clicked.connect(self.choose_hatch_fill_color)  # [6767]
        hatch_layout_inner.addWidget(self.hatch_color_button)  # [6768]
        hatch_layout_inner.addStretch()  # [6769]

        hatch_layout_outer.addLayout(hatch_layout_inner)  # [6770]
        layout.addWidget(hatch_group_box)  # [6771]

        self.hatch_widget_group = {  # [6772]
            "forward_slash": self.hatch_forward_slash_check,  # [6773]
            "backward_slash": self.hatch_backward_slash_check,  # [6774]
            "horizontal": self.hatch_horizontal_check,  # [6775]
            "vertical": self.hatch_vertical_check,  # [6776]
            "thickness_spin": self.hatch_thickness_spin,  # [6777]
            "color_button": self.hatch_color_button,  # [6778]
        }  # [6779]
        self.hatch_forward_slash_check.stateChanged.connect(  # [6780]
            lambda state,
            style_name="forward_slash": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [6781]
        )  # [6782]
        self.hatch_backward_slash_check.stateChanged.connect(  # [6783]
            lambda state,
            style_name="backward_slash": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [6784]
        )  # [6785]
        self.hatch_horizontal_check.stateChanged.connect(  # [6786]
            lambda state, style_name="horizontal": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [6787]
        )  # [6788]
        self.hatch_vertical_check.stateChanged.connect(  # [6789]
            lambda state, style_name="vertical": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [6790]
        )  # [6791]
        self.hatch_thickness_spin.valueChanged.connect(
            self._update_hatch_settings_from_ui
        )  # [6792]

        division_group_box = QGroupBox("Division Settings")  # [6793]
        division_layout_outer = QVBoxLayout(division_group_box)  # [6794]
        division_layout_inner = QHBoxLayout()  # [6795]

        self.divide_check = QCheckBox("Divide (V)")
        self.divide_check.setToolTip("Divide shape segments (V)")  # [6796]
        self.divide_check.stateChanged.connect(
            lambda state: self.overlay.set_divide_enabled(
                state == Qt.CheckState.Checked.value
            )
        )  # [6797]
        division_layout_inner.addWidget(self.divide_check)  # [6798]

        self.divisions_spin = QSpinBox()
        self.divisions_spin.setRange(2, 100)  # [6799]
        self.divisions_spin.setValue(self.overlay.number_of_divisions)
        self.divisions_spin.setToolTip("Number of divisions (min 2)")  # [6800]
        self.divisions_spin.valueChanged.connect(
            self.overlay.set_number_of_divisions
        )  # [6801]
        division_layout_inner.addWidget(self.divisions_spin)  # [6802]

        division_layout_inner.addSpacing(10)  # [6803]

        self.division_point_color_button = QPushButton("")  # [6804]
        self.division_point_color_button.setFixedSize(20, 20)  # [6805]
        self.division_point_color_button.setToolTip("Division Point Color")  # [6806]
        self.division_point_color_button.clicked.connect(
            self.choose_division_point_color
        )  # [6807]
        division_layout_inner.addWidget(self.division_point_color_button)  # [6808]

        division_layout_inner.addWidget(QLabel("Size:"))  # [6809]
        self.division_point_size_spin = QDoubleSpinBox()  # [6810]
        self.division_point_size_spin.setRange(1.0, 20.0)  # [6811]
        self.division_point_size_spin.setDecimals(1)  # [6812]
        self.division_point_size_spin.setSingleStep(0.5)  # [6813]
        self.division_point_size_spin.setValue(
            self.overlay.division_point_size
        )  # [6814]
        self.division_point_size_spin.setToolTip("Division Point Diameter")  # [6815]
        self.division_point_size_spin.setSuffix("px")  # [6816]
        division_layout_inner.addWidget(self.division_point_size_spin)  # [6817]
        division_layout_inner.addStretch()  # [6818]

        division_layout_outer.addLayout(division_layout_inner)  # [6819]
        layout.addWidget(division_group_box)  # [6820]

        self.division_settings_group = {  # [6821]
            "divide_check": self.divide_check,  # [6822]
            "divisions_spin": self.divisions_spin,  # [6823]
            "color_button": self.division_point_color_button,  # [6824]
            "size_spin": self.division_point_size_spin,  # [6825]
        }  # [6826]
        self.overlay.divide_enabled_changed.connect(
            self.update_divide_controls_visuals_slot_bool
        )  # [6827]
        self.overlay.number_of_divisions_changed.connect(
            self.update_divide_controls_visuals_slot_int
        )  # [6828]
        self.overlay.division_point_color_changed.connect(
            self.update_division_point_color_button_style
        )  # [6829]
        self.division_point_size_spin.valueChanged.connect(
            self.overlay.set_division_point_size
        )  # [6830]

        # --- Adding Lines, Grid, and Snap controls --- # [6831]
        external_tools_group = QGroupBox("External Overlay & Snap Tools")  # [6832]
        external_tools_layout = QVBoxLayout(external_tools_group)  # [6833]

        # Change 3: Grid and Set.G next to Set.L
        lines_grid_layout = QHBoxLayout()  # [6834]
        self.lines_toggle_checkbox = QCheckBox("Lines")  # [6835]
        self.lines_toggle_checkbox.setToolTip(
            "Toggle Guide Lines visibility (Alt+Shift+Home)"
        )  # [6836]
        self.lines_toggle_checkbox.stateChanged.connect(
            self._handle_lines_toggle_checkbox
        )  # [6837]
        lines_grid_layout.addWidget(self.lines_toggle_checkbox)  # [6838]
        self.lines_settings_button = QPushButton("Set.L")  # [6839]
        self.lines_settings_button.setToolTip(
            "Open Guide Lines Appearance Settings"
        )  # [6840]
        self.lines_settings_button.clicked.connect(
            self._handle_lines_settings_button
        )  # [6841]
        self.lines_settings_button.setFixedSize(
            self.lines_settings_button.fontMetrics().horizontalAdvance("Set.L") + 10,
            self.lines_toggle_checkbox.sizeHint().height(),
        )  # [6842]
        lines_grid_layout.addWidget(self.lines_settings_button)  # [6843]

        self.grid_toggle_checkbox = QCheckBox("Grid")  # [6844]
        self.grid_toggle_checkbox.setToolTip(
            "Toggle Grid visibility (Ctrl+Alt+F10)"
        )  # [6845]
        self.grid_toggle_checkbox.stateChanged.connect(
            self._handle_grid_toggle_checkbox
        )  # [6846]
        lines_grid_layout.addWidget(self.grid_toggle_checkbox)  # [6847]
        self.grid_settings_button = QPushButton("Set.G")  # [6848]
        self.grid_settings_button.setToolTip("Open Grid Settings")  # [6849]
        self.grid_settings_button.clicked.connect(
            self._handle_grid_settings_button
        )  # [6850]
        self.grid_settings_button.setFixedSize(
            self.grid_settings_button.fontMetrics().horizontalAdvance("Set.G") + 10,
            self.grid_toggle_checkbox.sizeHint().height(),
        )  # [6851]
        lines_grid_layout.addWidget(self.grid_settings_button)  # [6852]
        lines_grid_layout.addStretch()  # [6853]
        external_tools_layout.addLayout(lines_grid_layout)  # [6854]

        # Snap Controls # [6855]
        snap_options_group = QGroupBox("Snapping Mode")  # [6856]
        snap_options_layout = QHBoxLayout(snap_options_group)  # [6857]
        self.snap_button_group = QButtonGroup(self)  # [6858]
        self.snap_button_group.setExclusive(True)  # [6859]

        self.snap_to_lines_checkbox = QRadioButton("S2L")  # [6860]
        self.snap_to_lines_checkbox.setToolTip(
            "Snap to Guide Lines (Alt+Shift+F1)"
        )  # [6861]
        self.snap_button_group.addButton(self.snap_to_lines_checkbox)  # [6862]
        snap_options_layout.addWidget(self.snap_to_lines_checkbox)  # [6863]

        self.snap_to_grid_checkbox = QRadioButton("S2G")  # [6864]
        self.snap_to_grid_checkbox.setToolTip(
            "Snap to Grid intersections/lines (Alt+Shift+F2)"
        )  # [6865]
        self.snap_button_group.addButton(self.snap_to_grid_checkbox)  # [6866]
        snap_options_layout.addWidget(self.snap_to_grid_checkbox)  # [6867]

        self.snap_to_all_checkbox = QRadioButton("S2A")  # [6868]
        self.snap_to_all_checkbox.setToolTip(
            "Snap to key points of other shapes (vertices, midpoints, etc.) (Alt+Shift+F3)"
        )  # [6869]
        self.snap_button_group.addButton(self.snap_to_all_checkbox)  # [6870]
        snap_options_layout.addWidget(self.snap_to_all_checkbox)  # [6871]

        self.snap_off_radio = QRadioButton("OFF")  # [6872]
        self.snap_off_radio.setToolTip("Turn off snapping")  # [6873]
        self.snap_button_group.addButton(self.snap_off_radio)  # [6874]
        snap_options_layout.addWidget(self.snap_off_radio)  # [6875]
        self.snap_off_radio.setChecked(True)  # Default to off # [6876]

        # Change 3: Sens next to OFF
        snap_sensitivity_label = QLabel("Sens:")  # [6877]
        snap_options_layout.addWidget(snap_sensitivity_label)  # [6878]

        self.snap_sensitivity_spinbox = QSpinBox()  # [6879]
        self.snap_sensitivity_spinbox.setRange(1, 100)  # [6880]
        self.snap_sensitivity_spinbox.setToolTip(
            "Snapping sensitivity (pixels)"
        )  # [6881]
        self.snap_sensitivity_spinbox.setSuffix("px")  # [6882]
        snap_options_layout.addWidget(self.snap_sensitivity_spinbox)  # [6883]
        snap_options_layout.addStretch()  # [6884]

        external_tools_layout.addWidget(snap_options_group)  # [6885]
        layout.addWidget(external_tools_group)  # [6886]

        # Connections for snap buttons # [6887]
        self.snap_to_lines_checkbox.toggled.connect(
            lambda checked: self.overlay.set_snap_mode("lines") if checked else None
        )  # [6888]
        self.snap_to_grid_checkbox.toggled.connect(
            lambda checked: self.overlay.set_snap_mode("grid") if checked else None
        )  # [6889]
        self.snap_to_all_checkbox.toggled.connect(
            lambda checked: self.overlay.set_snap_mode("all") if checked else None
        )  # [6890]
        self.snap_off_radio.toggled.connect(
            lambda checked: self.overlay.set_snap_mode("none") if checked else None
        )  # [6891]
        self.snap_sensitivity_spinbox.valueChanged.connect(
            self.overlay.set_snap_sensitivity
        )  # [6892]
        # Connections for signals from overlay to update UI # [6893]
        self.overlay.snap_mode_changed.connect(
            self.update_snap_controls_from_settings
        )  # [6894]
        self.overlay.snap_sensitivity_changed.connect(
            lambda s: self.snap_sensitivity_spinbox.setValue(s)
        )  # [6895]

        self.exit_button.clicked.connect(self._trigger_main_app_exit)

        # --- End of Snap controls addition --- # [6896]

        checkbox_layout = QHBoxLayout()  # [6897]
        self.dim_check = QCheckBox("Dimm")
        self.dim_check.setToolTip("Dim background in Normal drawing mode")  # [6898]
        checkbox_layout.addWidget(self.dim_check)  # [6899]
        self.clear_warning_check = QCheckBox("Clear W.")
        self.clear_warning_check.setToolTip(
            "Ask confirmation before clearing when exiting BOARD/EDIT mode"
        )  # [6900]
        checkbox_layout.addWidget(self.clear_warning_check)  # [6901]
        # HIDE button is already in fill_back_layout
        checkbox_layout.addStretch()  # [6902]
        layout.addLayout(checkbox_layout)  # [6903]

        indicator_layout = QHBoxLayout()  # [6904]
        self.tool_text_check = QCheckBox("Show Indicators")
        self.tool_text_check.setToolTip("Show tool name and mode indicators")  # [6905]
        indicator_layout.addWidget(self.tool_text_check)  # [6906]

        self.center_check = QCheckBox("Center")
        self.center_check.setToolTip("Show center point of shapes (C)")  # [6907]
        self.center_check.stateChanged.connect(
            lambda state: self.overlay.set_show_center_point(
                state == Qt.CheckState.Checked.value
            )
        )  # [6908]
        indicator_layout.addWidget(self.center_check)  # [6909]

        self.info_button = QPushButton("?")
        self.info_button.setFixedSize(
            self.tool_text_check.sizeHint().height(),
            self.tool_text_check.sizeHint().height(),
        )
        self.info_button.setToolTip("Show Author Info")  # [6910]
        self.info_button.clicked.connect(self.show_info_dialog)  # [6911]
        indicator_layout.addWidget(self.info_button)  # [6912]
        indicator_layout.addStretch()  # [6913]
        layout.addLayout(indicator_layout)  # [6914]

        tool_frame = QFrame()
        tool_frame.setFrameStyle(
            QFrame.Shape.StyledPanel | QFrame.Shadow.Plain
        )  # [6915]
        tool_layout_inner = QVBoxLayout(tool_frame)
        tool_layout_inner.setSpacing(2)
        tool_layout_inner.setContentsMargins(4, 4, 4, 4)  # [6916]
        tool_layout_inner.addWidget(QLabel("<b>Tools:</b>"))  # [6917]
        # Change 2: Sort tools alphabetically
        self.tools_config = sorted(
            [  # [6918]
                ("Angle (>)", "angle_marker"),  # [6919]
                ("Arc (U)", "arc"),
                ("Arrow (A)", "arrow"),
                ("Brush (B)", "brush"),
                ("Dimension (Q)", "dimension"),
                ("Ellipse (E)", "ellipse"),
                ("Line Point (M)", "line_point"),
                ("Line Single (L)", "line"),
                ("M.Point (O)", "MPoint"),
                ("Polygon (P)", "polygon"),  # [6920]
                ("Rectangle (R)", "rect"),
                ("Reg. Polygon (W)", "regular_polygon"),
                ("Spline (S)", "spline"),
                ("Text (X)", "text"),
                ("Trapeze (Z)", "trapeze"),
                ("Triangle (T)", "triangle"),
            ],
            key=lambda item: item[0],
        )  # [6921]

        self.tool_buttons = {}
        self.tool_group = QButtonGroup(widget)  # [6922]
        for label, tool_name in self.tools_config:  # [6923]
            tool_row_layout = QHBoxLayout()  # [6924]
            btn = QRadioButton(label)
            btn.setSizePolicy(
                QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
            )  # [6925]

            if tool_name == "line_point":  # [6926]
                btn.setToolTip(
                    "Line Point Tool (M)\nCtrl+LMB=Snap, Ctrl+LMB (on shape)=Lasso Select"
                )  # [6927]
            elif tool_name == "spline":  # [6928]
                btn.setToolTip(
                    "Spline Tool (S)\nLMB to add points, RMB/DblClk to finish, Esc to cancel."
                )  # [6929]
            elif tool_name == "arrow":  # [6930]
                btn.setToolTip("Arrow Tool (A)")  # [6931]
            elif tool_name == "MPoint":  # [6932]
                btn.setToolTip("M.Point Tool (O)")  # [6933]
            elif tool_name == "dimension":  # [6934]
                btn.setToolTip(
                    "Dimension Tool (Q)\n1. Click start point\n2. Click end point\n3. Click to set offset\nEsc/RMB=cancel, Shift+C=Clear ALL shapes"
                )  # [6935]
            else:  # [6936]
                btn.setToolTip(f"Select {label.split(' (')[0]} tool")  # [6937]

            tool_row_layout.addWidget(btn)  # [6938]
            param_widgets = {}  # [6939]
            param_layout = QHBoxLayout()
            param_layout.setSpacing(2)  # [6940]
            if tool_name == "rect":  # [6941]
                # Change 3: Rnd and Radius in a new row
                rect_params_row1 = QHBoxLayout()  # [6942]
                width_spin = QSpinBox()
                width_spin.setRange(0, 5000)
                width_spin.setValue(0)
                width_spin.setSuffix("W")
                width_spin.setToolTip("Rectangle Width (0 = Draw with mouse)")  # [6943]
                height_spin = QSpinBox()
                height_spin.setRange(0, 5000)
                height_spin.setValue(0)
                height_spin.setSuffix("H")
                height_spin.setToolTip(
                    "Rectangle Height (0 = Draw with mouse)"
                )  # [6944]
                width_spin.setFixedWidth(55)
                height_spin.setFixedWidth(55)  # [6945]
                rect_params_row1.addWidget(width_spin)
                rect_params_row1.addWidget(height_spin)  # [6946]
                rect_params_row1.addStretch()  # [6947]
                # Removed adding param_layout to tool_row_layout here

                rect_params_row2 = QHBoxLayout()  # [6948]
                rounded_check = QCheckBox("Rnd")
                rounded_check.setToolTip("Enable rounded corners (U)")  # [6949]
                radius_spin = QSpinBox()
                radius_spin.setRange(0, 1000)
                radius_spin.setValue(5)
                radius_spin.setSuffix("R")
                radius_spin.setToolTip("Corner Radius (px)")  # [6950]
                radius_spin.setFixedWidth(55)  # [6951]
                rect_params_row2.addWidget(rounded_check)
                rect_params_row2.addWidget(radius_spin)  # [6952]
                rect_params_row2.addStretch()  # [6953]

                # Create a QVBoxLayout to place both rows
                rect_vertical_layout = QVBoxLayout()  # [6954]
                rect_vertical_layout.setSpacing(1)  # Smaller spacing between rows
                rect_vertical_layout.setContentsMargins(0, 0, 0, 0)
                rect_vertical_layout.addLayout(rect_params_row1)  # Add first row
                rect_vertical_layout.addLayout(rect_params_row2)  # Add second row
                tool_row_layout.addLayout(
                    rect_vertical_layout
                )  # Add QVBoxLayout to tool_row_layout

                param_widgets = {
                    "W": width_spin,
                    "H": height_spin,
                    "Rounded": rounded_check,
                    "Radius": radius_spin,
                }  # [6955]
                width_spin.valueChanged.connect(self.overlay.update)
                height_spin.valueChanged.connect(self.overlay.update)
                rounded_check.stateChanged.connect(self.overlay.update)
                radius_spin.valueChanged.connect(self.overlay.update)
            elif tool_name == "ellipse":  # [6956]
                width_spin = QSpinBox()
                width_spin.setRange(0, 5000)
                width_spin.setValue(0)
                width_spin.setSuffix("W")
                width_spin.setToolTip("Ellipse Width (0 = Draw with mouse)")  # [6957]
                height_spin = QSpinBox()
                height_spin.setRange(0, 5000)
                height_spin.setValue(0)
                height_spin.setSuffix("H")
                height_spin.setToolTip("Ellipse Height (0 = Draw with mouse)")  # [6958]
                width_spin.setFixedWidth(55)
                height_spin.setFixedWidth(55)  # [6959]
                param_layout.addWidget(width_spin)
                param_layout.addWidget(height_spin)  # [6960]
                param_widgets = {"W": width_spin, "H": height_spin}  # [6961]
                width_spin.valueChanged.connect(self.overlay.update)
                height_spin.valueChanged.connect(self.overlay.update)
            elif tool_name == "triangle":  # [6962]
                equilateral_spin = QSpinBox()
                equilateral_spin.setRange(0, 5000)
                equilateral_spin.setValue(0)
                equilateral_spin.setSuffix("E")
                equilateral_spin.setToolTip(
                    "Equilateral Triangle Side Length (0 = Draw with mouse)"
                )  # [6963]
                right_leg1_spin = QSpinBox()
                right_leg1_spin.setRange(0, 5000)
                right_leg1_spin.setValue(0)
                right_leg1_spin.setSuffix("A")
                right_leg1_spin.setToolTip(
                    "Right Triangle Leg 1 Length (0 = Draw with mouse)"
                )  # [6964]
                right_leg2_spin = QSpinBox()
                right_leg2_spin.setRange(0, 5000)
                right_leg2_spin.setValue(0)
                right_leg2_spin.setSuffix("B")
                right_leg2_spin.setToolTip(
                    "Right Triangle Leg 2 Length (0 = Draw with mouse)"
                )  # [6965]
                # Change 3: Narrower fields in Triangle
                equilateral_spin.setFixedWidth(40)
                right_leg1_spin.setFixedWidth(40)
                right_leg2_spin.setFixedWidth(40)  # [6966]
                param_layout.addWidget(equilateral_spin)
                param_layout.addWidget(QLabel("OR"))
                param_layout.addWidget(right_leg1_spin)
                param_layout.addWidget(right_leg2_spin)  # [6967]
                param_widgets = {
                    "EqSide": equilateral_spin,
                    "LegA": right_leg1_spin,
                    "LegB": right_leg2_spin,
                }  # [6968]
                equilateral_spin.valueChanged.connect(self.overlay.update)
                right_leg1_spin.valueChanged.connect(self.overlay.update)
                right_leg2_spin.valueChanged.connect(self.overlay.update)
            elif tool_name == "arc":  # [6969]
                width_spin = QSpinBox()
                width_spin.setRange(0, 5000)
                width_spin.setValue(0)
                width_spin.setSuffix("W")
                width_spin.setToolTip(
                    "Arc Bounding Width (0 = Draw with mouse)"
                )  # [6970]
                height_spin = QSpinBox()
                height_spin.setRange(0, 5000)
                height_spin.setValue(0)
                height_spin.setSuffix("H")
                height_spin.setToolTip(
                    "Arc Bounding Height (0 = Draw with mouse)"
                )  # [6971]
                arc_span_spin = QSpinBox()
                arc_span_spin.setRange(1, 360)
                arc_span_spin.setValue(180)
                arc_span_spin.setSuffix("S")
                arc_span_spin.setToolTip("Arc Span Angle (degrees)")  # [6972]
                arc_span_spin.valueChanged.connect(self.set_arc_span_angle)  # [6973]
                width_spin.setFixedWidth(55)
                height_spin.setFixedWidth(55)
                arc_span_spin.setFixedWidth(55)  # [6974]
                param_layout.addWidget(width_spin)
                param_layout.addWidget(height_spin)
                param_layout.addWidget(arc_span_spin)  # [6975]
                param_widgets = {
                    "W": width_spin,
                    "H": height_spin,
                    "Span": arc_span_spin,
                }  # [6976]
                self.arc_span_angle_spin = arc_span_spin  # [6977]
                width_spin.valueChanged.connect(self.overlay.update)
                height_spin.valueChanged.connect(self.overlay.update)
                # arc_span_spin already connected to set_arc_span_angle which should handle updates if needed
            elif tool_name == "trapeze":  # [6978]
                base1_spin = QSpinBox()
                base1_spin.setRange(0, 5000)
                base1_spin.setValue(0)
                base1_spin.setSuffix("b1")
                base1_spin.setToolTip(
                    "Trapeze Base 1 Length (Bottom) (0 = Draw with mouse)"
                )  # [6979]
                base2_spin = QSpinBox()
                base2_spin.setRange(0, 5000)
                base2_spin.setValue(0)
                base2_spin.setSuffix("b2")
                base2_spin.setToolTip(
                    "Trapeze Base 2 Length (Top) (0 = Draw with mouse)"
                )  # [6980]
                height_spin = QSpinBox()
                height_spin.setRange(0, 5000)
                height_spin.setValue(0)
                height_spin.setSuffix("H")
                height_spin.setToolTip("Trapeze Height (0 = Draw with mouse)")  # [6981]
                base1_spin.setFixedWidth(55)
                base2_spin.setFixedWidth(55)
                height_spin.setFixedWidth(55)  # [6982]
                param_layout.addWidget(base1_spin)
                param_layout.addWidget(base2_spin)
                param_layout.addWidget(height_spin)  # [6983]
                param_widgets = {
                    "Base1": base1_spin,
                    "Base2": base2_spin,
                    "H": height_spin,
                }  # [6984]
                base1_spin.valueChanged.connect(self.overlay.update)
                base2_spin.valueChanged.connect(self.overlay.update)
                height_spin.valueChanged.connect(self.overlay.update)
            elif tool_name == "line":  # [6985]
                length_spin = QSpinBox()
                length_spin.setRange(0, 5000)
                length_spin.setValue(0)
                length_spin.setSuffix("L")
                length_spin.setToolTip("Line Length (0 = Draw with mouse)")  # [6986]
                length_spin.setFixedWidth(55)  # [6987]
                param_layout.addWidget(length_spin)  # [6988]
                param_widgets = {"L": length_spin}  # [6989]
                length_spin.valueChanged.connect(self.overlay.update)
            elif tool_name == "line_point" or tool_name == "spline":  # [6990]
                param_widgets = {}  # [6991]
                if tool_name == "line_point":  # [6992]
                    self.line_point_invert_check = QCheckBox("Invert")  # [6993]
                    self.line_point_invert_check.setToolTip(
                        "Invert Ctrl+Lasso selection (select outside) (I)"
                    )  # [6994]
                    param_layout.addWidget(self.line_point_invert_check)  # [6995]
                    param_widgets["InvertLasso"] = (
                        self.line_point_invert_check
                    )  # [6996]
                    self.line_point_invert_check.toggled.connect(
                        self.overlay.update
                    )  # Added

                self.line_point_arrow_group = QButtonGroup(widget)  # [6997]
                if tool_name == "spline":  # [6998]
                    self.line_point_no_arrow_radio_spline = QRadioButton("0AH")
                    self.line_point_no_arrow_radio_spline.setToolTip(
                        "No arrows on spline (Alt+N)"
                    )  # [6999]
                    self.line_point_1a_radio_spline = QRadioButton("1AH")
                    self.line_point_1a_radio_spline.setToolTip(
                        "Arrow at the spline end (Alt+E)"
                    )  # [7000]
                    self.line_point_2a_radio_spline = QRadioButton("2AH")
                    self.line_point_2a_radio_spline.setToolTip(
                        "Arrows at the spline ends (Alt+D)"
                    )  # [7001]
                    self.line_point_arrow_group.addButton(
                        self.line_point_no_arrow_radio_spline
                    )  # [7002]
                    self.line_point_arrow_group.addButton(
                        self.line_point_1a_radio_spline
                    )  # [7003]
                    self.line_point_arrow_group.addButton(
                        self.line_point_2a_radio_spline
                    )  # [7004]
                    self.line_point_no_arrow_radio_spline.setChecked(True)  # [7005]
                    param_layout.addWidget(
                        self.line_point_no_arrow_radio_spline
                    )  # [7006]
                    param_layout.addWidget(self.line_point_1a_radio_spline)  # [7007]
                    param_layout.addWidget(self.line_point_2a_radio_spline)  # [7008]
                    param_widgets["NoArrowRadioSpline"] = (
                        self.line_point_no_arrow_radio_spline
                    )  # [7009]
                    param_widgets["1aRadioSpline"] = (
                        self.line_point_1a_radio_spline
                    )  # [7010]
                    param_widgets["2aRadioSpline"] = (
                        self.line_point_2a_radio_spline
                    )  # [7011]
                    self.line_point_no_arrow_radio_spline.toggled.connect(
                        lambda checked: self._update_line_point_arrow_style(None)
                        if checked
                        else None
                    )  # [7012]
                    self.line_point_1a_radio_spline.toggled.connect(
                        lambda checked: self._update_line_point_arrow_style("1a")
                        if checked
                        else None
                    )  # [7013]
                    self.line_point_2a_radio_spline.toggled.connect(
                        lambda checked: self._update_line_point_arrow_style("2a")
                        if checked
                        else None
                    )  # [7014]
                    self.line_point_no_arrow_radio_spline.toggled.connect(
                        self.overlay.update
                    )  # Added
                    self.line_point_1a_radio_spline.toggled.connect(
                        self.overlay.update
                    )  # Added
                    self.line_point_2a_radio_spline.toggled.connect(
                        self.overlay.update
                    )  # Added
                else:  # [7015]
                    self.line_point_no_arrow_radio = QRadioButton("0A")
                    self.line_point_no_arrow_radio.setToolTip(
                        "No arrows on line points (Alt+N)"
                    )  # [7016]
                    self.line_point_1a_radio = QRadioButton("1A")
                    self.line_point_1a_radio.setToolTip(
                        "Arrow at the end of the last segment (Alt+E)"
                    )  # [7017]
                    self.line_point_2a_radio = QRadioButton("2A")
                    self.line_point_2a_radio.setToolTip(
                        "Arrows at the start of the first and end of the last segment (Alt+D)"
                    )  # [7018]
                    self.line_point_arrow_group.addButton(
                        self.line_point_no_arrow_radio
                    )  # [7019]
                    self.line_point_arrow_group.addButton(
                        self.line_point_1a_radio
                    )  # [7020]
                    self.line_point_arrow_group.addButton(
                        self.line_point_2a_radio
                    )  # [7021]
                    self.line_point_no_arrow_radio.setChecked(True)  # [7022]
                    param_layout.addWidget(self.line_point_no_arrow_radio)  # [7023]
                    param_layout.addWidget(self.line_point_1a_radio)  # [7024]
                    param_layout.addWidget(self.line_point_2a_radio)  # [7025]
                    param_widgets["NoArrowRadio"] = (
                        self.line_point_no_arrow_radio
                    )  # [7026]
                    param_widgets["1aRadio"] = self.line_point_1a_radio  # [7027]
                    param_widgets["2aRadio"] = self.line_point_2a_radio  # [7028]
                    self.line_point_no_arrow_radio.toggled.connect(
                        lambda checked: self._update_line_point_arrow_style(None)
                        if checked
                        else None
                    )  # [7029]
                    self.line_point_1a_radio.toggled.connect(
                        lambda checked: self._update_line_point_arrow_style("1a")
                        if checked
                        else None
                    )  # [7030]
                    self.line_point_2a_radio.toggled.connect(
                        lambda checked: self._update_line_point_arrow_style("2a")
                        if checked
                        else None
                    )  # [7031]
                    self.line_point_no_arrow_radio.toggled.connect(
                        self.overlay.update
                    )  # Added
                    self.line_point_1a_radio.toggled.connect(
                        self.overlay.update
                    )  # Added
                    self.line_point_2a_radio.toggled.connect(
                        self.overlay.update
                    )  # Added

            elif tool_name == "arrow":  # [7032]
                length_spin = QSpinBox()
                length_spin.setRange(0, 5000)
                length_spin.setValue(0)
                length_spin.setSuffix("L")
                length_spin.setToolTip(
                    "Arrow Line Length (0 = Draw with mouse)"
                )  # [7033]
                length_spin.setFixedWidth(55)  # [7034]
                param_layout.addWidget(length_spin)  # [7035]
                arrow_2x_check = QCheckBox("2x")
                arrow_2x_check.setToolTip(
                    "Draw arrow with heads at both ends (Alt+D)"
                )  # [7036]
                param_layout.addWidget(arrow_2x_check)  # [7037]
                param_widgets = {
                    "L": length_spin,
                    "DoubleHeaded": arrow_2x_check,
                }  # [7038]
                length_spin.valueChanged.connect(self.overlay.update)
                arrow_2x_check.toggled.connect(self.overlay.update)  # Added
            elif tool_name == "regular_polygon":  # [7039]
                sides_spin = QSpinBox()
                sides_spin.setRange(3, 100)
                sides_spin.setValue(5)
                sides_spin.setSuffix("N")
                sides_spin.setToolTip("Number of Sides (3-100)")  # [7040]
                radius_spin = QSpinBox()
                radius_spin.setRange(0, 5000)
                radius_spin.setValue(0)
                radius_spin.setSuffix("R")
                radius_spin.setToolTip(
                    "Polygon Radius/Size (0 = Draw with mouse)"
                )  # [7041]
                sides_spin.setFixedWidth(55)
                radius_spin.setFixedWidth(55)  # [7042]
                param_layout.addWidget(sides_spin)
                param_layout.addWidget(radius_spin)  # [7043]
                param_widgets = {"Sides": sides_spin, "Radius": radius_spin}  # [7044]
            elif tool_name == "MPoint":  # [7045]
                # Change 3: label pos and start in a new row
                mpoint_row1_layout = QHBoxLayout()
                mpoint_row1_layout.setSpacing(2)  # [7046]
                self.mpoint_style_group = QButtonGroup(widget)
                self.mpoint_style_group.setExclusive(True)  # [7047]
                self.mpoint_circle_radio = QRadioButton("O")
                self.mpoint_circle_radio.setToolTip(
                    "Draw circle points (Alt+O)"
                )  # [7048]
                self.mpoint_circle_radio.setChecked(True)  # [7049]
                self.mpoint_square_check = QCheckBox("Sq")  # [7050]
                self.mpoint_square_check.setToolTip(
                    "Draw square points (Alt+S)"
                )  # [7051]
                self.mpoint_style_group.addButton(self.mpoint_circle_radio)
                self.mpoint_style_group.addButton(self.mpoint_square_check)  # [7052]
                self.mpoint_circle_radio.toggled.connect(
                    lambda checked: self._update_mpoint_style(is_circle=checked)
                )  # [7053]
                self.mpoint_square_check.toggled.connect(
                    lambda checked: self._update_mpoint_style(is_circle=not checked)
                )  # [7054]
                mpoint_row1_layout.addWidget(self.mpoint_circle_radio)
                mpoint_row1_layout.addWidget(self.mpoint_square_check)  # [7055]
                self.mpoint_size_spin = QSpinBox()
                self.mpoint_size_spin.setRange(2, 100)
                self.mpoint_size_spin.setValue(10)
                self.mpoint_size_spin.setSuffix("Sz")
                self.mpoint_size_spin.setToolTip("Point Size")  # [7056]
                self.mpoint_size_spin.valueChanged.connect(
                    self._update_mpoint_setting
                )  # [7057]
                mpoint_row1_layout.addWidget(self.mpoint_size_spin)  # [7058]
                self.mpoint_label_check = QCheckBox("txt")
                self.mpoint_label_check.setToolTip(
                    "Enable sequential labels (T)"
                )  # [7059]
                self.mpoint_label_check.stateChanged.connect(
                    self._update_mpoint_setting
                )  # [7060]
                mpoint_row1_layout.addWidget(self.mpoint_label_check)  # [7061]
                self.mpoint_label_style_button = QPushButton("T")
                self.mpoint_label_style_button.setFixedSize(
                    self.mpoint_label_check.sizeHint().height(),
                    self.mpoint_label_check.sizeHint().height(),
                )
                self.mpoint_label_style_button.setToolTip(
                    "Configure MPoint Label Text Style"
                )  # [7062]
                self.mpoint_label_style_button.clicked.connect(
                    self.configure_mpoint_label_style
                )  # [7063]
                mpoint_row1_layout.addWidget(self.mpoint_label_style_button)  # [7064]
                mpoint_row1_layout.addStretch()  # [7065]

                mpoint_row2_layout = QHBoxLayout()
                mpoint_row2_layout.setSpacing(2)  # [7066]
                mpoint_row2_layout.addWidget(QLabel("Pos:"))  # [7067]
                self.mpoint_label_pos_combo = QComboBox()
                self.mpoint_label_pos_combo.addItems(["Up", "Down", "Left", "Right"])
                self.mpoint_label_pos_combo.setToolTip("Label Position")  # [7068]
                self.mpoint_label_pos_combo.currentTextChanged.connect(
                    self._update_mpoint_setting
                )  # [7069]
                mpoint_row2_layout.addWidget(self.mpoint_label_pos_combo)  # [7070]
                mpoint_row2_layout.addWidget(QLabel("Start:"))  # [7071]
                self.mpoint_label_start_edit = QLineEdit("1")
                self.mpoint_label_start_edit.setToolTip(
                    "Starting label (e.g., 1, A, A1)"
                )
                self.mpoint_label_start_edit.setFixedWidth(40)  # [7072]
                self.mpoint_label_start_edit.textChanged.connect(
                    self._update_mpoint_setting
                )  # [7073]
                mpoint_row2_layout.addWidget(self.mpoint_label_start_edit)  # [7074]
                mpoint_row2_layout.addStretch()  # [7075]

                mpoint_v_layout = QVBoxLayout()
                mpoint_v_layout.setSpacing(1)  # [7076]
                mpoint_v_layout.addLayout(mpoint_row1_layout)  # [7077]
                mpoint_v_layout.addLayout(mpoint_row2_layout)  # [7078]
                param_layout.addLayout(mpoint_v_layout)  # [7079]

                self.mpoint_widget_group = {  # [7080]
                    "circle_radio": self.mpoint_circle_radio,
                    "square_check": self.mpoint_square_check,  # [7081]
                    "size_spin": self.mpoint_size_spin,
                    "label_check": self.mpoint_label_check,  # [7082]
                    "label_style_button": self.mpoint_label_style_button,  # [7083]
                    "pos_combo": self.mpoint_label_pos_combo,
                    "start_edit": self.mpoint_label_start_edit,  # [7084]
                }  # [7085]
                param_widgets = {}  # [7086]
            elif tool_name == "dimension":  # [7087]
                btn.setToolTip(
                    "Dimension Tool (Q)\n1. Click start point\n2. Click end point\n3. Click to set offset\nEsc/RMB=cancel, Shift+C=Clear ALL shapes"
                )  # [7088]
                self.dimension_preview_color_button = QPushButton("")
                self.dimension_preview_color_button.setFixedSize(20, 20)
                self.dimension_preview_color_button.setToolTip(
                    "Set Dimension Preview Line Color"
                )  # [7089]
                self.dimension_preview_color_button.clicked.connect(
                    self.choose_dimension_preview_color
                )  # [7090]
                param_layout.addWidget(self.dimension_preview_color_button)  # [7091]
                self.dimension_suffix_edit = QLineEdit()  # [7092]
                self.dimension_suffix_edit.setPlaceholderText("m")  # [7093]
                self.dimension_suffix_edit.setToolTip(
                    "Suffix for dimension text (e.g., m, mm, ft)"
                )  # [7094]
                self.dimension_suffix_edit.setFixedWidth(40)  # [7095]
                param_layout.addWidget(self.dimension_suffix_edit)  # [7096]
                param_widgets["SuffixEdit"] = self.dimension_suffix_edit  # [7097]
                self.update_dimension_preview_color_button_style(
                    self.overlay.dimension_preview_line_color
                )  # [7098]
            elif tool_name == "angle_marker":  # [7099]
                btn.setToolTip(
                    "Angle Tool (>)\n1. Click point A\n2. Click vertex O\n3. Click point B\nEsc/RMB=cancel, (I=IN, O=OUT)"
                )  # [7100]
                self.angle_tool_color_button = QPushButton("")  # [7101]
                self.angle_tool_color_button.setFixedSize(20, 20)  # [7102]
                self.angle_tool_color_button.setToolTip(
                    "Set Angle Line & Default Text Color"
                )  # [7103]
                self.angle_tool_color_button.clicked.connect(
                    self.choose_angle_tool_color
                )  # [7104]
                param_layout.addWidget(self.angle_tool_color_button)  # [7105]

                self.angle_tool_text_style_button = QPushButton("T")  # [7106]
                self.angle_tool_text_style_button.setFixedSize(20, 20)  # [7107]
                self.angle_tool_text_style_button.setToolTip(
                    "Configure Angle Text Style (Font, Size, BG, etc.)"
                )  # [7108]
                self.angle_tool_text_style_button.clicked.connect(
                    self.configure_angle_text_style
                )  # [7109]
                param_layout.addWidget(self.angle_tool_text_style_button)  # [7110]

                self.angle_tool_inner_check = QCheckBox("IN")  # [7111]
                self.angle_tool_inner_check.setToolTip(
                    "Show Inner Angle (I=Toggle)"
                )  # [7112]
                self.angle_tool_inner_check.setChecked(
                    self.overlay.current_angle_tool_show_inner
                )  # [7113]
                param_layout.addWidget(self.angle_tool_inner_check)  # [7114]

                self.angle_tool_outer_check = QCheckBox("OUT")  # [7115]
                self.angle_tool_outer_check.setToolTip(
                    "Show Outer Angle (O=Toggle)"
                )  # [7116]
                self.angle_tool_outer_check.setChecked(
                    self.overlay.current_angle_tool_show_outer
                )  # [7117]
                param_layout.addWidget(self.angle_tool_outer_check)  # [7118]

                self.angle_tool_widget_group = {  # [7119]
                    "color_button": self.angle_tool_color_button,  # [7120]
                    "text_style_button": self.angle_tool_text_style_button,  # [7121]
                    "inner_check": self.angle_tool_inner_check,  # [7122]
                    "outer_check": self.angle_tool_outer_check,  # [7123]
                }  # [7124]
                self.angle_tool_inner_check.stateChanged.connect(
                    self._update_angle_tool_settings_from_ui
                )  # [7125]
                self.angle_tool_outer_check.stateChanged.connect(
                    self._update_angle_tool_settings_from_ui
                )  # [7126]
                self.update_angle_tool_color_button_style(
                    self.overlay.current_angle_tool_line_color
                )  # [7127]

            if (
                param_widgets
                and tool_name != "MPoint"
                and tool_name != "line_point"
                and tool_name != "spline"
            ):  # [7128]
                clear_button = QPushButton("C")
                clear_button.setFixedSize(20, 20)
                clear_button.setToolTip("Clear these size parameters to 0")  # [7129]
                clear_button.clicked.connect(
                    functools.partial(self.clear_fixed_size_params, tool_name)
                )  # [7130]
                param_layout.addWidget(clear_button)  # [7131]
                param_widgets["clear_button"] = clear_button  # [7132]

            if param_widgets or tool_name in [
                "line_point",
                "MPoint",
                "dimension",
                "text",
                "brush",
                "polygon",
                "angle_marker",
                "spline",
            ]:  # [7133]
                tool_row_layout.addLayout(param_layout)  # [7134]
                if param_widgets:  # [7135]
                    self.fixed_size_widgets[tool_name] = param_widgets  # [7136]
            tool_row_layout.addStretch()  # [7137]
            tool_layout_inner.addLayout(tool_row_layout)  # [7138]
            self.tool_buttons[tool_name] = btn
            self.tool_group.addButton(btn)  # [7139]
            btn.toggled.connect(
                lambda checked, t=tool_name: self.set_tool(t) if checked else None
            )  # [7140]

        layout.addWidget(tool_frame)  # [7141]

        layout.addStretch()  # [7142]
        action_column_layout = QVBoxLayout()
        action_column_layout.setSpacing(3)  # [7143]

        self.board_bg_color_preview_button = QPushButton()  # [7144]
        self.board_pen_color_preview_button = QPushButton()  # [7145]
        self.temp_color_preview_button = QPushButton()  # [7146]
        self.draw_color_preview_button = QPushButton()  # [7147]
        self.edit_pen_color_preview_button = QPushButton()  # [7148]

        self.save_button = QPushButton()  # [7149]
        self.load_button = QPushButton()  # [7150]
        self.load_join_button = QPushButton()  # [7151]
        self.load_img_button = QPushButton()  # [7152]
        self.undo_button = QPushButton()  # [7153]
        self.redo_button = QPushButton()  # [7154]
        self.anim_button = QPushButton()  # [7155]
        self.shortcuts_button = QPushButton()  # [7156]
        self.board_button = QPushButton()  # [7157]
        self.edit_button = QPushButton()  # [7158]
        self.temp_button = QPushButton()  # [7159]
        self.drawing_button = QPushButton()  # [7160]
        self.clear_button_action = QPushButton()  # [7161]

        self.board_bg_color_preview_button.clicked.connect(
            self.choose_board_background_color
        )  # [7162]
        self.board_pen_color_preview_button.clicked.connect(
            self.choose_board_pen_color
        )  # [7163]
        self.temp_color_preview_button.clicked.connect(self.choose_temp_color)  # [7164]
        self.draw_color_preview_button.clicked.connect(self.choose_draw_color)  # [7165]
        self.edit_pen_color_preview_button.clicked.connect(
            self.choose_edit_pen_color
        )  # [7166]

        self.save_button.clicked.connect(self.save_scene_action)  # [7167]
        self.load_button.clicked.connect(self.load_scene_action)  # [7168]
        self.load_join_button.clicked.connect(self.load_and_join_scene_action)  # [7169]
        self.load_img_button.clicked.connect(
            self.load_background_image_action
        )  # [7170]
        self.undo_button.clicked.connect(self.overlay.undo)  # [7171]
        self.redo_button.clicked.connect(self.overlay.redo)  # [7172]
        self.anim_button.clicked.connect(self.start_animation_setup)  # [7173]
        self.shortcuts_button.clicked.connect(
            lambda: self.toggle_shortcuts_window(force_reset=False)
        )  # [7174]
        self.board_button.clicked.connect(self.overlay.enter_board_mode)  # [7175]
        self.edit_button.clicked.connect(self.overlay.enter_edit_mode)  # [7176]
        self.temp_button.clicked.connect(self.overlay.enter_temp_mode)  # [7177]
        self.clear_button_action.clicked.connect(self.overlay.clear_scene)  # [7178]

        action_buttons_config = [  # [7179]
            [
                (
                    "Color (Board BG)",
                    "choose_board_background_color",
                    self.board_bg_color_preview_button,
                ),  # [7180]
                (
                    "Color (Board Pen)",
                    "choose_board_pen_color",
                    self.board_pen_color_preview_button,
                ),
            ],  # [7181]
            [
                (
                    "Color (Edit Pen)",
                    "choose_edit_pen_color",
                    self.edit_pen_color_preview_button,
                ),  # [7182]
                ("Color (Temp)", "choose_temp_color", self.temp_color_preview_button),
            ],  # [7183]
            [
                (
                    "Color (Draw)",
                    "choose_draw_color",
                    self.draw_color_preview_button,
                ),  # [7184]
                ("Save (Ctrl+S)", "save_scene_action", self.save_button),
            ],  # [7185]
            [
                ("Load (Ctrl+L)", "load_scene_action", self.load_button),  # [7186]
                (
                    "Load&Join (Ctrl+Shift+L)",
                    "load_and_join_scene_action",
                    self.load_join_button,
                ),
            ],  # [7187]
            [
                (
                    "LoadIMG",
                    "load_background_image_action",
                    self.load_img_button,
                ),  # [7188]
                ("ANIM", "start_animation_setup", self.anim_button),
            ],  # [7189]
            [
                ("Undo (Ctrl+Z)", "overlay.undo", self.undo_button),  # [7190]
                ("Redo (Ctrl+Y)", "overlay.redo", self.redo_button),
            ],  # [7191]
            [
                (
                    "Clear (Shift+C)",
                    "overlay.clear_scene",
                    self.clear_button_action,
                ),  # [7192]
                (
                    "KEYS (Ctrl+K)",
                    lambda: self.toggle_shortcuts_window(force_reset=False),
                    self.shortcuts_button,
                ),
            ],  # [7193]
            [
                (
                    "BOARD (Alt+\\)",
                    "overlay.enter_board_mode",
                    self.board_button,
                ),  # [7194]
                ("EDIT (RAlt+\\)", "overlay.enter_edit_mode", self.edit_button),
            ],  # [7195]
            [
                (
                    "TEMP (Alt+Shift+\\)",
                    "overlay.enter_temp_mode",
                    self.temp_button,
                ),  # [7196]
                ("DRAW (Ctrl+\\)", "handle_draw_mode_toggle", self.drawing_button),
            ],  # [7197]
        ]  # [7198]

        for row_config in action_buttons_config:  # [7199]
            h_layout = QHBoxLayout()  # [7200]
            for btn_text, method_name_or_lambda, btn_widget in row_config:  # [7201]
                btn_widget.setText(btn_text)  # [7202]
                btn_widget.setToolTip(btn_text)  # [7203]
                btn_widget.setSizePolicy(
                    QSizePolicy.Policy.MinimumExpanding, QSizePolicy.Policy.Fixed
                )  # [7204]
                h_layout.addWidget(btn_widget)  # [7205]
            action_column_layout.addLayout(h_layout)  # [7206]

        self.drawing_button.setCheckable(True)  # [7207]

        layout.addLayout(action_column_layout)  # [7208]

        self.original_button_style = self.drawing_button.styleSheet()  # [7209]
        self.active_mode_style = (
            "background-color: lightgreen; border: 1px solid darkgreen;"  # [7210]
        )

        self.drawing_button.toggled.connect(self.handle_draw_mode_toggle)  # [7211]
        self.overlay.drawing_mode_changed.connect(
            self.update_draw_mode_button_visuals
        )  # [7212]
        self.overlay.edit_mode_changed.connect(
            self.update_edit_mode_button_visuals
        )  # [7213]
        self.overlay.board_mode_changed.connect(
            self.update_board_mode_button_visuals
        )  # [7214]
        self.overlay.temp_mode_changed.connect(
            self.update_temp_mode_button_visuals
        )  # [7215]
        self.overlay.color_changed.connect(
            self.update_draw_color_preview_button
        )  # [7216]
        self.overlay.edit_pen_color_changed.connect(
            self.update_edit_pen_color_preview_button
        )  # [7217]
        self.overlay.board_pen_color_changed.connect(
            self.update_board_pen_color_preview_button
        )  # [7218]
        self.overlay.board_background_color_changed.connect(
            self.update_board_bg_color_preview_button
        )  # [7219]
        self.overlay.temp_color_changed.connect(
            self.update_temp_color_preview_button
        )  # [7220]
        self.overlay.dimension_preview_color_changed.connect(
            self.update_dimension_preview_color_button_style
        )  # [7221]
        self.overlay.angle_tool_config_changed.connect(
            self.update_angle_tool_controls_from_signal
        )  # [7222]
        self.overlay.show_center_point_changed.connect(
            self.update_center_button_visuals
        )  # [7223]
        self.overlay.divide_enabled_changed.connect(
            self.update_divide_controls_visuals_slot_bool
        )  # [7224]
        self.overlay.number_of_divisions_changed.connect(
            self.update_divide_controls_visuals_slot_int
        )  # [7225]
        self.overlay.division_point_color_changed.connect(
            self.update_division_point_color_button_style
        )  # [7226]
        self.division_point_size_spin.valueChanged.connect(
            self.overlay.set_division_point_size
        )  # [7227]

        self.hatch_forward_slash_check.stateChanged.connect(  # [7228]
            lambda state,
            style_name="forward_slash": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [7229]
        )  # [7230]
        self.hatch_backward_slash_check.stateChanged.connect(  # [7231]
            lambda state,
            style_name="backward_slash": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [7232]
        )  # [7233]
        self.hatch_horizontal_check.stateChanged.connect(  # [7234]
            lambda state, style_name="horizontal": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [7235]
        )  # [7236]
        self.hatch_vertical_check.stateChanged.connect(  # [7237]
            lambda state, style_name="vertical": self._toggle_hatch_style_and_update(
                style_name, state == Qt.CheckState.Checked.value
            )  # [7238]
        )  # [7239]
        self.hatch_thickness_spin.valueChanged.connect(
            self._update_hatch_settings_from_ui
        )  # [7240]

        self.alpha_spin.valueChanged.connect(self.overlay.set_alpha)  # [7241]
        self.thickness_spin.valueChanged.connect(
            self.overlay.set_line_thickness
        )  # [7242]
        self.style_combo.activated.connect(self.on_style_combo_activated)  # [7243]
        self.arrow_size_spin.valueChanged.connect(
            self.overlay.set_arrow_head_size
        )  # [7244]
        self.brush_size_spin.valueChanged.connect(self.set_brush_size)  # [7245]
        self.time_spin.valueChanged.connect(
            self.overlay.set_temp_mode_duration
        )  # [7246]
        self.fill_check.stateChanged.connect(self.update_fill_state_and_hatch)  # [7247]
        self.dim_check.stateChanged.connect(
            lambda state: self.overlay.set_dim_background(
                state == Qt.CheckState.Checked.value
            )
        )  # [7248]
        self.tool_text_check.stateChanged.connect(
            lambda state: self.overlay.set_show_tool_text(
                state == Qt.CheckState.Checked.value
            )
        )  # [7249]
        self.overlay.defaults_changed.connect(
            self.update_controls_from_defaults
        )  # [7250]
        self.overlay.shapes_visibility_changed.connect(
            self.update_hide_button_visuals
        )  # [7251]
        self.overlay.line_point_arrow_style_changed.connect(
            self.update_line_point_arrow_style_controls
        )  # [7252]

        self._animation_running = False  # [7253]
        self._animation_paused = False  # [7254]
        self._animation_params = {}  # [7255]
        self._animation_scenes = []  # [7256]
        self._animation_current_index = -1  # [7257]
        self._animation_direction = 1  # [7258]
        self._pingpong_returning = False  # [7259]
        self._animation_timer_step = QTimer(self)
        self._animation_timer_step.setSingleShot(True)
        self._animation_timer_step.timeout.connect(self._animation_step)  # [7260]
        self._animation_timer_clear = QTimer(self)
        self._animation_timer_clear.setSingleShot(True)
        self._animation_timer_clear.timeout.connect(
            self._animation_clear_and_schedule_next
        )  # [7261]
        self._animation_was_indicator_shown = True  # [7262]
        self._animation_pause_remaining_clear = -1  # [7263]
        self._animation_pause_remaining_step = -1  # [7264]
        self._animation_individual_scene_timers = []  # [7265]

        self.overlay.control_panel = self  # [7266]
        self.restore_settings()  # [7267]
        # Ensure snap controls state is initialized after settings restore # [7268]
        self.update_snap_controls_from_settings()  # [7269]
        print("ControlPanel initialized and settings restored.")  # [7270]
        self._initial_position_set = True  # [7271]

    @Slot()  # [7272]
    def choose_hatch_fill_color(self):  # [7273]
        """Opens a color dialog to choose the hatch fill color."""  # [7274]
        initial_color = self.overlay.current_hatch_color  # [7275]
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Hatch Fill Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )  # [7276]
        if color.isValid():  # [7277]
            self.overlay.current_hatch_color = color  # [7278]
            self.update_hatch_fill_color_button_style(color)  # [7279]
            self.overlay.save_hatch_fill_settings()  # [7280]
            if self.overlay.selected_shapes:  # [7281]
                changed_shapes = []  # [7282]
                prev_props = {}  # [7283]
                current_indices = []  # [7284]
                for shape in self.overlay.selected_shapes:  # [7285]
                    if shape.hatch_properties:  # [7286]
                        try:  # [7287]
                            idx = self.overlay.shapes.index(shape)  # [7288]
                            prev_props[idx] = deepcopy(shape)  # [7289]
                            shape.hatch_properties["color"] = QColor(color)  # [7290]
                            changed_shapes.append(shape)  # [7291]
                            current_indices.append(idx)  # [7292]
                        except ValueError:  # [7293]
                            continue  # [7294]
                if changed_shapes:  # [7295]
                    self.overlay.save_state(
                        "change_hatch_fill_config",
                        shapes_involved=changed_shapes,
                        previous_geometries=prev_props,
                        indices=current_indices,
                    )  # [7296]
                    self.overlay.update()  # [7297]

            elif self.overlay.drawing_mode:  # [7298]
                self.overlay.update()  # [7299]
        else:  # [7300]
            print("Hatch fill color selection cancelled.")  # [7301]

    @Slot()  # [7302]
    def choose_division_point_color(self):  # [7303]
        """Opens a color dialog to choose the division point color."""  # [7304]
        initial_color = self.overlay.division_point_color  # [7305]
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Division Point Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )  # [7306]
        if color.isValid():  # [7307]
            self.overlay.set_division_point_color(color)  # [7308]
        else:  # [7309]
            print("Division point color selection cancelled.")  # [7310]

    def _handle_lines_toggle_checkbox(self, state):  # [7311]
        """Handles the checkbox state change for Lines."""  # [7312]
        global lines_app_instance  # [7313]
        if lines_app_instance:  # [7314]
            is_checked = state == Qt.CheckState.Checked.value  # [7315]
            if is_checked != lines_app_instance.linijki_widoczne:  # [7316]
                lines_app_instance.toggle_lines_visibility()  # [7317]
        elif (
            lines_app_instance
            and (state == Qt.CheckState.Checked.value)
            != lines_app_instance.linijki_widoczne
        ):  # [7318]
            self.lines_toggle_checkbox.setChecked(
                lines_app_instance.linijki_widoczne
            )  # [7319]

    def _handle_lines_settings_button(self):  # [7320]
        """Handles the settings button click for Lines."""  # [7321]
        global lines_app_instance, lines_settings_dialog_instance  # [7322]
        if lines_app_instance:  # [7323]
            if (
                lines_settings_dialog_instance is None
                or not lines_settings_dialog_instance.isVisible()
            ):  # [7324]
                lines_app_instance.pokaz_dialog_ustawien_lines()  # [7325]
            else:  # [7326]
                lines_settings_dialog_instance.activateWindow()  # [7327]
                lines_settings_dialog_instance.raise_()  # [7328]

    def _handle_grid_toggle_checkbox(self, state):  # [7329]
        """Handles the checkbox state change for Grid."""  # [7330]
        global grid_settings_window_instance, grid_overlay_instance  # [7331]
        if grid_settings_window_instance and grid_overlay_instance:  # [7332]
            grid_settings_window_instance.toggleGrid(state)  # [7333]

    def _handle_grid_settings_button(self):  # [7334]
        """Handles the settings button click for Grid."""  # [7335]
        global grid_settings_window_instance  # [7336]
        if grid_settings_window_instance:  # [7337]
            if not grid_settings_window_instance.isVisible():  # [7338]
                grid_settings_window_instance.show()  # [7339]
            grid_settings_window_instance.raise_()  # [7340]
            grid_settings_window_instance.activateWindow()  # [7341]

    @Slot(bool)  # [7342]
    def update_lines_toggle_checkbox_state(self, visible):  # [7343]
        """Updates the Lines checkbox state based on a signal."""  # [7344]
        self.lines_toggle_checkbox.blockSignals(True)  # [7345]
        self.lines_toggle_checkbox.setChecked(visible)  # [7346]
        self.lines_toggle_checkbox.blockSignals(False)  # [7347]

    @Slot(bool)  # [7348]
    def update_grid_toggle_checkbox_state(self, visible):  # [7349]
        """Updates the Grid checkbox state based on a signal."""  # [7350]
        self.grid_toggle_checkbox.blockSignals(True)  # [7351]
        self.grid_toggle_checkbox.setChecked(visible)  # [7352]
        self.grid_toggle_checkbox.blockSignals(False)  # [7353]

    def _toggle_hatch_style_and_update(self, style_name, is_checked):  # [7354]
        current_styles = set(self.overlay.current_hatch_style)  # [7355]
        if is_checked:  # [7356]
            current_styles.add(style_name)  # [7357]
        else:  # [7358]
            current_styles.discard(style_name)  # [7359]
        self.overlay.current_hatch_style = list(current_styles)  # [7360]
        self._update_hatch_settings_from_ui()  # [7361]

    @Slot(bool)  # [7362]
    def toggle_zoom_button_handler(self, checked):  # [7363]
        self.toggle_zoom(checked)  # [7364]

    def toggle_zoom(self, enable):  # [7365]
        """Enables or disables Windows Magnifier."""  # [7366]
        if not _IS_WINDOWS:  # [7367]
            print("Magnifier control is only available on Windows.")  # [7368]
            if self.zoom_button.isChecked() != self.zoom_enabled:  # [7369]
                self.zoom_button.setChecked(self.zoom_enabled)  # [7370]
            return  # [7371]

        if enable:  # [7372]
            if not self.zoom_enabled:  # [7373]
                try:  # [7374]
                    if not self._zoom_first_use_info_shown:  # [7375]
                        QMessageBox.information(
                            self,
                            "Magnifier Information",  # [7376]
                            "Windows Magnifier will be launched directly.\n"  # [7377]
                            "Please set your desired zoom level and mode directly in the Magnifier application "  # [7378]
                            "the first time you use it.\nThis message will not be shown again.",
                        )  # [7379]
                        self._zoom_first_use_info_shown = True  # [7380]
                        self.settings.setValue(
                            "magnifier/firstUseInfoShown", True
                        )  # [7381]

                    subprocess.Popen(
                        ["cmd.exe", "/c", "start", "", "Magnify.exe"], shell=True
                    )  # [7382]
                    self.zoom_enabled = True  # [7383]
                    print("Launched Windows Magnifier (Magnify.exe)")  # [7384]
                except Exception as e:  # [7385]
                    print(f"Error launching Magnifier: {e}")  # [7386]
                    QMessageBox.warning(
                        self, "Magnifier Error", f"Could not launch Magnifier: {e}"
                    )  # [7387]
                    self.zoom_enabled = False  # [7388]
            if self.zoom_button.isChecked() != self.zoom_enabled:  # [7389]
                self.zoom_button.setChecked(self.zoom_enabled)  # [7390]
        else:  # [7391]
            if self.zoom_enabled:  # [7392]
                if not _PYAUTOGUI_AVAILABLE:  # [7393]
                    QMessageBox.warning(
                        self,
                        "Magnifier Control Disabled",  # [7394]
                        "PyAutoGUI module is not installed.\n"  # [7395]
                        "Magnifier closing via hotkey is disabled.\n"  # [7396]
                        "Please install PyAutoGUI: pip install pyautogui",
                    )  # [7397]
                    if self.zoom_button.isChecked() != self.zoom_enabled:  # [7398]
                        self.zoom_button.setChecked(self.zoom_enabled)  # [7399]
                    return  # [7400]

                print(
                    "Attempting to close Magnifier via hotkey (Win + Esc)..."
                )  # [7401]
                try:  # [7402]
                    pyautogui.hotkey("win", "esc")  # [7403]
                    self.zoom_enabled = False  # [7404]
                    print("Sent Win + Esc to close Magnifier.")  # [7405]
                except Exception as e:  # [7406]
                    print(f"Error sending Win + Esc to close Magnifier: {e}")  # [7407]
                    QMessageBox.warning(
                        self,
                        "Magnifier Error",
                        f"Could not send hotkey to close Magnifier: {e}",
                    )  # [7408]
            if self.zoom_button.isChecked() != self.zoom_enabled:  # [7409]
                self.zoom_button.setChecked(self.zoom_enabled)  # [7410]

    @Slot(bool)  # [7411]
    def toggle_dark_mode(self, checked):  # [7412]
        app = QApplication.instance()  # [7413]
        if _QDARKSTYLE_AVAILABLE:  # [7414]
            if checked:  # [7415]
                app.setStyleSheet(
                    qdarkstyle.load_stylesheet(qt_api="pyside6")
                )  # [7416]
                self.dark_mode_button.setText("LIGHT")  # [7417] # NEW LINE
                print("Switched to Dark Theme.")  # [7418]
            else:  # [7419]
                app.setStyleSheet("")  # [7420]
                self.dark_mode_button.setText("DARK")  # [7421] # NEW LINE
                print("Switched to Light Theme.")  # [7422]
            self.settings.setValue("controlPanel/darkModeEnabled", checked)  # [7423]
        else:  # [7424]
            print("WARNING: qdarkstyle not available, cannot toggle theme.")  # [7425]
            self.dark_mode_button.blockSignals(True)  # [7426]
            self.dark_mode_button.setChecked(False)  # [7427]
            self.dark_mode_button.blockSignals(False)  # [7428]
            self.dark_mode_button.setText(
                "DARK"
            )  # [7429] # NEW LINE (Ensure text is correct when dark mode is unavailable)
            self.settings.setValue("controlPanel/darkModeEnabled", False)  # [7430]

    @Slot(str, bool)  # [7431]
    def toggle_preview_animation_scene(self, filepath, show):  # [7432]
        """Shows or hides the preview of a specific animation scene."""  # [7433]
        preview_tag_base = f"preview_anim_{os.path.basename(filepath)}"  # [7434]

        if show:  # [7435]
            if filepath not in self._anim_dialog_previewed_scene_tags:  # [7436]
                unique_preview_tag = (
                    f"{preview_tag_base}_{uuid.uuid4().hex[:4]}"  # [7437]
                )
                self._anim_dialog_previewed_scene_tags[filepath] = (
                    unique_preview_tag  # [7438]
                )
                print(
                    f"Showing preview for: {os.path.basename(filepath)} (tag: {unique_preview_tag})"
                )  # [7439]

                if not self.overlay.drawing_mode:
                    self.overlay.enter_edit_mode()  # [7440]
                elif not (
                    self.overlay.edit_mode
                    or self.overlay.board_mode
                    or self.overlay.temp_mode
                ):  # [7441]
                    self.overlay.enter_edit_mode()  # [7442]
                self.settings.setValue(
                    "drawingModeBeforeAnimDialogPreview", self.overlay.drawing_mode
                )  # [7443]

                self.overlay.load_scene(
                    filepath, join=True, animation_tag=unique_preview_tag
                )  # [7444]
                self.overlay.update()  # [7445]
        else:  # [7446]
            if filepath in self._anim_dialog_previewed_scene_tags:  # [7447]
                tag_to_remove = self._anim_dialog_previewed_scene_tags.pop(
                    filepath
                )  # [7448]
                print(
                    f"Hiding preview for: {os.path.basename(filepath)} (tag: {tag_to_remove})"
                )  # [7449]
                self.overlay.remove_shapes_by_animation_tag(tag_to_remove)  # [7450]
                self.overlay.update()  # [7451]

            if (
                not self._anim_dialog_previewed_scene_tags and self.overlay.edit_mode
            ):  # [7452]
                if not self.settings.value(
                    "drawingModeBeforeAnimDialogPreview", False, type=bool
                ):  # [7453]
                    self.overlay.set_drawing_mode(False)  # [7454]

    def clear_all_previewed_animation_scenes(self):  # [7455]
        """Clears all currently previewed animation scenes."""  # [7456]
        if self._anim_dialog_previewed_scene_tags:  # [7457]
            print("Clearing all previewed animation scenes.")  # [7458]
            for filepath, tag_to_remove in list(
                self._anim_dialog_previewed_scene_tags.items()
            ):  # [7459]
                print(
                    f"  Removing preview for: {os.path.basename(filepath)} (tag: {tag_to_remove})"
                )  # [7460]
                self.overlay.remove_shapes_by_animation_tag(tag_to_remove)  # [7461]
            self._anim_dialog_previewed_scene_tags.clear()  # [7462]
            self.overlay.update()  # [7463]
            if (
                self.overlay.edit_mode
                and not self.overlay.board_mode
                and not self.overlay.temp_mode
            ):  # [7464]
                if not self.settings.value(
                    "drawingModeBeforeAnimDialogPreview", False, type=bool
                ):  # [7465]
                    self.overlay.set_drawing_mode(False)  # [7466]

    def mousePressEvent(self, event: QMouseEvent):  # [7467]
        """Handles mouse press for potential window dragging."""  # [7468]
        if event.button() == Qt.MouseButton.LeftButton:  # [7469]
            title_bar_height = (
                self.style().pixelMetric(QStyle.PixelMetric.PM_TitleBarHeight)
                if self.style()
                else 20
            )  # [7470]
            grab_area_height = title_bar_height + 5  # [7471]
            is_on_title_bar_area = event.position().y() <= grab_area_height  # [7472]

            if is_on_title_bar_area:  # [7473]
                child = self.childAt(event.position().toPoint())
                is_interactive = False  # [7474]
                if child:  # [7475]
                    current_widget = child  # [7476]
                    while current_widget and current_widget != self.widget():  # [7477]
                        interactive_types = [  # [7478]
                            "QPushButton",
                            "QRadioButton",
                            "QCheckBox",
                            "QSpinBox",
                            "QDoubleSpinBox",  # [7479]
                            "QComboBox",
                            "QLineEdit",
                            "QTextEdit",
                            "QSlider",  # [7480]
                            "QAbstractSpinBox",
                            "QToolButton",
                            "QAbstractSlider",  # [7481]
                            "QDial",
                            "QScrollBar",  # [7482]
                        ]  # [7483]
                        if any(
                            current_widget.inherits(t) for t in interactive_types
                        ):  # [7484]
                            is_interactive = True
                            break  # [7485]
                        current_widget = current_widget.parentWidget()  # [7486]
                if not is_interactive:  # [7487]
                    self._dragging_window = True  # [7488]
                    self._drag_window_offset = (
                        event.globalPosition().toPoint() - self.geometry().topLeft()
                    )  # [7489]
                    self.setCursor(Qt.CursorShape.SizeAllCursor)  # [7490]
                    event.accept()  # [7491]
                    return  # [7492]
            else:  # [7493]
                child = self.childAt(event.position().toPoint())
                is_interactive = False  # [7494]
                if child:  # [7495]
                    current_widget = child  # [7496]
                    while current_widget and current_widget != self.widget():  # [7497]
                        interactive_types = [  # [7498]
                            "QPushButton",
                            "QRadioButton",
                            "QCheckBox",
                            "QSpinBox",
                            "QDoubleSpinBox",  # [7499]
                            "QComboBox",
                            "QLineEdit",
                            "QTextEdit",
                            "QSlider",  # [7500]
                            "QAbstractSpinBox",
                            "QToolButton",
                            "QAbstractSlider",  # [7501]
                            "QDial",
                            "QScrollBar",  # [7502]
                        ]  # [7503]
                        if any(
                            current_widget.inherits(t) for t in interactive_types
                        ):  # [7504]
                            is_interactive = True
                            break  # [7505]
                        current_widget = current_widget.parentWidget()  # [7506]
                if not is_interactive:  # [7507]
                    self._dragging_window = True  # [7508]
                    self._drag_window_offset = (
                        event.globalPosition().toPoint() - self.geometry().topLeft()
                    )  # [7509]
                    self.setCursor(Qt.CursorShape.SizeAllCursor)  # [7510]
                    event.accept()  # [7511]
                    return  # [7512]
        super().mousePressEvent(event)  # [7513]

    def mouseMoveEvent(self, event: QMouseEvent):  # [7514]
        """Handles mouse move for window dragging."""  # [7515]
        if (
            self._dragging_window and event.buttons() & Qt.MouseButton.LeftButton
        ):  # [7516]
            self.move(
                event.globalPosition().toPoint() - self._drag_window_offset
            )  # [7517]
            event.accept()  # [7518]
            return  # [7519]
        super().mouseMoveEvent(event)  # [7520]

    def mouseReleaseEvent(self, event: QMouseEvent):  # [7521]
        """Handles mouse release to stop window dragging."""  # [7522]
        if (
            event.button() == Qt.MouseButton.LeftButton and self._dragging_window
        ):  # [7523]
            self._dragging_window = False  # [7524]
            self.unsetCursor()  # [7525]
            event.accept()  # [7526]
            return  # [7527]
        super().mouseReleaseEvent(event)  # [7528]

    @Slot()  # [7529]
    def show_info_dialog(self):  # [7530]
        if self.info_dialog is None:  # [7531]
            self.info_dialog = AuthorInfoDialog(self)  # [7532]
        self.info_dialog.exec()  # [7533]

    def _create_line_style_combo(self, parent_layout):  # [7534]
        style_layout = QHBoxLayout()  # [7535]
        style_layout.addWidget(QLabel("Style:"))  # [7536]
        self.style_combo = QComboBox()
        self.style_combo.setToolTip(
            "Drawing Line Style\nShortcut: Ctrl+Shift + PageUp/Down"
        )  # [7537]
        custom_pattern_1 = [1, 4]
        custom_pattern_2 = [4, 4]
        custom_pattern_3 = [8, 4, 2, 4]
        custom_pattern_4 = [1, 2, 1, 4]
        custom_pattern_5 = [6, 2]  # [7538]
        self.line_styles_list = [  # [7539]
            ("Solid", Qt.PenStyle.SolidLine, None),
            ("Dash", Qt.PenStyle.DashLine, None),
            ("Dot", Qt.PenStyle.DotLine, None),  # [7540]
            ("Dash Dot", Qt.PenStyle.DashDotLine, None),
            ("Dash Dot Dot", Qt.PenStyle.DashDotDotLine, None),  # [7541]
            ("Loose Dot", Qt.PenStyle.CustomDashLine, custom_pattern_1),
            ("Loose Dash", Qt.PenStyle.CustomDashLine, custom_pattern_2),  # [7542]
            ("Dash-Dot Var", Qt.PenStyle.CustomDashLine, custom_pattern_3),
            ("Dot-Dot-Gap", Qt.PenStyle.CustomDashLine, custom_pattern_4),  # [7543]
            ("Tight Dash", Qt.PenStyle.CustomDashLine, custom_pattern_5),  # [7544]
        ]  # [7545]
        for name, style_enum, pattern in self.line_styles_list:  # [7546]
            self.style_combo.addItem(name, (style_enum, pattern))  # [7547]
        style_layout.addWidget(self.style_combo)
        parent_layout.addLayout(style_layout)  # [7548] # Change 3: Add to passed layout

    @Slot(str)  # [7549]
    def clear_fixed_size_params(self, tool_name):  # [7550]
        if tool_name in self.fixed_size_widgets:  # [7551]
            widgets = self.fixed_size_widgets[tool_name]  # [7552]
            print(f"Clearing fixed size parameters for tool: {tool_name}")  # [7553]
            for name, widget in widgets.items():  # [7554]
                if isinstance(widget, (QSpinBox, QDoubleSpinBox)):  # [7555]
                    widget.blockSignals(True)
                    widget.setValue(0)
                    widget.blockSignals(False)  # [7556]
            if (
                tool_name == "rect"
                and "Rounded" in widgets
                and isinstance(widgets["Rounded"], QCheckBox)
            ):  # [7557]
                widgets["Rounded"].blockSignals(True)
                widgets["Rounded"].setChecked(False)
                widgets["Rounded"].blockSignals(False)  # [7558]
            if (
                tool_name == "arrow"
                and "DoubleHeaded" in widgets
                and isinstance(widgets["DoubleHeaded"], QCheckBox)
            ):  # [7559]
                widgets["DoubleHeaded"].blockSignals(True)
                widgets["DoubleHeaded"].setChecked(False)
                widgets["DoubleHeaded"].blockSignals(False)  # [7560]
        else:  # [7561]
            print(
                f"Warning: No fixed size widgets found for tool {tool_name} to clear."
            )  # [7562]

    @Slot(int)  # [7563]
    def set_arc_span_angle(self, angle):  # [7564]
        if hasattr(self.overlay, "set_arc_span_angle"):  # [7565]
            self.overlay.set_arc_span_angle(angle)  # [7566]

    def restore_settings(self):  # [7567]
        self.overlay.blockSignals(True)
        self.alpha_spin.blockSignals(True)
        self.thickness_spin.blockSignals(False)  # [7568]
        self.style_combo.blockSignals(True)
        self.arrow_size_spin.blockSignals(True)
        self.brush_size_spin.blockSignals(True)  # [7569]
        self.time_spin.blockSignals(True)
        self.fill_check.blockSignals(True)
        self.dim_check.blockSignals(True)  # [7570]
        self.tool_text_check.blockSignals(True)
        self.clear_warning_check.blockSignals(True)  # [7571]
        self.center_check.blockSignals(True)  # [7572]
        self.divide_check.blockSignals(True)  # [7573]
        self.divisions_spin.blockSignals(True)  # [7574]
        self.division_settings_group["color_button"].blockSignals(True)  # [7575]
        self.division_settings_group["size_spin"].blockSignals(True)  # [7576]
        self.dark_mode_button.blockSignals(True)  # [7577]
        for widget in self.angle_tool_widget_group.values():
            widget.blockSignals(True)  # [7578]
        for widget in self.hatch_widget_group.values():
            widget.blockSignals(True)  # [7579]

        if hasattr(self, "line_point_arrow_group"):  # [7580]
            if hasattr(self, "line_point_no_arrow_radio"):  # [7581]
                self.line_point_no_arrow_radio.blockSignals(True)  # [7582]
                self.line_point_1a_radio.blockSignals(True)  # [7583]
                self.line_point_2a_radio.blockSignals(True)  # [7584]
            if hasattr(self, "line_point_no_arrow_radio_spline"):  # [7585]
                self.line_point_no_arrow_radio_spline.blockSignals(True)  # [7586]
                self.line_point_1a_radio_spline.blockSignals(True)  # [7587]
                self.line_point_2a_radio_spline.blockSignals(True)  # [7588]

        for tool, widgets in self.fixed_size_widgets.items():  # [7589]
            for name, widget in widgets.items():  # [7590]
                if name == "clear_button":
                    continue  # [7591]
                if isinstance(widget, (QSpinBox, QCheckBox, QDoubleSpinBox)):
                    widget.blockSignals(True)  # [7592]
        if hasattr(self, "mpoint_widget_group"):  # [7593]
            for widget in self.mpoint_widget_group.values():
                widget.blockSignals(True)  # [7594]

        # New position and size restoration logic
        restored_manually = False
        if (
            self.settings.contains("controlPanel/pos_x")
            and self.settings.contains("controlPanel/pos_y")
            and self.settings.contains("controlPanel/size_w")
            and self.settings.contains("controlPanel/size_h")
        ):
            pos_x = self.settings.value("controlPanel/pos_x", type=int)
            pos_y = self.settings.value("controlPanel/pos_y", type=int)
            size_w = self.settings.value("controlPanel/size_w", type=int)
            size_h = self.settings.value("controlPanel/size_h", type=int)

            print(
                f"ControlPanel restore_settings: Loaded manual pos=({pos_x},{pos_y}), size=({size_w},{size_h})"
            )

            if size_w > 0 and size_h > 0:
                screen_available_geom = (
                    QGuiApplication.primaryScreen().availableGeometry()
                )

                # Check if restored size is sensible and fits on screen
                valid_width = min(
                    size_w, screen_available_geom.width() - 20
                )  # -20 margin
                valid_height = min(
                    size_h, screen_available_geom.height() - 40
                )  # -40 margin (title bar)

                # Respect minimum sizes if they are larger
                valid_width = max(self.minimumWidth(), valid_width)
                valid_height = max(self.minimumHeight(), valid_height)

                restored_size = QSize(valid_width, valid_height)
                self.resize(restored_size)

                # Check if restored position is on screen
                restored_pos = QPoint(pos_x, pos_y)
                candidate_rect = QRect(restored_pos, restored_size)

                final_x = restored_pos.x()
                final_y = restored_pos.y()

                # Simple check if top-left is off-screen or too close to edge
                if (
                    final_x < screen_available_geom.left() - restored_size.width() + 50
                    or final_x > screen_available_geom.right() - 50
                ):  # If most of window is off
                    final_x = (
                        screen_available_geom.right() - restored_size.width() - 10
                    )  # Default to top-right

                if (
                    final_y < screen_available_geom.top() - restored_size.height() + 50
                    or final_y > screen_available_geom.bottom() - 50
                ):
                    final_y = screen_available_geom.top() + 10  # Default to top

                # Additional safeguard to not go completely off
                final_x = max(
                    screen_available_geom.left(),
                    min(final_x, screen_available_geom.right() - restored_size.width()),
                )
                final_y = max(
                    screen_available_geom.top(),
                    min(
                        final_y, screen_available_geom.bottom() - restored_size.height()
                    ),
                )

                self.move(QPoint(final_x, final_y))
                print(
                    f"ControlPanel restore_settings: Restored manually to pos={self.pos()}, size={self.size()}"
                )
                restored_manually = True
            else:
                print("ControlPanel restore_settings: Invalid size from settings.")

        if not restored_manually:
            print(
                "ControlPanel restore_settings: No valid manual pos/size found or restore failed. Adjusting position."
            )
            self.adjust_position()

        default_draw_color = QColor(255, 0, 0)
        saved_draw_color_str = self.settings.value(
            "controlPanel/drawPenColor",
            default_draw_color.name(QColor.NameFormat.HexArgb),
        )  # [7595]
        saved_draw_color = QColor(saved_draw_color_str)
        self.overlay.set_pen_color(
            saved_draw_color if saved_draw_color.isValid() else default_draw_color
        )  # [7596]
        default_temp_color = QColor(0, 0, 255)
        saved_temp_color_str = self.settings.value(
            "controlPanel/tempPenColor",
            default_temp_color.name(QColor.NameFormat.HexArgb),
        )  # [7597]
        saved_temp_color = QColor(saved_temp_color_str)
        self.overlay.set_temp_pen_color(
            saved_temp_color if saved_temp_color.isValid() else default_temp_color
        )  # [7598]
        saved_time_duration = self.settings.value(
            "controlPanel/tempDuration", 3.0, type=float
        )  # [7599]
        self.time_spin.setValue(saved_time_duration)
        self.overlay.set_temp_mode_duration(saved_time_duration)  # [7600]
        saved_tool = self.settings.value("controlPanel/currentTool", "rect")
        self.set_tool(
            saved_tool if saved_tool in self.tool_buttons else "rect"
        )  # [7601]
        saved_alpha_255 = self.settings.value("controlPanel/alpha", 255, type=int)
        saved_alpha_percent = round(saved_alpha_255 / 2.55)  # [7602]
        self.alpha_spin.setValue(saved_alpha_percent)
        self.overlay.set_alpha(saved_alpha_percent)  # [7603]
        saved_thickness = self.settings.value("controlPanel/thickness", 2, type=int)
        self.thickness_spin.setValue(saved_thickness)
        self.overlay.set_line_thickness(saved_thickness)  # [7604]
        saved_style_value = self.settings.value(
            "controlPanel/lineStyleValue", Qt.PenStyle.SolidLine.value, type=int
        )  # [7605]
        saved_pattern_json = self.settings.value("controlPanel/linePattern", None)
        saved_pattern = None  # [7606]
        if saved_pattern_json:  # [7607]
            try:
                saved_pattern = json.loads(saved_pattern_json)  # [7608]
            except json.JSONDecodeError:
                saved_pattern = None  # [7609]
        if not isinstance(saved_pattern, list):
            saved_pattern = None  # [7610]
        restored_index = next(
            (
                i
                for i, data in enumerate(self.line_styles_list)
                if data[1].value == saved_style_value
                and (data[1] != Qt.PenStyle.CustomDashLine or data[2] == saved_pattern)
            ),
            0,
        )  # [7611]
        self.style_combo.setCurrentIndex(restored_index)
        self.overlay.set_line_style(saved_style_value, saved_pattern)  # [7612]
        saved_arrow_size = self.settings.value("controlPanel/arrowSize", 10, type=int)
        self.arrow_size_spin.setValue(saved_arrow_size)
        self.overlay.set_arrow_head_size(saved_arrow_size)  # [7613]
        saved_brush_size = self.settings.value("controlPanel/brushSize", 5, type=int)
        self.brush_size_spin.setValue(saved_brush_size)
        self.overlay.brush_size = saved_brush_size  # [7614]
        saved_fill_state = self.settings.value(
            "controlPanel/fillChecked", True, type=bool
        )
        self.fill_check.setChecked(saved_fill_state)  # [7615]
        saved_dimm_state = self.settings.value(
            "controlPanel/dimmChecked", True, type=bool
        )
        self.dim_check.setChecked(saved_dimm_state)
        self.overlay.set_dim_background(saved_dimm_state)  # [7616]
        saved_tool_text_state = self.settings.value(
            "controlPanel/showToolText", True, type=bool
        )
        self.tool_text_check.setChecked(saved_tool_text_state)
        self.overlay.set_show_tool_text(saved_tool_text_state)  # [7617]
        saved_clear_warning_state = self.settings.value(
            "controlPanel/clearWarningChecked", True, type=bool
        )
        self.clear_warning_check.setChecked(saved_clear_warning_state)  # [7618]
        saved_center_state = self.settings.value(
            "controlPanel/showCenterPoint", False, type=bool
        )  # [7619]
        self.center_check.setChecked(saved_center_state)  # [7620]
        self.overlay.set_show_center_point(saved_center_state)  # [7621]
        saved_divide_enabled = self.settings.value(
            "controlPanel/divideEnabled", False, type=bool
        )  # [7622]
        saved_num_divisions = self.settings.value(
            "controlPanel/numberOfDivisions", 2, type=int
        )  # [7623]
        self.divide_check.setChecked(saved_divide_enabled)  # [7624]
        self.divisions_spin.setValue(saved_num_divisions)  # [7625]
        self.overlay.set_divide_enabled(saved_divide_enabled)  # [7626]
        self.overlay.set_number_of_divisions(saved_num_divisions)  # [7627]
        self.overlay.load_division_point_settings()  # [7628]
        self.update_division_point_color_button_style(
            self.overlay.division_point_color
        )  # [7629]
        self.division_settings_group["size_spin"].setValue(
            self.overlay.division_point_size
        )  # [7630]

        saved_lp_arrow_style = self.settings.value(
            "controlPanel/linePointArrowStyle", None
        )  # [7631]
        self.overlay.current_line_point_arrow_style = saved_lp_arrow_style  # [7632]
        self.update_line_point_arrow_style_controls(saved_lp_arrow_style)  # [7633]

        for tool, widgets in self.fixed_size_widgets.items():  # [7634]
            for name, widget in widgets.items():  # [7635]
                if name == "clear_button":
                    continue  # [7636]
                setting_key = f"controlPanel/fixedSize/{tool}_{name}"  # [7637]
                if (
                    tool == "dimension"
                    and name == "SuffixEdit"
                    and isinstance(widget, QLineEdit)
                ):  # [7638]
                    saved_val = self.settings.value(setting_key, "", type=str)
                    widget.setText(saved_val)  # [7639]
                elif isinstance(widget, QSpinBox):  # [7640]
                    default_val = 0 if name not in ["Radius", "Sides"] else 5  # [7641]
                    saved_val = self.settings.value(setting_key, default_val, type=int)
                    widget.setValue(saved_val)  # [7642]
                    if tool == "arc" and name == "Span":
                        self.set_arc_span_angle(saved_val)  # [7643]
                elif isinstance(widget, QDoubleSpinBox):
                    widget.setValue(
                        self.settings.value(setting_key, 0.0, type=float)
                    )  # [7644]
                elif isinstance(widget, QCheckBox):
                    widget.setChecked(
                        self.settings.value(setting_key, False, type=bool)
                    )  # [7645]
        if hasattr(self, "mpoint_widget_group"):  # [7646]
            for widget in self.mpoint_widget_group.values():
                widget.blockSignals(True)  # [7647]

        saved_mpoint_settings = self.settings.value(
            "controlPanel/mpointSettings", None
        )  # [7648]
        if isinstance(saved_mpoint_settings, dict):  # [7649]
            defaults = {
                "style": "circle",
                "size": 10,
                "label_enabled": False,
                "label_pos": "Up",
                "label_start": "1",
            }  # [7650]
            defaults.update(saved_mpoint_settings)
            self.overlay.mpoint_settings = defaults
            self.update_mpoint_controls(defaults)
            self.overlay._reset_next_mpoint_label()  # [7651]
        self.overlay.load_mpoint_label_style()  # [7652]
        self.settings.beginGroup("textDefaults")
        defaults = self.overlay.default_text_properties  # [7653]
        defaults["font"] = self.settings.value("font", defaults["font"])
        defaults["size"] = self.settings.value(
            "size", defaults["size"], type=int
        )  # [7654]
        defaults["bold"] = self.settings.value("bold", defaults["bold"], type=bool)
        defaults["italic"] = self.settings.value(
            "italic", defaults["italic"], type=bool
        )  # [7655]
        defaults["underline"] = self.settings.value(
            "underline", defaults["underline"], type=bool
        )
        defaults["strikeout"] = self.settings.value(
            "strikeout", defaults["strikeout"], type=bool
        )  # [7656]
        defaults["color"] = self.settings.value("color", defaults["color"])
        bg_color_setting = self.settings.value("backgroundColor")  # [7657]
        defaults["background_color"] = (
            bg_color_setting if bg_color_setting is not None else None
        )
        defaults["alignment"] = self.settings.value(
            "alignment", defaults["alignment"]
        )  # [7658]
        defaults["curve_angle"] = int(
            self.settings.value("curve_angle", defaults.get("curve_angle", 0))
        )
        self.settings.endGroup()  # [7659]
        self.overlay.default_text_properties = defaults
        self.update_text_tool_button_style()  # [7660]
        self.update_hide_button_visuals(self.overlay.shapes_visible)  # [7661]
        self.overlay.load_angle_tool_settings()  # [7662]
        self.overlay.load_hatch_fill_settings()  # [7663]
        self._zoom_first_use_info_shown = self.settings.value(
            "magnifier/firstUseInfoShown", False, type=bool
        )  # [7664]

        # Load dark mode setting and apply it # [7665]
        dark_mode_enabled = self.settings.value(
            "controlPanel/darkModeEnabled", False, type=bool
        )  # [7666]
        self.dark_mode_button.setChecked(dark_mode_enabled)  # [7667]
        if dark_mode_enabled:  # [7668]
            self.dark_mode_button.setText("LIGHT")  # [7669]
        else:  # [7670]
            self.dark_mode_button.setText("DARK")  # [7671]
        app = QApplication.instance()  # [7672]
        if _QDARKSTYLE_AVAILABLE:  # [7673]
            if dark_mode_enabled:  # [7674]
                app.setStyleSheet(
                    qdarkstyle.load_stylesheet(qt_api="pyside6")
                )  # [7675]
                print("Applied Dark Theme on startup.")  # [7676]
            else:  # [7677]
                app.setStyleSheet("")  # [7678]
                print("Applied Light Theme on startup.")  # [7679]
        else:  # [7680]
            app.setStyleSheet("")  # [7681]
            print(
                "WARNING: qdarkstyle not available, theme not applied on startup."
            )  # [7682]
            self.dark_mode_button.setChecked(False)  # [7683]
            self.settings.setValue("controlPanel/darkModeEnabled", False)  # [7684]

        self.overlay.blockSignals(False)
        self.alpha_spin.blockSignals(False)
        self.thickness_spin.blockSignals(False)  # [7685]
        self.style_combo.blockSignals(False)
        self.arrow_size_spin.blockSignals(False)
        self.brush_size_spin.blockSignals(False)  # [7686]
        self.time_spin.blockSignals(False)
        self.fill_check.blockSignals(False)
        self.dim_check.blockSignals(False)  # [7687]
        self.tool_text_check.blockSignals(False)
        self.clear_warning_check.blockSignals(False)  # [7688]
        self.center_check.blockSignals(False)  # [7689]
        self.divide_check.blockSignals(False)  # [7690]
        self.divisions_spin.blockSignals(False)  # [7691]
        self.division_settings_group["color_button"].blockSignals(False)  # [7692]
        self.division_settings_group["size_spin"].blockSignals(False)  # [7693]
        self.dark_mode_button.blockSignals(False)  # [7694]
        for widget in self.angle_tool_widget_group.values():
            widget.blockSignals(False)  # [7695]
        for widget in self.hatch_widget_group.values():
            widget.blockSignals(False)  # [7696]
        if hasattr(self, "line_point_arrow_group"):  # [7697]
            if hasattr(self, "line_point_no_arrow_radio"):  # [7698]
                self.line_point_no_arrow_radio.blockSignals(False)  # [7699]
                self.line_point_1a_radio.blockSignals(False)  # [7700]
                self.line_point_2a_radio.blockSignals(False)  # [7701]
            if hasattr(self, "line_point_no_arrow_radio_spline"):  # [7702]
                self.line_point_no_arrow_radio_spline.blockSignals(False)  # [7703]
                self.line_point_1a_radio_spline.blockSignals(False)  # [7704]
                self.line_point_2a_radio_spline.blockSignals(False)  # [7705]

        for tool, widgets in self.fixed_size_widgets.items():  # [7706]
            for name, widget in widgets.items():  # [7707]
                if name == "clear_button":
                    continue  # [7708]
                if isinstance(widget, (QSpinBox, QCheckBox, QDoubleSpinBox)):
                    widget.blockSignals(False)  # [7709]
        if hasattr(self, "mpoint_widget_group"):  # [7710]
            for widget in self.mpoint_widget_group.values():
                widget.blockSignals(False)  # [7711]
        self.update_text_tool_button_style()
        self.update_draw_mode_button_visuals()
        self.update_edit_mode_button_visuals()  # [7712]
        self.update_board_mode_button_visuals()
        self.update_temp_mode_button_visuals()  # [7713]
        self.update_hatch_fill_controls()  # [7714]

    def save_settings(self):  # [7715]
        # Instead of if not self.isMinimized(): self.settings.setValue("controlPanel/geometry", self.geometry())
        # or self.settings.setValue("controlPanel/geometry", self.saveGeometry())
        # We will use manual position and size saving

        current_pos_before_save = self.pos()
        current_size_before_save = self.size()

        if (
            self.isVisible() and not self.isMinimized() and self.parentWidget() is None
        ):  # Also check if it's a top-level window (not docked)
            self.settings.setValue("controlPanel/pos_x", current_pos_before_save.x())
            self.settings.setValue("controlPanel/pos_y", current_pos_before_save.y())
            self.settings.setValue(
                "controlPanel/size_w", current_size_before_save.width()
            )
            self.settings.setValue(
                "controlPanel/size_h", current_size_before_save.height()
            )
            print(
                f"ControlPanel save_settings: Saved manual pos=({current_pos_before_save.x()},{current_pos_before_save.y()}), size=({current_size_before_save.width()},{current_size_before_save.height()})"
            )
        else:
            # If window is hidden/minimized or docked, do not overwrite last good pos/size
            # unless they are not in settings. This prevents saving "disappeared" geometry.
            if not self.settings.contains(
                "controlPanel/pos_x"
            ):  # Just need to check one key
                self.settings.setValue(
                    "controlPanel/pos_x", current_pos_before_save.x()
                )
                self.settings.setValue(
                    "controlPanel/pos_y", current_pos_before_save.y()
                )
                self.settings.setValue(
                    "controlPanel/size_w", current_size_before_save.width()
                )
                self.settings.setValue(
                    "controlPanel/size_h", current_size_before_save.height()
                )
                print(
                    f"ControlPanel save_settings (fallback for hidden/minimized/docked): Saved manual pos=({current_pos_before_save.x()},{current_pos_before_save.y()}), size=({current_size_before_save.width()},{current_size_before_save.height()})"
                )
            else:
                print(
                    f"ControlPanel save_settings: Window not in normal floating state (Visible: {self.isVisible()}, Minimized: {self.isMinimized()}, Floating: {self.isFloating()}), not overwriting pos/size."
                )

        self.settings.setValue(
            "controlPanel/drawPenColor",
            self.overlay.current_pen_color.name(QColor.NameFormat.HexArgb),
        )  # [7716]
        self.settings.setValue(
            "controlPanel/tempPenColor",
            self.overlay.current_pen_color_temp.name(QColor.NameFormat.HexArgb),
        )  # [7717]
        self.settings.setValue(
            "controlPanel/tempDuration", self.overlay.temp_mode_shape_duration
        )  # [7718]
        self.settings.setValue(
            "controlPanel/currentTool", self.overlay.current_tool
        )  # [7719]
        self.settings.setValue(
            "controlPanel/alpha", self.overlay.current_alpha
        )  # [7720]
        self.settings.setValue(
            "controlPanel/thickness", self.overlay.current_line_thickness
        )  # [7721]
        current_style_data = self.style_combo.currentData()
        style_val_to_save = Qt.PenStyle.SolidLine.value
        pattern_to_save = None  # [7722]
        if current_style_data:
            style_enum, pattern = current_style_data
            style_val_to_save = style_enum.value
            pattern_to_save = pattern  # [7723]
        self.settings.setValue(
            "controlPanel/lineStyleValue", style_val_to_save
        )  # [7724]
        self.settings.setValue(
            "controlPanel/linePattern",
            json.dumps(pattern_to_save) if pattern_to_save is not None else None,
        )  # [7725]
        self.settings.setValue(
            "controlPanel/arrowSize", self.overlay.current_arrow_head_size
        )
        self.settings.setValue(
            "controlPanel/brushSize", self.overlay.brush_size
        )  # [7726]
        self.settings.setValue("controlPanel/fillChecked", self.fill_check.isChecked())
        self.settings.setValue(
            "controlPanel/dimmChecked", self.dim_check.isChecked()
        )  # [7727]
        self.settings.setValue(
            "controlPanel/showToolText", self.tool_text_check.isChecked()
        )
        self.settings.setValue(
            "controlPanel/clearWarningChecked", self.clear_warning_check.isChecked()
        )  # [7728]
        self.settings.setValue(
            "controlPanel/showCenterPoint", self.overlay.show_center_point
        )  # [7729]
        self.settings.setValue(
            "controlPanel/divideEnabled", self.overlay.divide_enabled
        )  # [7730]
        self.settings.setValue(
            "controlPanel/numberOfDivisions", self.overlay.number_of_divisions
        )  # [7731]
        self.overlay.save_division_point_settings()  # [7732]

        self.settings.setValue(
            "controlPanel/linePointArrowStyle",
            self.overlay.current_line_point_arrow_style,
        )  # [7733]
        for tool, widgets in self.fixed_size_widgets.items():  # [7734]
            if (
                tool == "dimension"
                and "SuffixEdit" in widgets
                and isinstance(widgets["SuffixEdit"], QLineEdit)
            ):  # [7735]
                self.settings.setValue(
                    f"controlPanel/fixedSize/{tool}_SuffixEdit",
                    widgets["SuffixEdit"].text(),
                )  # [7736]
            for name, widget in widgets.items():  # [7737]
                if name == "clear_button":
                    continue  # [7738]
                setting_key = f"controlPanel/fixedSize/{tool}_{name}"  # [7739]
                if isinstance(widget, QSpinBox):
                    self.settings.setValue(setting_key, widget.value())  # [7740]
                elif isinstance(widget, QDoubleSpinBox):
                    self.settings.setValue(setting_key, widget.value())  # [7741]
                elif isinstance(widget, QCheckBox):
                    self.settings.setValue(setting_key, widget.isChecked())  # [7742]
        if hasattr(self.overlay, "mpoint_settings"):
            self._update_mpoint_setting()
            self.settings.setValue(
                "controlPanel/mpointSettings", self.overlay.mpoint_settings
            )  # [7743]
        self.overlay.save_mpoint_label_style()  # [7744]
        if hasattr(self.overlay, "default_text_properties"):  # [7745]
            defaults = self.overlay.default_text_properties
            self.settings.beginGroup("textDefaults")  # [7746]
            self.settings.setValue("font", defaults.get("font", "Arial"))
            self.settings.setValue("size", defaults.get("size", 12))  # [7747]
            self.settings.setValue("bold", defaults.get("bold", False))
            self.settings.setValue("italic", defaults.get("italic", False))  # [7748]
            self.settings.setValue("underline", defaults.get("underline", False))
            self.settings.setValue(
                "strikeout", defaults.get("strikeout", False)
            )  # [7749]
            self.settings.setValue("color", defaults.get("color", "#000000"))
            self.settings.setValue(
                "backgroundColor", defaults.get("background_color")
            )  # [7750]
            self.settings.setValue("alignment", defaults.get("alignment", "left"))
            self.settings.setValue(
                "curve_angle", defaults.get("curve_angle", 0)
            )  # [7751]
            self.settings.endGroup()  # [7752]
        self.overlay.save_board_settings()
        self.overlay.save_dimension_text_defaults()
        self.overlay.save_dimension_preview_line_color()  # [7753]
        self.overlay.save_angle_tool_settings()  # [7754]
        self.overlay.save_hatch_fill_settings()  # [7755]

        self.settings.setValue(
            "controlPanel/darkModeEnabled", self.dark_mode_button.isChecked()
        )  # [7756] # NEW LINE

        self.settings.sync()  # [7757]

    def adjust_position(self):  # [7758]
        try:  # [7759]
            screen_geo = QGuiApplication.primaryScreen().availableGeometry()
            print(
                f"ControlPanel adjust_position: Screen available geometry: {screen_geo}"
            )

            # Use sizeHint as preferred size if current size is too small
            # or if restoreGeometry failed.
            hint_w = self.sizeHint().width()
            hint_h = self.sizeHint().height()
            min_hint_w = self.minimumSizeHint().width()
            min_hint_h = self.minimumSizeHint().height()

            current_w = self.width()
            current_h = self.height()
            print(
                f"ControlPanel adjust_position: Initial current size: {current_w}x{current_h}, Hint: {hint_w}x{hint_h}, MinHint: {min_hint_w}x{min_hint_h}"
            )

            panel_width = current_w
            # If width is too small, try sizeHint, then minimumSizeHint, then a constant
            if panel_width <= 100:
                panel_width = hint_w if hint_w > 100 else min_hint_w
            if panel_width <= 100:
                panel_width = 550

            panel_height = current_h
            if panel_height <= 100:
                panel_height = hint_h if hint_h > 100 else min_hint_h
            if panel_height <= 100:
                panel_height = 700

            # Adjust to screen sizes, but not less than minimumSize
            panel_width = min(panel_width, screen_geo.width() - 20)
            panel_height = min(panel_height, screen_geo.height() - 40)

            # Ensure size is not less than the minimum defined for the widget
            panel_width = max(panel_width, self.minimumWidth())
            panel_height = max(panel_height, self.minimumHeight())

            self.resize(panel_width, panel_height)
            print(f"ControlPanel adjust_position: Resized to {self.size()}")

            # Positioning - top right corner as default
            x = screen_geo.right() - panel_width - 10  # 10px from right edge
            y = screen_geo.top() + 10  # 10px from top edge

            # Ensure it's within screen boundaries
            x = max(screen_geo.left(), min(x, screen_geo.right() - panel_width))
            y = max(screen_geo.top(), min(y, screen_geo.bottom() - panel_height))

            self.move(x, y)
            print(
                f"ControlPanel adjust_position: Final geometry: {self.geometry()}"
            )  # [7760]
        except Exception as e:
            print(f"Error in ControlPanel.adjust_position: {e}")  # [7761]
            traceback.print_exc()
            # Absolute fallback in case of error
            self.resize(550, 700)
            self.move(50, 50)

    def choose_draw_color(self):  # [7762]
        initial_color = self.overlay.current_pen_color  # [7763]
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Draw Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )  # [7764]
        if color.isValid():  # [7765]
            self.overlay.set_pen_color(color)  # [7766]
            alpha_percent = round(color.alpha() / 2.55)  # [7767]
            self.alpha_spin.blockSignals(True)
            self.alpha_spin.setValue(alpha_percent)
            self.alpha_spin.blockSignals(False)  # [7768]
            self.overlay.set_alpha(alpha_percent)  # [7769]

    def choose_edit_pen_color(self):  # [7770]
        print(
            "Note: Standard color dialog does not support gradient selection."
        )  # [7771]
        initial_color = self.overlay.current_pen_color_edit  # [7772]
        color = QColorDialog.getColor(
            initial_color, self, "Choose Edit Pen Color"
        )  # [7773]
        if color.isValid():  # [7774]
            self.overlay.set_edit_pen_color(color)  # [7775]
            if self.overlay.edit_mode:
                self.overlay.update()  # [7776]

    def choose_board_pen_color(self):  # [7777]
        initial_color = self.overlay.current_pen_color_board_only  # [7778]
        color = QColorDialog.getColor(
            initial_color, self, "Choose Board Pen Color"
        )  # [7779]
        if color.isValid():  # [7780]
            self.overlay.set_board_pen_color_only(color)  # [7781]
            if self.overlay.board_mode and not self.overlay.edit_mode:
                self.overlay.update()  # [7782]

    def choose_board_background_color(self):  # [7783]
        initial_color = self.overlay.board_background_color  # [7784]
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Board Background Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )  # [7785]
        if color.isValid():
            self.overlay.set_board_background_color(color)  # [7786]

    def choose_temp_color(self):  # [7787]
        initial_color = self.overlay.current_pen_color_temp  # [7788]
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Temp Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )  # [7789]
        if color.isValid():  # [7790]
            self.overlay.set_temp_pen_color(color)  # [7791]
            if self.overlay.temp_mode:
                self.overlay.update()  # [7792]

    def choose_dimension_preview_color(self):  # [7793]
        initial_color = self.overlay.dimension_preview_line_color  # [7794]
        color = QColorDialog.getColor(
            initial_color,
            self,
            "Choose Dimension Preview Line Color",
            QColorDialog.ColorDialogOption.ShowAlphaChannel,
        )  # [7795]
        if color.isValid():
            self.overlay.set_dimension_preview_line_color(color)  # [7796]

    @Slot(QColor)  # [7797]
    def update_angle_tool_color_button_style(self, color):  # [7798]
        if hasattr(self, "angle_tool_color_button") and color.isValid():  # [7799]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)  # [7800]
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7801]
            self.angle_tool_color_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css}; border: 1px solid grey;"
            )  # [7802]
            self.angle_tool_color_button.setToolTip(
                f"Angle Tool Line & Default Text Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7803]
        elif hasattr(self, "angle_tool_color_button"):  # [7804]
            self.angle_tool_color_button.setStyleSheet(
                self.original_button_style
            )  # [7805]
            self.angle_tool_color_button.setToolTip(
                "Invalid Angle Tool Color"
            )  # [7806]

    @Slot(QColor)  # [7807]
    def update_hatch_fill_color_button_style(self, color):  # [7808]
        if hasattr(self, "hatch_color_button") and color.isValid():  # [7809]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)  # [7810]
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7811]
            self.hatch_color_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css}; border: 1px solid grey;"
            )  # [7812]
            self.hatch_color_button.setToolTip(
                f"Hatch Fill Line Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7813]
        elif hasattr(self, "hatch_color_button"):  # [7814]
            self.hatch_color_button.setStyleSheet(self.original_button_style)  # [7815]
            self.hatch_color_button.setToolTip("Invalid Hatch Fill Color")  # [7816]

    @Slot(QColor)  # [7817]
    def update_division_point_color_button_style(self, color):  # [7818]
        if hasattr(self, "division_point_color_button") and color.isValid():  # [7819]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)  # [7820]
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7821]
            self.division_point_color_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css}; border: 1px solid grey;"
            )  # [7822]
            self.division_point_color_button.setToolTip(
                f"Division Point Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7823]
        elif hasattr(self, "division_point_color_button"):  # [7824]
            self.division_point_color_button.setStyleSheet(
                self.original_button_style
            )  # [7825]
            self.division_point_color_button.setToolTip(
                "Invalid Division Point Color"
            )  # [7826]

    @Slot(float)  # [7827]
    def update_division_point_size_spin_value(self, size):  # [7828]
        if hasattr(self, "division_point_size_spin"):  # [7829]
            self.division_point_size_spin.blockSignals(True)  # [7830]
            self.division_point_size_spin.setValue(size)  # [7831]
            self.division_point_size_spin.blockSignals(False)  # [7832]

    @Slot(QColor)  # [7833]
    def update_draw_color_preview_button(self, color):  # [7834]
        if color.isValid():  # [7835]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7836]
            self.draw_color_preview_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css};"
            )
            self.draw_color_preview_button.setToolTip(
                f"Draw Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7837]
        else:
            self.draw_color_preview_button.setStyleSheet(self.original_button_style)
            self.draw_color_preview_button.setToolTip("Invalid Draw Color")  # [7838]

    @Slot(QColor)  # [7839]
    def update_edit_pen_color_preview_button(self, color):  # [7840]
        if color.isValid():  # [7841]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7842]
            self.edit_pen_color_preview_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css};"
            )
            self.edit_pen_color_preview_button.setToolTip(
                f"Edit Pen Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7843]
        else:
            self.edit_pen_color_preview_button.setStyleSheet(self.original_button_style)
            self.edit_pen_color_preview_button.setToolTip(
                "Invalid Edit Pen Color"
            )  # [7844]

    @Slot(QColor)  # [7845]
    def update_board_pen_color_preview_button(self, color):  # [7846]
        if color.isValid():  # [7847]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7848]
            self.board_pen_color_preview_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css};"
            )
            self.board_pen_color_preview_button.setToolTip(
                f"Board Pen Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7849]
        else:
            self.board_pen_color_preview_button.setStyleSheet(
                self.original_button_style
            )
            self.board_pen_color_preview_button.setToolTip(
                "Invalid Board Pen Color"
            )  # [7850]

    @Slot(QColor)  # [7851]
    def update_board_bg_color_preview_button(self, color):  # [7852]
        if color.isValid():  # [7853]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7854]
            self.board_bg_color_preview_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css};"
            )
            self.board_bg_color_preview_button.setToolTip(
                f"Board Background Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7855]
        else:
            self.board_bg_color_preview_button.setStyleSheet(self.original_button_style)
            self.board_bg_color_preview_button.setToolTip(
                "Invalid Board Background Color"
            )  # [7856]

    @Slot(QColor)  # [7857]
    def update_temp_color_preview_button(self, color):  # [7858]
        if color.isValid():  # [7859]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7860]
            self.temp_color_preview_button.setStyleSheet(
                f"background-color: {bg_color_css}; color: {text_color_css};"
            )
            self.temp_color_preview_button.setToolTip(
                f"Temp Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7861]
        else:
            self.temp_color_preview_button.setStyleSheet(self.original_button_style)
            self.temp_color_preview_button.setToolTip("Invalid Temp Color")  # [7862]

    @Slot(QColor)  # [7863]
    def update_dimension_preview_color_button_style(self, color: QColor):  # [7864]
        """Updates the style of the dimension preview line color button."""  # [7865]
        if (
            hasattr(self, "dimension_preview_color_button") and color.isValid()
        ):  # [7866]
            bg_color_css = color.name(QColor.NameFormat.HexRgb)  # [7867]
            text_color_css = "white" if color.lightnessF() < 0.5 else "black"  # [7868]
            self.dimension_preview_color_button.setStyleSheet(  # [7869]
                f"background-color: {bg_color_css}; color: {text_color_css}; border: 1px solid grey;"  # [7870]
            )  # [7871]
            self.dimension_preview_color_button.setToolTip(
                f"Dimension Preview Line Color: {color.name(QColor.NameFormat.HexArgb)}"
            )  # [7872]
        elif hasattr(self, "dimension_preview_color_button"):  # [7873]
            self.dimension_preview_color_button.setStyleSheet(
                self.original_button_style
            )  # [7874]
            self.dimension_preview_color_button.setToolTip(
                "Invalid Dimension Preview Line Color"
            )  # [7875]

    @Slot(str)  # Added slot for snap_mode_changed # [7876]
    def update_snap_controls_from_settings(self, mode: Optional[str] = None):  # [7877]
        """Updates Snap mode UI controls based on signal or current settings."""  # [7878]
        if not hasattr(self.overlay, "snap_mode") or not hasattr(
            self.overlay, "snap_sensitivity"
        ):  # [7879]
            print(
                "Warning: Overlay does not have snap_mode or snap_sensitivity attributes yet."
            )  # [7880]
            return  # [7881]

        current_mode = mode if mode is not None else self.overlay.snap_mode  # [7882]
        current_sensitivity = self.overlay.snap_sensitivity  # [7883]

        self.snap_to_lines_checkbox.blockSignals(True)  # [7884]
        self.snap_to_grid_checkbox.blockSignals(True)  # [7885]
        self.snap_to_all_checkbox.blockSignals(True)  # [7886]
        self.snap_off_radio.blockSignals(True)  # [7887]
        self.snap_sensitivity_spinbox.blockSignals(True)  # [7888]

        self.snap_to_lines_checkbox.setChecked(current_mode == "lines")  # [7889]
        self.snap_to_grid_checkbox.setChecked(current_mode == "grid")  # [7890]
        self.snap_to_all_checkbox.setChecked(current_mode == "all")  # [7891]
        self.snap_off_radio.setChecked(current_mode == "none")  # [7892]

        self.snap_sensitivity_spinbox.setValue(current_sensitivity)  # [7893]

        self.snap_to_lines_checkbox.blockSignals(False)  # [7894]
        self.snap_to_grid_checkbox.blockSignals(False)  # [7895]
        self.snap_to_all_checkbox.blockSignals(False)  # [7896]
        self.snap_off_radio.blockSignals(False)  # [7897]
        self.snap_sensitivity_spinbox.blockSignals(False)  # [7898]
        print(
            f"ControlPanel UI updated for snap_mode: {current_mode}, sensitivity: {current_sensitivity}"
        )  # [7899]

    @Slot(bool)  # [7900]
    def update_draw_button_state(self, is_drawing):  # [7901]
        self.drawing_button.blockSignals(True)
        self.drawing_button.setChecked(is_drawing)
        self.drawing_button.blockSignals(False)  # [7902]

    @Slot()  # [7903]
    def update_draw_mode_button_visuals(self, is_drawing=None):  # [7904]
        if is_drawing is None:
            is_drawing = self.overlay.drawing_mode  # [7905]
        self.update_draw_button_state(is_drawing)  # [7906]
        is_normal_draw_active = (
            is_drawing
            and not self.overlay.edit_mode
            and not self.overlay.board_mode
            and not self.overlay.temp_mode
        )  # [7907]
        self.drawing_button.setStyleSheet(
            self.active_mode_style
            if is_normal_draw_active
            else self.original_button_style
        )  # [7908]

    @Slot(bool)  # [7909]
    def update_edit_mode_button_visuals(self, is_edit=None):  # [7910]
        if is_edit is None:
            is_edit = self.overlay.edit_mode  # [7911]
        self.edit_button.setStyleSheet(
            self.active_mode_style if is_edit else self.original_button_style
        )  # [7912]

    @Slot(bool)  # [7913]
    def update_board_mode_button_visuals(self, is_board=None):  # [7914]
        if is_board is None:
            is_board = self.overlay.board_mode and not self.overlay.edit_mode  # [7915]
        self.board_button.setStyleSheet(
            self.active_mode_style if is_board else self.original_button_style
        )  # [7916]

    @Slot(bool)  # [7917]
    def update_temp_mode_button_visuals(self, is_temp=None):  # [7918]
        if is_temp is None:
            is_temp = self.overlay.temp_mode  # [7919]
        self.temp_button.setStyleSheet(
            self.active_mode_style if is_temp else self.original_button_style
        )  # [7920]

    @Slot(bool)  # [7921]
    def update_hide_button_visuals(self, visible):  # [7922]
        is_hidden = not visible  # [7923]
        self.hide_shapes_button.blockSignals(True)
        self.hide_shapes_button.setChecked(is_hidden)  # [7924]
        self.hide_shapes_button.setText("SHOW" if is_hidden else "HIDE")
        self.hide_shapes_button.blockSignals(False)  # [7925]

    @Slot(bool)  # [7926]
    def update_center_button_visuals(self, show_center):  # [7927]
        self.center_check.blockSignals(True)  # [7928]
        self.center_check.setChecked(show_center)  # [7929]
        self.center_check.blockSignals(False)  # [7930]

    @Slot(bool)  # [7931]
    def update_divide_controls_visuals_slot_bool(self, enabled):  # [7932]
        self.update_divide_controls_visuals(
            enabled, self.overlay.number_of_divisions
        )  # [7933]

    @Slot(int)  # [7934]
    def update_divide_controls_visuals_slot_int(self, num_divisions):  # [7935]
        self.update_divide_controls_visuals(
            self.overlay.divide_enabled, num_divisions
        )  # [7936]

    def update_divide_controls_visuals(self, enabled, num_divisions):  # [7937]
        """Updates the visual state of division controls."""  # [7938]
        self.divide_check.blockSignals(True)  # [7939]
        self.divide_check.setChecked(enabled)  # [7940]
        self.divide_check.blockSignals(False)  # [7941]

        self.divisions_spin.blockSignals(True)  # [7942]
        self.divisions_spin.setValue(num_divisions)  # [7943]
        self.divisions_spin.setEnabled(enabled)  # [7944]
        self.divisions_spin.blockSignals(False)  # [7945]

    @Slot(str)  # [7946]
    def set_tool(self, tool):  # [7947]
        if tool not in self.tool_buttons:
            return  # [7948]
        if self.overlay.current_tool != tool:  # [7949]
            self.overlay.current_tool = tool
            self.overlay.unsetCursor()  # [7950]
            self.overlay.current_drawing_shape = None
            self.overlay.polygon_points.clear()
            self.overlay.brush_points.clear()
            self.overlay.angle_points.clear()
            self.overlay.spline_points.clear()  # [7951]
            self.overlay.dragging = False
            self.overlay.resizing = False
            self.overlay.is_lasso_selecting = False  # [7952]
            if self.overlay.input_mode:
                self.overlay.input_mode = None  # [7953]
            self.overlay.dimension_points.clear()
            self.overlay.dimension_preview_shapes.clear()  # [7954]
            if (
                tool == "dimension"
                and hasattr(self.overlay, "overlay")
                and self.overlay is not None
                and not self.overlay.dimension_preview_color_explicitly_set
            ):  # [7955]
                new_preview_color = QColor(self.overlay.current_pen_color)
                new_preview_color.setAlpha(100)  # [7956]
                self.overlay.overlay.set_dimension_preview_line_color(
                    new_preview_color, from_pen_color_change=True
                )  # [7957]
            self.overlay.active_angle_shape_for_point_drag = None
            self.overlay.active_angle_point_handle = None  # [7958]
            self.overlay.update()
            print(f"Control panel: Tool set to: {tool}")  # [7959]
        if not self.tool_buttons[tool].isChecked():  # [7960]
            self.tool_buttons[tool].blockSignals(True)
            self.tool_buttons[tool].setChecked(True)
            self.tool_buttons[tool].blockSignals(False)  # [7961]

        if hasattr(self, "line_point_arrow_group"):  # [7962]
            enable_arrow_controls_lp = tool == "line_point"  # [7963]
            self.line_point_no_arrow_radio.setEnabled(
                enable_arrow_controls_lp
            )  # [7964]
            self.line_point_1a_radio.setEnabled(enable_arrow_controls_lp)  # [7965]
            self.line_point_2a_radio.setEnabled(enable_arrow_controls_lp)  # [7966]

            enable_arrow_controls_spline = tool == "spline"  # [7967]
            if hasattr(self, "line_point_no_arrow_radio_spline"):  # [7968]
                self.line_point_no_arrow_radio_spline.setEnabled(
                    enable_arrow_controls_spline
                )  # [7969]
                self.line_point_1a_radio_spline.setEnabled(
                    enable_arrow_controls_spline
                )  # [7970]
                self.line_point_2a_radio_spline.setEnabled(
                    enable_arrow_controls_spline
                )  # [7971]

        self.overlay.update()  # [7972]

    @Slot(int)  # [7973]
    def set_brush_size(self, size):  # [7974]
        size = max(1, size)  # [7975]
        if size != self.overlay.brush_size:  # [7976]
            self.overlay.brush_size = size
            print(f"Brush size set to: {self.overlay.brush_size}")
            self.overlay.update()  # [7977]

    @Slot(int)  # [7978]
    def on_style_combo_activated(self, index):  # [7979]
        style_data = self.style_combo.itemData(index)  # [7980]
        if style_data:
            style_enum, pattern = style_data
            self.overlay.set_line_style(style_enum.value, pattern)  # [7981]

    @Slot(int)  # [7982]
    def update_fill_state_and_hatch(self, state):  # [7983]
        is_filled = state == Qt.CheckState.Checked.value  # [7984]

        if self.overlay.selected_shapes:  # [7985]
            changed_shapes = []  # [7986]
            prev_props = {}  # [7987]
            current_indices = []  # [7988]
            for shape in self.overlay.selected_shapes:  # [7989]
                is_shape_fillable = (
                    shape.type
                    in [
                        "rect",
                        "ellipse",
                        "triangle",
                        "polygon",
                        "trapeze",
                        "regular_polygon",
                        "arc",
                    ]
                    or shape.is_mpoint_marker
                )  # [7990]
                if is_shape_fillable:  # [7991]
                    try:  # [7992]
                        idx = self.overlay.shapes.index(shape)  # [7993]
                        prev_props[idx] = deepcopy(shape)  # [7994]
                        shape.filled = is_filled  # [7995]
                        # Removed: if shape.filled and shape.hatch_properties: shape.hatch_properties = None # [7996]
                        changed_shapes.append(shape)  # [7997]
                        current_indices.append(idx)  # [7998]
                    except ValueError:  # [7999]
                        continue  # [8000]
            if changed_shapes:  # [8001]
                self.overlay.save_state(
                    "toggle_fill",
                    shapes_involved=changed_shapes,
                    previous_geometries=prev_props,
                    indices=current_indices,
                )  # [8002]
                # self.overlay.update() # Removed, will be at the end

        # Update the state of hatch buttons based on fill state
        # If fill is enabled, hatching is disabled (as they are visually exclusive in this implementation)
        # Removed block:
        # if is_filled: # [8003]
        #     if self.hatch_forward_slash_check.isChecked(): self.hatch_forward_slash_check.setChecked(False)
        #     if self.hatch_backward_slash_check.isChecked(): self.hatch_backward_slash_check.setChecked(False)
        #     if self.hatch_horizontal_check.isChecked(): self.hatch_horizontal_check.setChecked(False)
        #     if self.hatch_vertical_check.isChecked(): self.hatch_vertical_check.setChecked(False)

        # Always call overlay update to refresh Fill:ON/OFF indicator
        self.overlay.update()

    @Slot()  # [8004]
    def update_controls_from_defaults(self):  # [8005]
        self.update_text_tool_button_style()  # [8006]

    def update_text_tool_button_style(self):  # [8007]
        text_tool_btn = self.tool_buttons.get("text")  # [8008]
        if text_tool_btn:
            text_tool_btn.setStyleSheet("")  # [8009]

    @Slot()  # [8010]
    def save_scene_action(self):  # [8011]
        filename, selected_filter = QFileDialog.getSaveFileName(  # [8012]
            self,
            "Save Scene",
            "",  # [8013]
            "JSON Files (*.json);;SVG Files (*.svg)",  # [8014]
        )  # [8015]
        if filename:  # [8016]
            if selected_filter == "SVG Files (*.svg)":  # [8017]
                if not filename.lower().endswith(".svg"):  # [8018]
                    filename += ".svg"  # [8019]
                self.overlay.export_scene_to_svg(filename)  # [8020]
            else:  # [8021]
                if not filename.lower().endswith(".json"):  # [8022]
                    filename += ".json"  # [8023]
                self.overlay.save_scene(filename)  # [8024]

    @Slot()  # [8025]
    def load_scene_action(self):  # [8026]
        filename, _ = QFileDialog.getOpenFileName(
            self, "Load Scene", "", "JSON Files (*.json)"
        )  # [8027]
        if filename:
            self.overlay.load_scene(filename, join=False)  # [8028]

    @Slot()  # [8029]
    def load_and_join_scene_action(self):  # [8030]
        last_dir = self.settings.value(
            "paths/lastLoadJoinDir",
            QStandardPaths.writableLocation(
                QStandardPaths.StandardLocation.DocumentsLocation
            ),
        )  # [8031]
        filenames, _ = QFileDialog.getOpenFileNames(
            self, "Load & Join Scene(s)", last_dir, "JSON Files (*.json)"
        )  # [8032]
        if filenames:  # [8033]
            self.settings.setValue(
                "paths/lastLoadJoinDir", os.path.dirname(filenames[0])
            )  # [8034]
            total_loaded = 0
            shapes_before_join = deepcopy(self.overlay.shapes)
            selection_before_join = deepcopy(self.overlay.selected_shapes)  # [8035]
            initial_load_join_saved = False  # [8036]
            for filename in filenames:  # [8037]
                loaded_count = self.overlay.load_scene(filename, join=True)  # [8038]
                if loaded_count > 0 and not initial_load_join_saved:  # [8039]
                    self.overlay.save_state(
                        "load_join",
                        all_shapes_before=shapes_before_join,
                        selected_shapes_before=selection_before_join,
                        previous_geometries=0,
                    )  # [8040]
                    initial_load_join_saved = True  # [8041]
                total_loaded += loaded_count  # [8042]
            if (
                total_loaded > 0
                and self.overlay.undo_stack
                and self.overlay.undo_stack[-1]["action"] == "load_join"
            ):  # [8043]
                self.overlay.undo_stack[-1]["action_data"]["load_join_count"] = (
                    total_loaded  # [8044]
                )
                print(
                    f"Joined a total of {total_loaded} shapes from {len(filenames)} file(s)."
                )  # [8045]
            else:
                print(
                    "No shapes loaded from selected file(s) or undo stack inconsistent."
                )  # [8046]
        else:
            print("Load & Join cancelled.")  # [8047]

    @Slot()  # [8048]
    def load_background_image_action(self):  # [8049]
        last_dir = self.settings.value(
            "paths/lastImageDir",
            QStandardPaths.writableLocation(
                QStandardPaths.StandardLocation.PicturesLocation
            ),
        )  # [8050]
        filename, _ = QFileDialog.getOpenFileName(
            self,
            "Load Background Image",
            last_dir,
            "Images (*.png *.jpg *.jpeg *.bmp *.gif)",
        )  # [8051]
        if filename:
            self.settings.setValue("paths/lastImageDir", os.path.dirname(filename))
            self.overlay.set_background_image(filename)  # [8052]
        else:
            print("Background image load cancelled.")  # [8053]

    def toggle_shortcuts_window(self, force_reset=False):  # [8054]
        if self.shortcuts_window is None:
            self.shortcuts_window = ShortcutsWindow(self, self.settings)
            force_reset = True  # [8055]
        if not self.shortcuts_window.isVisible():  # [8056]
            if (
                force_reset
                or not self.shortcuts_window.restore_geometry_from_settings()
            ):
                self.shortcuts_window.reset_and_center()  # [8057]
            self.shortcuts_window.show()
            self.shortcuts_window.activateWindow()  # [8058]
        else:
            self.shortcuts_window.hide()  # [8059]

    def close_all(self):  # [8060]
        self.save_settings()  # [8061]
        self.close_all_child_windows_if_any()  # Call the new method
        self.close()  # Calls this widget's closeEvent
        print("Control panel and its child windows closed (via close_all)")  # [8062]

    def close_all_child_windows_if_any(self):
        print(
            "ControlPanel: Closing its child windows (shortcuts, info, anim_config)..."
        )
        if self.shortcuts_window:  # Check if it exists
            if self.shortcuts_window.isVisible():
                print("ControlPanel: Closing shortcuts window.")
                self.shortcuts_window.setAttribute(
                    Qt.WidgetAttribute.WA_DeleteOnClose, True
                )
                self.shortcuts_window.close()
            self.shortcuts_window = None  # Remove reference if it should be recreated
        if self.info_dialog:  # Check if it exists
            if self.info_dialog.isVisible():
                print("ControlPanel: Closing info dialog.")
                self.info_dialog.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
                self.info_dialog.close()
            self.info_dialog = None
        if hasattr(self, "_anim_config_dialog") and self._anim_config_dialog:
            if self._anim_config_dialog.isVisible():
                print("ControlPanel: Closing animation config dialog.")
                self._anim_config_dialog.setAttribute(
                    Qt.WidgetAttribute.WA_DeleteOnClose, True
                )
                self._anim_config_dialog.reject()  # Use reject() or close()
            self._anim_config_dialog = None  # Remove reference

    def closeEvent(self, event: QCloseEvent):
        print("ControlPanel closeEvent triggered.")

        main_app = getattr(self, "main_app_parent", None)  # Safely get the reference

        if main_app:
            print(f"  CP.main_app_parent exists: {type(main_app)}")
            has_is_exiting = hasattr(main_app, "_is_exiting")
            print(f"  CP.main_app_parent has _is_exiting: {has_is_exiting}")
            if has_is_exiting:
                app_is_currently_exiting = main_app._is_exiting
                print(
                    f"  CP.main_app_parent._is_exiting value: {app_is_currently_exiting}"
                )
            else:
                app_is_currently_exiting = (
                    False  # Assume not exiting if flag doesn't exist
                )

            has_exit_method = hasattr(main_app, "_exit_application")
            print(f"  CP.main_app_parent has _exit_application: {has_exit_method}")

            if not app_is_currently_exiting:
                # App is not yet in the process of closing;
                # this event (e.g., clicking X) should initiate full shutdown.
                print(
                    "ControlPanel: Window X clicked, app is NOT exiting. Attempting to trigger main app exit."
                )
                if has_exit_method:
                    main_app._exit_application()  # Main closing method
                    # _exit_application will set _is_exiting to True and call app.quit(),
                    # which should re-trigger closeEvent for this window,
                    # but then app_is_currently_exiting will be True.
                    event.accept()  # Accept, because _exit_application will handle the rest.
                    return
                else:
                    # Critical error: missing closing method in main app.
                    print(
                        "ControlPanel: CRITICAL - _exit_application method missing on main_app. Forcing local save & app quit."
                    )
                    self.save_settings()
                    self.close_all_child_windows_if_any()
                    if self.zoom_enabled:
                        self.toggle_zoom(False)
                    QApplication.instance().quit()
                    event.accept()
                    return
            else:  # app_is_currently_exiting is True
                # App IS ALREADY in the process of closing (e.g., initiated by EXIT button).
                # This ControlPanel is being closed as part of that process.
                print(
                    "ControlPanel: App IS ALREADY exiting. Allowing natural close of this panel."
                )
                # Settings should already be saved by _exit_application.
                # Just clean up specifics for this panel here, if needed.
                self.close_all_child_windows_if_any()  # Just in case
                if self.zoom_enabled:
                    self.toggle_zoom(False)
                super().closeEvent(event)  # Allow standard closing of this widget.
                return
        else:
            # main_app_parent is not set. This shouldn't happen in normal flow,
            # but as a fallback, save settings and allow closing.
            print(
                "ControlPanel: Fallback - main_app_parent is None. Performing local cleanup and allowing super().closeEvent()."
            )
            self.save_settings()
            self.close_all_child_windows_if_any()
            if self.zoom_enabled:
                self.toggle_zoom(False)
            super().closeEvent(event)

    @Slot()
    def _trigger_main_app_exit(self):
        """Calls the closing method in the main application."""
        if self.main_app_parent and hasattr(self.main_app_parent, "_exit_application"):
            print("ControlPanel: EXIT button clicked, triggering main app exit.")
            self.main_app_parent._exit_application()
        else:
            print(
                "ERROR: main_app_parent not set or _exit_application not found in ControlPanel. Quitting directly."
            )
            QApplication.instance().quit()  # Fallback

    @Slot(bool)  # [8063]
    def handle_draw_mode_toggle(self, checked):  # [8064]
        if (
            not self.overlay.edit_mode
            and not self.overlay.board_mode
            and not self.overlay.temp_mode
        ):  # [8065]
            self.overlay.set_drawing_mode(checked)  # [8066]
        elif checked:  # [8067]
            print(
                "DRAW button clicked while in special mode. Exiting special mode..."
            )  # [8068]
            success = True  # [8069]
            if self.overlay.edit_mode or self.overlay.board_mode:
                success = self.overlay.exit_board_mode(
                    ask_save=False, configure=False
                )  # [8070]
            elif self.overlay.temp_mode:
                success = self.overlay.exit_temp_mode(configure=False)  # [8071]
            if success:
                self.overlay.set_drawing_mode(True)  # [8072]
            else:  # [8073]
                self.drawing_button.blockSignals(True)
                self.drawing_button.setChecked(False)
                self.drawing_button.blockSignals(False)  # [8074]
                self.update_draw_mode_button_visuals(False)  # [8075]

    def _update_mpoint_style(self, is_circle):  # [8076]
        if is_circle:  # [8077]
            if not self.mpoint_circle_radio.isChecked():
                self.mpoint_circle_radio.blockSignals(True)
                self.mpoint_circle_radio.setChecked(True)
                self.mpoint_circle_radio.blockSignals(False)  # [8078]
            if self.mpoint_square_check.isChecked():
                self.mpoint_square_check.blockSignals(True)
                self.mpoint_square_check.setChecked(False)
                self.mpoint_square_check.blockSignals(False)  # [8079]
        else:  # [8080]
            if not self.mpoint_square_check.isChecked():
                self.mpoint_square_check.blockSignals(True)
                self.mpoint_square_check.setChecked(True)
                self.mpoint_square_check.blockSignals(False)  # [8081]
            if self.mpoint_circle_radio.isChecked():
                self.mpoint_circle_radio.blockSignals(True)
                self.mpoint_circle_radio.setChecked(False)
                self.mpoint_circle_radio.blockSignals(False)  # [8082]
        self._update_mpoint_setting()  # [8083]

    @Slot()  # [8084]
    def _update_mpoint_setting(self):  # [8085]
        if not hasattr(self, "mpoint_widget_group") or not self.mpoint_widget_group:
            return  # [8086]
        settings = {  # [8087]
            "style": "circle"
            if self.mpoint_circle_radio.isChecked()
            else "square",  # [8088]
            "size": self.mpoint_size_spin.value(),
            "label_enabled": self.mpoint_label_check.isChecked(),  # [8089]
            "label_pos": self.mpoint_label_pos_combo.currentText(),
            "label_start": self.mpoint_label_start_edit.text() or "1",  # [8090]
        }  # [8091]
        self.overlay.update_mpoint_settings(settings)  # [8092]

    def update_mpoint_controls(self, settings):  # [8093]
        if not hasattr(self, "mpoint_widget_group") or not self.mpoint_widget_group:
            return  # [8094]
        widgets = self.mpoint_widget_group
        style = settings.get("style", "circle")  # [8095]
        widgets["circle_radio"].blockSignals(True)
        widgets["circle_radio"].setChecked(style == "circle")
        widgets["circle_radio"].blockSignals(False)  # [8096]
        widgets["square_check"].blockSignals(True)
        widgets["square_check"].setChecked(style == "square")
        widgets["square_check"].blockSignals(False)  # [8097]
        widgets["size_spin"].blockSignals(True)
        widgets["size_spin"].setValue(settings.get("size", 10))
        widgets["size_spin"].blockSignals(False)  # [8098]
        widgets["label_check"].blockSignals(True)
        widgets["label_check"].setChecked(settings.get("label_enabled", False))
        widgets["label_check"].blockSignals(False)  # [8099]
        widgets["pos_combo"].blockSignals(True)
        widgets["pos_combo"].setCurrentText(settings.get("label_pos", "Up"))
        widgets["pos_combo"].blockSignals(False)  # [8100]
        widgets["start_edit"].blockSignals(True)
        widgets["start_edit"].setText(settings.get("label_start", "1"))
        widgets["start_edit"].blockSignals(False)  # [8101]

    @Slot()  # [8102]
    def configure_mpoint_label_style(self):  # [8103]
        if not hasattr(self.overlay, "mpoint_label_text_properties"):  # [8104]
            self.overlay.mpoint_label_text_properties = deepcopy(
                self.overlay.default_text_properties
            )  # [8105]
        current_props = deepcopy(self.overlay.mpoint_label_text_properties)
        current_props["text"] = ""  # [8106]
        dialog = TextInputDialog(
            self, existing_properties=current_props, is_mpoint_label_style=True
        )  # [8107]
        if dialog.exec():  # [8108]
            new_props = dialog.get_properties()
            style_props = {k: v for k, v in new_props.items() if k != "text"}  # [8109]
            self.overlay.mpoint_label_text_properties = style_props
            print(f"MPoint label style updated: {style_props}")  # [8110]
            self.overlay.save_mpoint_label_style()  # [8111]
        else:
            print("MPoint label style configuration cancelled.")  # [8112]

    @Slot()  # [8113]
    def _update_angle_tool_settings_from_ui(self):  # [8114]
        if (
            not hasattr(self, "angle_tool_widget_group")
            or not self.angle_tool_widget_group
        ):
            return  # [8115]

        settings = {  # [8116]
            "color": self.overlay.current_angle_tool_line_color,  # [8117]
            "textSize": self.overlay.current_angle_tool_text_size,  # [8118]
            "showInner": self.angle_tool_inner_check.isChecked(),  # [8119]
            "showOuter": self.angle_tool_outer_check.isChecked(),  # [8120]
        }  # [8121]
        self.overlay.update_angle_tool_settings(settings)  # [8122]

    @Slot(dict)  # [8123]
    def update_angle_tool_controls_from_signal(self, settings):  # [8124]
        """Updates Angle tool UI controls based on a signal."""  # [8125]
        if (
            not hasattr(self, "angle_tool_widget_group")
            or not self.angle_tool_widget_group
        ):
            return  # [8126]

        self.angle_tool_color_button.blockSignals(True)  # [8127]
        self.update_angle_tool_color_button_style(
            settings.get("color", self.overlay.current_angle_tool_line_color)
        )  # [8128]
        self.angle_tool_color_button.blockSignals(False)  # [8129]

        self.angle_tool_inner_check.blockSignals(True)  # [8130]
        self.angle_tool_inner_check.setChecked(
            settings.get("showInner", self.overlay.current_angle_tool_show_inner)
        )  # [8131]
        self.angle_tool_inner_check.blockSignals(False)  # [8132]

        self.angle_tool_outer_check.blockSignals(True)  # [8133]
        self.angle_tool_outer_check.setChecked(
            settings.get("showOuter", self.overlay.current_angle_tool_show_outer)
        )  # [8134]
        self.angle_tool_outer_check.blockSignals(False)  # [8135]

    @Slot()  # [8136]
    def choose_angle_tool_color(self):  # [8137]
        if hasattr(self.overlay, "current_angle_tool_line_color"):  # [8138]
            initial_color = self.overlay.current_angle_tool_line_color  # [8139]
            color = QColorDialog.getColor(
                initial_color, self, "Choose Angle Tool Line & Default Text Color"
            )  # [8140]
            if color.isValid():  # [8141]
                settings_to_update = {  # [8142]
                    "color": color,  # [8143]
                    "textSize": self.overlay.current_angle_tool_text_size,  # [8144]
                    "showInner": self.overlay.current_angle_tool_show_inner,  # [8145]
                    "showOuter": self.overlay.current_angle_tool_show_outer,  # [8146]
                }  # [8147]
                self.overlay.update_angle_tool_settings(settings_to_update)  # [8148]
            else:  # [8149]
                print("Angle tool color selection cancelled.")  # [8150]
        else:  # [8151]
            print(
                "Error: overlay has no attribute 'current_angle_tool_line_color'."
            )  # [8152]

    @Slot()  # [8153]
    def configure_angle_text_style(self):  # [8154]
        current_props = {  # [8155]
            "font": "Arial",  # [8156]
            "size": self.overlay.current_angle_tool_text_size,  # [8157]
            "bold": False,  # [8158]
            "italic": False,  # [8159]
            "underline": False,  # [8160]
            "strikeout": False,  # [8161]
            "color": self.overlay.current_angle_tool_line_color.name(),  # [8162]
            "background_color": None,  # [8163]
            "alignment": "center",  # [8164]
            "curve_angle": 0,  # [8165]
            "is_angle_display": True,  # [8166]
        }  # [8167]
        dialog = TextInputDialog(
            self, existing_properties=current_props, is_angle_text_style_edit=True
        )  # [8168]
        if dialog.exec():  # [8169]
            new_style_props = dialog.get_properties()  # [8170]
            new_color = QColor(
                new_style_props.get(
                    "color", self.overlay.current_angle_tool_line_color.name()
                )
            )  # [8171]
            new_size = new_style_props.get(
                "size", self.overlay.current_angle_tool_text_size
            )  # [8172]

            self.overlay.update_angle_tool_settings(
                {  # [8173]
                    "color": new_color,  # [8174]
                    "textSize": new_size,  # [8175]
                    "showInner": self.overlay.current_angle_tool_show_inner,  # [8176]
                    "showOuter": self.overlay.current_angle_tool_show_outer,  # [8177]
                }
            )  # [8178]
            self.update_angle_tool_color_button_style(new_color)  # [8179]
            print(
                f"Angle text style configured: Color={new_color.name()}, Size={new_size}"
            )  # [8180]
        else:  # [8181]
            print("Angle text style configuration cancelled.")  # [8182]

    @Slot()  # [8183]
    def _update_hatch_settings_from_ui(self):  # [8184]
        if not hasattr(self, "hatch_widget_group") or not self.hatch_widget_group:
            return  # [8185]

        style = []  # [8186]
        if self.hatch_forward_slash_check.isChecked():
            style.append("forward_slash")  # [8187]
        if self.hatch_backward_slash_check.isChecked():
            style.append("backward_slash")  # [8188]
        if self.hatch_horizontal_check.isChecked():
            style.append("horizontal")  # [8189]
        if self.hatch_vertical_check.isChecked():
            style.append("vertical")  # [8190]

        self.overlay.current_hatch_style = style  # [8191]
        self.overlay.current_hatch_thickness = (
            self.hatch_thickness_spin.value()
        )  # [8192]
        self.overlay.save_hatch_fill_settings()  # [8193]

        if self.overlay.selected_shapes:  # [8194]
            changed_shapes = []  # [8195]
            prev_props = {}  # [8196]
            current_indices = []  # [8197]
            for shape in self.overlay.selected_shapes:  # [8198]
                is_shape_fillable = (
                    shape.type
                    in [
                        "rect",
                        "ellipse",
                        "triangle",
                        "polygon",
                        "trapeze",
                        "regular_polygon",
                        "arc",
                    ]
                    or shape.is_mpoint_marker
                )  # [8199]
                if is_shape_fillable:  # [8200]
                    try:  # [8201]
                        idx = self.overlay.shapes.index(shape)  # [8202]
                        prev_props[idx] = deepcopy(shape)  # [8203]
                        if style:  # [8204]
                            shape.hatch_properties = {  # [8205]
                                "style": style,  # [8206]
                                "color": self.overlay.current_hatch_color,  # [8207]
                                "thickness": self.overlay.current_hatch_thickness,  # [8208]
                            }  # [8209]
                            # Removed: shape.filled = False # Disable standard fill if hatching is active # Added
                        else:  # [8210]
                            shape.hatch_properties = None  # [8211]
                        changed_shapes.append(shape)  # [8212]
                        current_indices.append(idx)  # [8213]
                    except ValueError:  # [8214]
                        continue  # [8215]
            if changed_shapes:  # [8216]
                self.overlay.save_state(
                    "toggle_hatch_fill",
                    shapes_involved=changed_shapes,
                    previous_geometries=prev_props,
                    indices=current_indices,
                )  # [8217]
                # self.overlay.update() # Removed, will be at the end

        # If hatching is enabled, uncheck 'Fill Shapes' checkbox
        # Removed block:
        # if style and self.fill_check.isChecked(): # [8218]
        #     self.fill_check.blockSignals(True)
        #     self.fill_check.setChecked(False)
        #     self.fill_check.blockSignals(False)

        self.overlay.update()  # Added

    def update_hatch_fill_controls(self):  # [8219]
        if not hasattr(self, "hatch_widget_group") or not self.hatch_widget_group:
            return  # [8220]

        style = self.overlay.current_hatch_style  # [8221]
        self.hatch_forward_slash_check.blockSignals(True)
        self.hatch_forward_slash_check.setChecked("forward_slash" in style)
        self.hatch_forward_slash_check.blockSignals(False)  # [8222]
        self.hatch_backward_slash_check.blockSignals(True)
        self.hatch_backward_slash_check.setChecked("backward_slash" in style)
        self.hatch_backward_slash_check.blockSignals(False)  # [8223]
        self.hatch_horizontal_check.blockSignals(True)
        self.hatch_horizontal_check.setChecked("horizontal" in style)
        self.hatch_horizontal_check.blockSignals(False)  # [8224]
        self.hatch_vertical_check.blockSignals(True)
        self.hatch_vertical_check.setChecked("vertical" in style)
        self.hatch_vertical_check.blockSignals(False)  # [8225]

        self.hatch_thickness_spin.blockSignals(True)
        self.hatch_thickness_spin.setValue(self.overlay.current_hatch_thickness)
        self.hatch_thickness_spin.blockSignals(False)  # [8226]
        self.update_hatch_fill_color_button_style(
            self.overlay.current_hatch_color
        )  # [8227]

    def hatch_fill_enabled(self):  # [8228]
        """Checks if any hatch style is enabled."""  # [8229]
        return bool(self.overlay.current_hatch_style)  # [8230]

    def get_hatch_style(self):  # [8231]
        """Returns a list of active hatch styles."""  # [8232]
        return self.overlay.current_hatch_style  # [8233]

    @Slot(str)  # [8234]
    def _update_line_point_arrow_style(self, style):  # [8235]
        """Updates the arrow style for the line_point and spline tools."""  # [8236]
        self.overlay.current_line_point_arrow_style = style  # [8237]
        self.overlay.line_point_arrow_style_changed.emit(style)  # [8238]
        if self.overlay.selected_shapes:  # [8239]
            changed_shapes = []  # [8240]
            prev_props = {}  # [8241]
            current_indices = []  # [8242]
            for shape in self.overlay.selected_shapes:  # [8243]
                if shape.type in ["line_point", "spline"]:  # [8244]
                    try:  # [8245]
                        idx = self.overlay.shapes.index(shape)  # [8246]
                        prev_props[idx] = deepcopy(shape)  # [8247]
                        shape.line_point_arrow_style = style  # [8248]
                        if style and shape.arrow_head_size is None:  # [8249]
                            shape.arrow_head_size = (
                                self.overlay.current_arrow_head_size
                            )  # [8250]
                        changed_shapes.append(shape)  # [8251]
                        current_indices.append(idx)  # [8252]
                    except ValueError:  # [8253]
                        continue  # [8254]
            if changed_shapes:  # [8255]
                self.overlay.save_state(
                    "change_line_style",
                    shapes_involved=changed_shapes,
                    previous_geometries=prev_props,
                    indices=current_indices,
                )  # [8256]
                self.overlay.update()  # [8257]

    @Slot(str)  # [8258]
    def update_line_point_arrow_style_controls(self, style):  # [8259]
        """Updates the UI controls for line_point/spline arrow style based on a signal."""  # [8260]
        is_line_point_tool = self.overlay.current_tool == "line_point"  # [8261]
        is_spline_tool = self.overlay.current_tool == "spline"  # [8262]

        if hasattr(self, "line_point_no_arrow_radio"):  # [8263]
            self.line_point_no_arrow_radio.blockSignals(True)  # [8264]
            self.line_point_1a_radio.blockSignals(True)  # [8265]
            self.line_point_2a_radio.blockSignals(True)  # [8266]
            if is_line_point_tool:  # [8267]
                if style is None:
                    self.line_point_no_arrow_radio.setChecked(True)  # [8268]
                elif style == "1a":
                    self.line_point_1a_radio.setChecked(True)  # [8269]
                elif style == "2a":
                    self.line_point_2a_radio.setChecked(True)  # [8270]
            self.line_point_no_arrow_radio.blockSignals(False)  # [8271]
            self.line_point_1a_radio.blockSignals(False)  # [8272]
            self.line_point_2a_radio.blockSignals(False)  # [8273]

        if hasattr(self, "line_point_no_arrow_radio_spline"):  # [8274]
            self.line_point_no_arrow_radio_spline.blockSignals(True)  # [8275]
            self.line_point_1a_radio_spline.blockSignals(True)  # [8276]
            self.line_point_2a_radio_spline.blockSignals(True)  # [8277]
            if is_spline_tool:  # [8278]
                if style is None:
                    self.line_point_no_arrow_radio_spline.setChecked(True)  # [8279]
                elif style == "1a":
                    self.line_point_1a_radio_spline.setChecked(True)  # [8280]
                elif style == "2a":
                    self.line_point_2a_radio_spline.setChecked(True)  # [8281]
            self.line_point_no_arrow_radio_spline.blockSignals(False)  # [8282]
            self.line_point_1a_radio_spline.blockSignals(False)  # [8283]
            self.line_point_2a_radio_spline.blockSignals(False)  # [8284]

    @Slot()  # [8285]
    def start_animation_setup(self):  # [8286]
        if self._animation_running:
            QMessageBox.warning(
                self,
                "Animation Running",
                "Animation is already running. Stop it first (Esc).",
            )
            return  # [8287]
        last_dir = self.settings.value(
            "paths/lastAnimDir",
            QStandardPaths.writableLocation(
                QStandardPaths.StandardLocation.DocumentsLocation
            ),
        )  # [8288]
        filenames, _ = QFileDialog.getOpenFileNames(
            self, "Select Scene Files for Animation", last_dir, "JSON Files (*.json)"
        )  # [8289]
        if not filenames:
            print("Animation setup cancelled: No files selected.")
            return  # [8290]
        self.settings.setValue(
            "paths/lastAnimDir", os.path.dirname(filenames[0])
        )  # [8291]
        print(f"Selected {len(filenames)} scene(s) for animation.")  # [8292]
        try:  # [8293]
            dialog = AnimationConfigDialog(filenames, self)  # [8294]
            if dialog.exec():  # [8295]
                self._animation_params = dialog.get_parameters()
                self._animation_scenes = dialog.get_scene_data()  # [8296]
                print("Animation parameters configured:")
                [
                    print(f"  - {key}: {value}")
                    for key, value in self._animation_params.items()
                ]  # [8297]
                QTimer.singleShot(50, self.start_animation_playback)  # [8298]
            else:
                self.clear_all_previewed_animation_scenes()
                print("Animation configuration cancelled.")  # [8299]
        except NameError:
            QMessageBox.critical(
                self, "Error", "AnimationConfigDialog class not defined yet."
            )  # [8300]
        except Exception as e:
            QMessageBox.critical(
                self, "Animation Setup Error", f"An error occurred during setup:\n{e}"
            )
            traceback.print_exc()  # [8301]

    def start_animation_playback(self):  # [8302]
        if not self._animation_scenes:  # [8303]
            QMessageBox.warning(
                self, "Animation Error", "No scenes selected for animation."
            )  # [8304]
            return  # [8305]
        self.clear_all_previewed_animation_scenes()  # [8306]
        print("Starting animation playback...")  # [8307]
        self._animation_running = True  # [8308]
        self._animation_paused = False  # [8309]
        self._animation_current_index = -1  # [8310]
        self._animation_direction = 1  # [8311]
        self._pingpong_returning = False  # [8312]

        for (
            timer_start,
            timer_clear,
            _,
            _,
        ) in self._animation_individual_scene_timers:  # [8313]
            timer_start.stop()  # [8314]
            timer_clear.stop()  # [8315]
            timer_start.deleteLater()  # [8316]
            timer_clear.deleteLater()  # [8317]
        self._animation_individual_scene_timers = []  # [8318]

        if (
            self._animation_params["play_back"]
            or self._animation_params["pingpong_back"]
        ):  # [8319]
            self._animation_current_index = len(self._animation_scenes)  # [8320]
            self._animation_direction = -1  # [8321]

        self._animation_was_indicator_shown = self.overlay.show_tool_text  # [8322]
        self.overlay.set_show_tool_text(False)  # [8323]
        self.hide()  # [8324]

        if hasattr(self.overlay, "main_app_parent") and hasattr(
            self.overlay.main_app_parent, "set_animation_active_status"
        ):  # [8325]
            self.overlay.main_app_parent.set_animation_active_status(True)  # [8326]
            print("Informed MainApplication: Animation ACTIVE")  # [8327]
        else:  # [8328]
            print(
                "Warning: Could not inform MainApplication about animation status."
            )  # [8329]

        start_delay_ms = int(self._animation_params["start_delay"] * 1000)  # [8330]
        print(f"Waiting for start delay: {start_delay_ms} ms")  # [8331]

        if self._animation_params.get("time_mode_auto", True):  # [8332]
            self._animation_timer_step.start(start_delay_ms)  # [8333]
        else:  # [8334]
            for i, scene_data in enumerate(self._animation_scenes):  # [8335]
                if (
                    scene_data.get("include_in_animation", True)
                    and scene_data.get("individual_start_time", 0.0) > 0
                ):  # [8336]
                    individual_start_delay_ms = (
                        int(scene_data["individual_start_time"] * 1000) + start_delay_ms
                    )  # [8337]
                    tag = f"anim_scene_ind_{i}_{uuid.uuid4().hex[:8]}"  # [8338]
                    print(
                        f"  Scheduling individual scene '{os.path.basename(scene_data['filepath'])}' in {individual_start_delay_ms}ms (tag: {tag})"
                    )  # [8339]

                    start_timer = QTimer(self)  # [8340]
                    start_timer.setSingleShot(True)  # [8341]
                    start_timer.setProperty("scene_data", scene_data)  # [8342]
                    start_timer.setProperty("animation_tag", tag)  # [8343]
                    start_timer.setProperty("scene_index", i)  # [8344]
                    start_timer.timeout.connect(
                        self._animation_load_individual_scene
                    )  # [8345]
                    start_timer.start(individual_start_delay_ms)  # [8346]

                    clear_timer = QTimer(self)  # [8347]
                    clear_timer.setSingleShot(True)  # [8348]
                    clear_timer.setProperty("animation_tag_to_clear", tag)  # [8349]
                    clear_timer.setProperty(
                        "clear_after_flag", scene_data.get("clear_after", False)
                    )  # [8350]
                    clear_timer.timeout.connect(
                        self._animation_clear_individual_scene
                    )  # [8351]

                    self._animation_individual_scene_timers.append(
                        (
                            start_timer,
                            clear_timer,
                            tag,
                            scene_data.get("clear_after", False),
                        )
                    )  # [8352]

            QTimer.singleShot(
                start_delay_ms, self._animation_step_manual_mode
            )  # [8353]

    def _animation_load_individual_scene(self):  # [8354]
        """Loads a single scene with an individual start time."""  # [8355]
        if not self._animation_running or self._animation_paused:  # [8356]
            return  # [8357]

        start_timer = self.sender()  # [8358]
        if not start_timer:
            return  # [8359]

        scene_data = start_timer.property("scene_data")  # [8360]
        animation_tag = start_timer.property("animation_tag")  # [8361]
        scene_idx = start_timer.property("scene_index")  # [8362]

        print(
            f"Animation: Loading individual scene {scene_idx + 1} ('{os.path.basename(scene_data['filepath'])}', tag: {animation_tag})"
        )  # [8363]
        target_mode = self._animation_params["mode"]  # [8364]
        if not self.overlay.isVisible():
            self.overlay.show()  # [8365]

        if target_mode == "EDIT" and not self.overlay.edit_mode:  # [8366]
            if self.overlay.board_mode:
                self.overlay.exit_board_mode(configure=False)  # [8367]
            self.overlay.enter_edit_mode()  # [8368]
        elif target_mode == "BOARD" and not self.overlay.board_mode:  # [8369]
            if self.overlay.edit_mode:
                self.overlay.exit_board_mode(configure=False)  # [8370]
            self.overlay.enter_board_mode()  # [8371]
        elif not self.overlay.drawing_mode:  # [8372]
            self.overlay.set_drawing_mode(True)  # [8373]

        self.overlay.load_scene(
            scene_data["filepath"], join=True, animation_tag=animation_tag
        )  # [8374]
        QApplication.processEvents()  # [8375]

        display_time = (
            scene_data["display_time"]
            if scene_data["display_time"] > 0
            else self._animation_params["default_time"]
        )  # [8376]
        display_time_ms = int(display_time * 1000)  # [8377]

        clear_timer_for_scene = None  # [8378]
        for st, ct, tag, caf in self._animation_individual_scene_timers:  # [8379]
            if tag == animation_tag:  # [8380]
                clear_timer_for_scene = ct  # [8381]
                break  # [8382]

        if clear_timer_for_scene:  # [8383]
            clear_timer_for_scene.start(display_time_ms)  # [8384]
        else:  # [8385]
            print(
                f"Error: Could not find clear timer for individual scene tag {animation_tag}"
            )  # [8386]

    def _animation_clear_individual_scene(self):  # [8387]
        """Clears shapes for a single scene with individual timing."""  # [8388]
        if not self._animation_running or self._animation_paused:  # [8389]
            return  # [8390]

        clear_timer = self.sender()  # [8391]
        if not clear_timer:
            return  # [8392]

        tag_to_clear = clear_timer.property("animation_tag_to_clear")  # [8393]
        clear_after_this_scene = clear_timer.property("clear_after_flag")  # [8394]

        if clear_after_this_scene:  # [8395]
            if tag_to_clear:  # [8396]
                print(
                    f"Animation: Clearing individual scene shapes with tag '{tag_to_clear}'"
                )  # [8397]
                self.overlay.remove_shapes_by_animation_tag(tag_to_clear)  # [8398]
                QApplication.processEvents()  # [8399]

        for i, (st, ct, tag, _) in enumerate(
            self._animation_individual_scene_timers
        ):  # [8400]
            if tag == tag_to_clear:  # [8401]
                st.deleteLater()  # [8402]
                ct.deleteLater()  # [8403]
                del self._animation_individual_scene_timers[i]  # [8404]
                break  # [8405]

    def _animation_step_manual_mode(self):  # [8406]
        """Handles sequential animation step in manual mode (only scenes with start time = 0)."""  # [8407]
        if not self._animation_running or self._animation_paused:  # [8408]
            print(
                "_animation_step_manual_mode called but animation not running or paused."
            )  # [8409]
            return  # [8410]

        scene_count = len(self._animation_scenes)  # [8411]
        is_finished_sequential = False  # [8412]
        next_sequential_index = -1  # [8413]

        current_search_idx = self._animation_current_index  # [8414]

        while True:  # [8415]
            current_search_idx += self._animation_direction  # [8416]
            if self._animation_direction == 1:  # [8417]
                if current_search_idx >= scene_count:  # [8418]
                    if (
                        self._animation_params["pingpong_front"]
                        and not self._pingpong_returning
                    ):  # [8419]
                        if scene_count > 1:  # [8420]
                            self._animation_direction = -1  # [8421]
                            current_search_idx = scene_count - 2  # [8422]
                            self._pingpong_returning = True  # [8423]
                        else:  # [8424]
                            is_finished_sequential = not self._animation_params[
                                "loop"
                            ]  # [8425]
                            current_search_idx = (
                                0 if self._animation_params["loop"] else -1
                            )  # [8426]
                    elif (
                        self._animation_params["pingpong_back"]
                        and self._pingpong_returning
                    ):  # [8427]
                        is_finished_sequential = not self._animation_params[
                            "loop"
                        ]  # [8428]
                        if self._animation_params["loop"]:  # [8429]
                            self._animation_direction = -1
                            current_search_idx = scene_count - 1
                            self._pingpong_returning = False  # [8430]
                        else:
                            current_search_idx = -1  # [8431]
                    elif self._animation_params["loop"]:  # [8432]
                        current_search_idx = 0  # [8433]
                    else:  # [8434]
                        is_finished_sequential = True  # [8435]
                    break  # [8436]
                if (
                    0 <= current_search_idx < scene_count
                    and self._animation_scenes[current_search_idx].get(
                        "individual_start_time", 0.0
                    )
                    == 0.0
                    and self._animation_scenes[current_search_idx].get(
                        "include_in_animation", True
                    )
                ):  # [8437]
                    next_sequential_index = current_search_idx  # [8438]
                    break  # [8439]
            elif self._animation_direction == -1:  # [8440]
                if current_search_idx < 0:  # [8441]
                    if (
                        self._animation_params["pingpong_back"]
                        and not self._pingpong_returning
                    ):  # [8442]
                        if scene_count > 1:  # [8443]
                            self._animation_direction = 1  # [8444]
                            current_search_idx = 1  # [8445]
                            self._pingpong_returning = True  # [8446]
                        else:  # [8447]
                            is_finished_sequential = not self._animation_params[
                                "loop"
                            ]  # [8448]
                            current_search_idx = (
                                scene_count - 1
                                if self._animation_params["loop"] and scene_count > 0
                                else -1
                            )  # [8449]
                    elif (
                        self._animation_params["pingpong_front"]
                        and self._pingpong_returning
                    ):  # [8450]
                        is_finished_sequential = not self._animation_params[
                            "loop"
                        ]  # [8451]
                        if self._animation_params["loop"]:  # [8452]
                            self._animation_direction = 1
                            current_search_idx = 0
                            self._pingpong_returning = False  # [8453]
                        else:
                            current_search_idx = -1  # [8454]
                    elif self._animation_params["loop"]:  # [8455]
                        current_search_idx = scene_count - 1  # [8456]
                    else:  # [8457]
                        is_finished_sequential = True  # [8458]
                    break  # [8459]
                if (
                    0 <= current_search_idx < scene_count
                    and self._animation_scenes[current_search_idx].get(
                        "individual_start_time", 0.0
                    )
                    == 0.0
                    and self._animation_scenes[current_search_idx].get(
                        "include_in_animation", True
                    )
                ):  # [8460]
                    next_sequential_index = current_search_idx  # [8461]
                    break  # [8462]
            if self._animation_direction == 0:
                break  # [8463]

        if is_finished_sequential or next_sequential_index == -1:  # [8464]
            if not self._animation_individual_scene_timers:  # [8465]
                print("Animation sequence (manual mode) finished.")  # [8466]
                self.stop_animation_playback(triggered_by_escape=False)  # [8467]
            return  # [8468]

        self._animation_current_index = next_sequential_index  # [8469]
        current_scene_data = self._animation_scenes[
            self._animation_current_index
        ]  # [8470]
        scene_path = current_scene_data["filepath"]  # [8471]

        print(
            f"Animation step (manual seq): Loading scene {self._animation_current_index + 1}/{scene_count} ('{os.path.basename(scene_path)}')"
        )  # [8472]
        target_mode = self._animation_params["mode"]  # [8473]
        if not self.overlay.isVisible():
            self.overlay.show()  # [8474]

        if target_mode == "EDIT" and not self.overlay.edit_mode:  # [8475]
            if self.overlay.board_mode:
                self.overlay.exit_board_mode(configure=False)  # [8476]
            self.overlay.enter_edit_mode()  # [8477]
        elif target_mode == "BOARD" and not self.overlay.board_mode:  # [8478]
            if self.overlay.edit_mode:
                self.overlay.exit_board_mode(configure=False)  # [8479]
            self.overlay.enter_board_mode()  # [8480]
        elif not self.overlay.drawing_mode:
            self.overlay.set_drawing_mode(True)  # [8481]

        current_animation_tag = f"anim_scene_seq_{self._animation_current_index}_{uuid.uuid4().hex[:8]}"  # [8482]
        self.overlay.load_scene(
            scene_path, join=True, animation_tag=current_animation_tag
        )  # [8483]
        QApplication.processEvents()  # [8484]

        display_time = (
            current_scene_data["display_time"]
            if current_scene_data["display_time"] > 0
            else self._animation_params["default_time"]
        )  # [8485]
        display_time_ms = int(display_time * 1000)  # [8486]

        self._animation_timer_clear.setProperty(
            "animation_tag_to_clear", current_animation_tag
        )  # [8487]
        self._animation_timer_clear.setProperty(
            "clear_after_flag", current_scene_data.get("clear_after", False)
        )  # [8488]
        self._animation_timer_clear.setProperty("is_manual_sequential", True)  # [8489]
        self._animation_timer_clear.start(display_time_ms)  # [8490]

    def _animation_step(self):  # [8491]
        if not self._animation_running or self._animation_paused:  # [8492]
            print(
                f"_animation_step called but animation not running or paused ({self._animation_running=}, {self._animation_paused=})"
            )  # [8493]
            return  # [8494]

        scene_count = len(self._animation_scenes)  # [8495]
        if scene_count == 0:  # [8496]
            self.stop_animation_playback(triggered_by_escape=False)  # [8497]
            return  # [8498]

        next_index = self._animation_current_index + self._animation_direction  # [8499]
        loop = self._animation_params["loop"]  # [8500]
        pingpong_front = self._animation_params["pingpong_front"]  # [8501]
        pingpong_back = self._animation_params["pingpong_back"]  # [8502]
        is_finished = False  # [8503]

        if self._animation_direction == 1:  # [8504]
            if next_index >= scene_count:  # [8505]
                if pingpong_front and not self._pingpong_returning:  # [8506]
                    if scene_count > 1:  # [8507]
                        self._animation_direction = -1  # [8508]
                        next_index = scene_count - 2  # [8509]
                        self._pingpong_returning = True  # [8510]
                    else:  # [8511]
                        is_finished = not loop  # [8512]
                        next_index = 0 if loop else -1  # [8513]
                elif pingpong_back and self._pingpong_returning:  # [8514]
                    if loop:  # [8515]
                        self._animation_direction = -1  # [8516]
                        next_index = scene_count - 1  # [8517]
                        self._pingpong_returning = False  # [8518]
                    else:  # [8519]
                        is_finished = True  # [8520]
                elif loop:  # [8521]
                    next_index = 0  # [8522]
                else:  # [8523]
                    is_finished = True  # [8524]
        elif self._animation_direction == -1:  # [8525]
            if next_index < 0:  # [8526]
                if pingpong_back and not self._pingpong_returning:  # [8527]
                    if scene_count > 1:  # [8528]
                        self._animation_direction = 1  # [8529]
                        next_index = 1  # [8530]
                        self._pingpong_returning = True  # [8531]
                    else:  # [8532]
                        is_finished = not loop  # [8533]
                        next_index = (
                            scene_count - 1 if loop and scene_count > 0 else -1
                        )  # [8534]
                elif pingpong_front and self._pingpong_returning:  # [8535]
                    if loop:  # [8536]
                        self._animation_direction = 1  # [8537]
                        next_index = 0  # [8538]
                        self._pingpong_returning = False  # [8539]
                    else:  # [8540]
                        is_finished = True  # [8541]
                elif loop:  # [8542]
                    next_index = scene_count - 1  # [8543]
                else:  # [8544]
                    is_finished = True  # [8545]

        if not is_finished:  # [8546]
            self._animation_current_index = next_index  # [8547]
            try:  # [8548]
                if not (0 <= self._animation_current_index < scene_count):  # [8549]
                    is_finished = True  # [8550]
                else:  # [8551]
                    current_scene_data = self._animation_scenes[
                        self._animation_current_index
                    ]  # [8552]
                    scene_path = current_scene_data["filepath"]  # [8553]

                    if not current_scene_data.get(
                        "include_in_animation", True
                    ):  # [8554]
                        print(
                            f"Animation step: Skipping scene (not included) {self._animation_current_index + 1}/{scene_count} ('{os.path.basename(scene_path)}')"
                        )  # [8555]
                        interval_ms = (
                            self._animation_params["interval"] * 1000
                        )  # [8556]
                        if not self._animation_params.get(
                            "time_mode_auto", True
                        ) and current_scene_data.get(
                            "use_between_time", False
                        ):  # [8557]
                            interval_ms = int(
                                current_scene_data.get(
                                    "between_time", self._animation_params["interval"]
                                )
                                * 1000
                            )  # [8558]
                        self._animation_timer_step.start(max(1, int(interval_ms)))
                        return  # [8559]

                    print(
                        f"Animation step: Loading scene {self._animation_current_index + 1}/{scene_count} ('{os.path.basename(scene_path)}')"
                    )  # [8560]
                    target_mode = self._animation_params["mode"]  # [8561]
                    if not self.overlay.isVisible():
                        self.overlay.show()  # [8562]

                    if target_mode == "EDIT" and not self.overlay.edit_mode:  # [8563]
                        if self.overlay.board_mode:
                            self.overlay.exit_board_mode(configure=False)  # [8564]
                        self.overlay.enter_edit_mode()  # [8565]
                    elif (
                        target_mode == "BOARD" and not self.overlay.board_mode
                    ):  # [8566]
                        if self.overlay.edit_mode:
                            self.overlay.exit_board_mode(configure=False)  # [8567]
                        self.overlay.enter_board_mode()  # [8568]
                    elif not self.overlay.drawing_mode:
                        self.overlay.set_drawing_mode(True)  # [8569]

                    current_animation_tag = f"anim_scene_{self._animation_current_index}_{uuid.uuid4().hex[:8]}"  # [8570]
                    self.overlay.load_scene(
                        scene_path, join=True, animation_tag=current_animation_tag
                    )  # [8571]
                    QApplication.processEvents()  # [8572]

                    display_time = self._animation_params["default_time"]  # [8573]
                    if not self._animation_params.get("time_mode_auto", True):  # [8574]
                        display_time = (
                            current_scene_data["display_time"]
                            if current_scene_data["display_time"] > 0
                            else self._animation_params["default_time"]
                        )  # [8575]

                    display_time_ms = int(display_time * 1000)  # [8576]
                    self._animation_timer_clear.setProperty(
                        "animation_tag_to_clear", current_animation_tag
                    )  # [8577]
                    self._animation_timer_clear.setProperty(
                        "clear_after_flag", current_scene_data.get("clear_after", False)
                    )  # [8578]
                    self._animation_timer_clear.setProperty(
                        "is_manual_sequential", False
                    )  # [8579]
                    self._animation_timer_clear.start(display_time_ms)  # [8580]
            except Exception as e:  # [8581]
                print(f"Error during animation step: {e}")
                traceback.print_exc()
                is_finished = True  # [8582]

        if is_finished:  # [8583]
            print("Animation sequence finished.")  # [8584]
            self.stop_animation_playback(triggered_by_escape=False)  # [8585]

    def _animation_clear_and_schedule_next(self):  # [8586]
        if not self._animation_running or self._animation_paused:
            return  # [8587]

        tag_to_clear = self._animation_timer_clear.property(
            "animation_tag_to_clear"
        )  # [8588]
        clear_after_this_scene = self._animation_timer_clear.property(
            "clear_after_flag"
        )  # [8589]
        is_manual_seq_step = self._animation_timer_clear.property(
            "is_manual_sequential"
        )  # [8590]

        if clear_after_this_scene:  # [8591]
            if tag_to_clear:  # [8592]
                print(
                    f"Animation: Clearing shapes with tag '{tag_to_clear}' (Clr?={clear_after_this_scene})"
                )  # [8593]
                self.overlay.remove_shapes_by_animation_tag(tag_to_clear)  # [8594]
                QApplication.processEvents()  # [8595]

        if (
            self._animation_params.get("time_mode_auto", True) or is_manual_seq_step
        ):  # [8596]
            current_scene_data = self._animation_scenes[
                self._animation_current_index
            ]  # [8597]
            interval_ms = self._animation_params["interval"] * 1000  # [8598]
            if not self._animation_params.get("time_mode_auto", True):  # [8599]
                if current_scene_data.get("use_between_time", False):  # [8600]
                    interval_ms = (
                        current_scene_data.get(
                            "between_time", self._animation_params["interval"]
                        )
                        * 1000
                    )  # [8601]

            interval_ms = int(max(1, interval_ms))  # [8602]

            if is_manual_seq_step:  # [8603]
                self._animation_step_manual_mode()  # [8604]
            else:  # [8605]
                self._animation_timer_step.start(interval_ms)  # [8606]

    @Slot()  # [8607]
    def _remove_persisted_shapes(self):  # [8608]
        sender_timer = self.sender()  # [8609]
        if sender_timer:  # [8610]
            tag_to_remove = sender_timer.property("animation_tag_to_remove")  # [8611]
            if tag_to_remove:  # [8612]
                print(
                    f"Animation: Persistence time ended. Removing shapes with tag '{tag_to_remove}'."
                )  # [8613]
                self.overlay.remove_shapes_by_animation_tag(tag_to_remove)  # [8614]
                self.overlay.update()  # [8615]
            sender_timer.deleteLater()  # [8616]

    def stop_animation_playback(self, triggered_by_escape=False):  # [8617]
        if not self._animation_running:
            return  # [8618]
        print(
            f"Stopping animation playback (Triggered by Escape: {triggered_by_escape})"
        )  # [8619]
        was_running = self._animation_running  # [8620]
        if (
            hasattr(self.overlay, "main_app_parent")
            and hasattr(self.overlay.main_app_parent, "set_animation_active_status")
            and was_running
        ):  # [8621]
            self.overlay.main_app_parent.set_animation_active_status(False)
            print("Informed MainApplication: Animation INACTIVE")  # [8622]
        self._animation_running = False
        self._animation_paused = False
        self._pingpong_returning = False  # [8623]
        self._animation_timer_step.stop()
        self._animation_timer_clear.stop()  # [8624]

        for (
            timer_start,
            timer_clear,
            _,
            _,
        ) in self._animation_individual_scene_timers:  # [8625]
            timer_start.stop()
            timer_start.deleteLater()  # [8626]
            timer_clear.stop()
            timer_clear.deleteLater()  # [8627]
        self._animation_individual_scene_timers = []  # [8628]

        if triggered_by_escape:  # [8629]
            print("Clearing last scene due to Esc.")  # [8630]
            self.overlay.clear_scene(save_undo=False)  # [8631]

        if self.overlay.edit_mode or self.overlay.board_mode:  # [8632]
            print("Exiting Board/Edit mode after animation stop.")  # [8633]
            self.overlay.exit_board_mode(ask_save=False, configure=True)  # [8634]
        elif self.overlay.drawing_mode:  # [8635]
            print("Exiting Drawing mode after animation stop.")  # [8636]
            self.overlay.set_drawing_mode(False)  # [8637]

        self.overlay.set_show_tool_text(self._animation_was_indicator_shown)  # [8638]
        self.show()
        self.activateWindow()  # [8639]


class ShortcutsWindow(QDialog):  # [8640]
    def __init__(self, parent=None, settings=None):  # [8641]
        super().__init__(parent)  # [8642]
        self.settings = settings
        self._first_show = True
        self.setWindowTitle("Shortcuts")  # [8643]
        self.setWindowFlags(
            Qt.WindowType.Window
            | Qt.WindowType.CustomizeWindowHint
            | Qt.WindowType.WindowTitleHint
            | Qt.WindowType.WindowMinimizeButtonHint
            | Qt.WindowType.WindowCloseButtonHint
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.Tool
        )  # [8644]
        layout = QVBoxLayout(self)
        layout.setSpacing(4)
        layout.setContentsMargins(8, 8, 8, 8)  # [8645]
        self.shortcuts_data = {  # [8646]
            "General": [  # [8647]
                ("Ctrl+\\", "Toggle Drawing Mode (Global Hotkey)"),  # [8648]
                ("Ctrl+Alt+\\ (RAlt+\\)", "Enter EDIT Mode (Global Hotkey)"),  # [8649]
                ("Alt+\\", "Enter BOARD Mode (Global Hotkey)"),  # [8650]
                ("Alt+Shift+\\", "Enter TEMP Mode (Global Hotkey)"),  # [8651]
                (
                    "Esc",
                    "Deselect All / Cancel Draw/Action / Hide Angle Offset / Exit Normal Draw / Exit loadimg EDIT (Confirm Action)",
                ),  # [8652]
                ("Esc (in TEMP)", "Exit TEMP Mode"),  # [8653]
                (
                    "Esc (x2 in BOARD/EDIT)",
                    "Exit BOARD/EDIT mode (Confirm Clear if 'Clear W.' checked)",
                ),  # [8654]
                ("Esc (during ANIM)", "Stop Animation"),  # [8655]
                ("Spacebar (during ANIM)", "Pause/Resume Animation"),  # [8656]
                ("Ctrl+Home", "Toggle Control Panel Visibility"),  # [8657]
                ("Ctrl+K", "Toggle This Shortcuts Window"),  # [8658]
                ("H", "Toggle Visibility of All Shapes"),  # [8659]
                ("Shift+H", "Toggle Visibility of MPoint Labels"),  # [8660]
                ("Ctrl+H", "Toggle Visibility of MPoint Markers"),  # [8661]
                ("Alt+H", "Toggle Visibility of MPoint Labels & Markers"),  # [8662]
                ("C", "Toggle Show Center Point (if enabled in panel)"),  # [8663]
                ("V", "Toggle Divide Shapes Mode"),  # [8664]
                ("Alt+Shift+Home", "Toggle Guide Lines Visibility"),  # [8665]
                ("Ctrl+Alt+F10", "Toggle Grid Visibility"),  # [8666]
                ("Alt+Shift+F1", "Toggle Snap to Lines Mode"),  # [8667]
                ("Alt+Shift+F2", "Toggle Snap to Grid Mode"),  # [8668]
                ("Alt+Shift+F3", "Toggle Snap to All Shapes Mode"),  # [8669]
                ("Alt+Shift+F4", "Turn Snap OFF"),  # New hotkey # [8670]
            ],  # [8671]
            "Tools": [  # [8672]
                ("A", "Arrow Tool"),  # [8673] # Change 2
                ("U", "Arc"),  # [8674]
                (">", "Angle Tool (I=IN, O=OUT)"),  # [8675]
                ("B", "Brush"),  # [8676]
                (
                    "Q",
                    "Dimension Tool (3 clicks, Esc/RMB=cancel, Shift+C=Clear ALL shapes)",
                ),  # [8677]
                ("E", "Ellipse"),  # [8678]
                ("M", "Line Point Tool"),  # [8679]
                ("L", "Line Single"),  # [8680]
                ("O", "M.Point Tool"),  # [8681]
                (
                    "P",
                    "Polygon (LMB=add, RMB/DblClk/Near Start=finish, Esc=cancel)",
                ),  # [8682]
                ("R", "Rectangle (U=Toggle Rounded)"),  # [8683]
                ("W", "Regular Polygon"),  # [8684]
                ("S", "Spline Tool"),  # [8685]
                (
                    "X",
                    "Text (Click/Drag = start pos/rect, Set Curve in Dialog)",
                ),  # [8686]
                ("Z", "Trapeze"),  # [8687]
                ("T", "Triangle"),  # [8688]
            ],  # [8689]
            "Tool Modifiers (While tool is active)": [  # [8690]
                ("Line Point: Ctrl+LMB", "Snap line to 15° increments"),  # [8691]
                ("Line Point: Alt+N", "No Arrows"),  # [8692]
                ("Line Point: Alt+E", "Arrow at End"),  # [8693]
                ("Line Point: Alt+D", "Arrows at Both Ends"),  # [8694]
                (
                    "Line Point: I",
                    "Invert Lasso Selection (when Ctrl is held)",
                ),  # [8695]
                ("Spline: Alt+N", "No Arrows"),  # [8696]
                ("Spline: Alt+E", "Arrow at End"),  # [8697]
                ("Spline: Alt+D", "Arrows at Both Ends"),  # [8698]
                ("Arrow: Alt+D", "Toggle Double-Headed Arrow"),  # [8699]
                ("MPoint: Alt+O", "Toggle Circle Marker Style"),  # [8700]
                ("MPoint: Alt+S", "Toggle Square Marker Style"),  # [8701]
                ("MPoint: T", "Toggle Label Visibility"),  # [8702]
                ("Angle: I", "Toggle Show Inner Angle"),  # [8703]
                ("Angle: O", "Toggle Show Outer Angle"),  # [8704]
                (
                    "Rectangle: U",
                    "Toggle Rounded Corners (for next fixed-size or drawn shape)",
                ),  # [8705]
            ],  # [8706]
            "File & Scene": [  # [8707]
                ("Ctrl+S", "Save Scene"),  # [8708]
                ("Ctrl+L", "Load Scene (Replace)"),  # [8709]
                ("Ctrl+Shift+L", "Load & Join Scene(s)"),  # [8710]
                ("ANIM Button", "Setup/Run Scene Animation"),  # [8711]
                ("LoadIMG Button", "Load Background Image (Enters EDIT)"),  # [8712]
                ("Shift+C", "Clear ALL Shapes (LoadIMG mode: Keep BG)"),  # [8713]
                ("EDIT Button / RAlt+\\", "Enter Edit Mode (Transparent BG)"),  # [8714]
                ("BOARD Button / Alt+\\", "Enter Whiteboard Mode"),  # [8715]
                (
                    "TEMP Button / Alt+Shift+\\",
                    "Enter Temporary Drawing Mode",
                ),  # [8716]
                ("Shift+PrtSc", "Save Screenshot (JPG/PNG) (Global Hotkey)"),  # [8717]
            ],  # [8718]
            "Edit & Undo": [  # [8719]
                ("Ctrl+Z", "Undo"),  # [8720]
                ("Ctrl+Y / Ctrl+Shift+Z", "Redo"),  # [8721]
                ("Ctrl+C", "Copy Selected (incl. groups)"),  # [8722]
                ("Ctrl+V", "Paste at Cursor (incl. groups)"),  # [8723]
                ("Ctrl+G", "Group Selected Shapes"),  # [8724]
                ("Ctrl+Shift+G", "Ungroup Selected Shapes"),  # [8725]
                (
                    "Delete / Backspace",
                    "Delete Selected (incl. groups/parts)",
                ),  # [8726]
                (
                    "Numpad '.' / Numpad Del",
                    "Open Color Picker for Selected Shape(s)",
                ),  # [8727]
                ("Numpad *", "Open Color Picker for Selected Shape(s)"),  # [8728]
                (
                    "Ctrl+Double-Click Shape",
                    "Delete Shape (NON-GROUPED, non-Text)",
                ),  # [8729]
                (
                    "Double-Click Text Shape",
                    "Edit Text Properties (Curve, Dim Suffix, Angle Format)",
                ),  # [8730]
                ("Y", "Send Selected Shape(s) to Back"),  # [8731]
            ],  # [8732]
            "Selection & Manipulation": [  # [8733]
                (
                    "Ctrl+LMB Click",
                    "Add/Remove from Selection (incl. groups / Dim/Angle Parts)",
                ),  # [8734]
                (
                    "LMB Click",
                    "Start Draw / Place Fixed Shape / Place MPoint / Add Poly/Line/Dim/Angle Point / Select Dim/Angle Part",
                ),  # [8735]
                (
                    "LMB Click (on selected)",
                    "Start Dragging Selected Shape(s) (incl. groups/Dim/Angle Parts)",
                ),  # [8736]
                ("Ctrl+A", "Select All Visible Shapes"),  # [8737]
                (
                    "LMB Drag",
                    "Draw / Move Selected (incl. groups/Dim/Angle Parts) / Resize (on handle)",
                ),  # [8738]
                (
                    "RMB Click",
                    "Clear Selection / Finish Poly/Line Point / Cancel Lasso / Cancel Dimension/Angle",
                ),  # [8739]
                ("Arrow Keys", "Nudge Selected (1px)"),  # [8740]
                ("Shift+Arrow Keys", "Nudge Selected (10px)"),  # [8741]
                ("+ / =", "Scale Up Selected"),  # [8742]
                ("Shift + + / =", "Scale Up (Larger)"),  # [8743]
                ("-", "Scale Down Selected"),  # [8744]
                ("Shift + -", "Scale Down (Larger)"),  # [8745]
                ("Ctrl+Left/Right", "Rotate Selected (90°)"),  # [8746]
                (
                    "Alt+Left/Right",
                    "Rotate Selected (0.1°/1°) (Shows Angles)",
                ),  # [8747]
                (
                    "Ctrl+Drag (Draw Line/Arrow/LinePoint)",
                    "Constrain Line Angle (15° increments)",
                ),  # [8748]
                ("Shift+Drag (Draw Rect/Ellipse)", "Maintain Aspect Ratio"),  # [8749]
                ("Numpad /", "Toggle Fill for Selected Fillable Shape(s)"),  # [8750]
                (
                    "Alt+J",
                    "Toggle Angle Deviation Display for Selected Lines/Arrows",
                ),  # [8751]
                (
                    "W/H/Param Inputs",
                    "Set fixed size (Click canvas to place)",
                ),  # [8752]
                (
                    "Clear ('C') Button",
                    "Reset fixed size parameters for adjacent tool to 0",
                ),  # [8753]
            ],  # [8754]
            "MPoint Controls": [  # [8755]
                ("Radio (O)", "Select Circle Marker Style (Alt+O to toggle)"),  # [8756]
                (
                    "Checkbox (Sq)",
                    "Select Square Marker Style (Alt+S to toggle)",
                ),  # [8757]
                ("Size Spinbox (Sz)", "Set Marker Size"),  # [8758]
                ("Checkbox (txt)", "Enable/Disable Labels (T=Toggle)"),  # [8759]
                ("Button (T)", "Configure MPoint Label Text Style"),  # [8760]
                ("Dropdown (Up/Down...)", "Set Label Position"),  # [8761]
                ("Text Field ('1')", "Set Starting Label"),  # [8762]
            ],  # [8763]
            "Angle Tool Controls": [  # [8764]
                ("Button (Color)", "Set Line & Default Text Color"),  # [8765]
                ("Button (T)", "Configure Angle Text Style"),  # [8766]
                ("Checkbox (IN)", "Show Inner Angle (I=Toggle)"),  # [8767]
                ("Checkbox (OUT)", "Show Outer Angle (O=Toggle)"),  # [8768]
            ],  # [8769]
            "Hatch Fill Shortcuts": [  # [8770]
                ("Slash (/)", "Toggle Forward Slash Hatch"),  # [8771]
                ("Backslash (\\)", "Toggle Backward Slash Hatch"),  # [8772]
                ("Bar (|)", "Toggle Vertical Hatch"),  # [8773]
                (
                    "Shift + Minus (-)",
                    "Toggle Horizontal Hatch (Emulates Underscore)",
                ),  # [8774]
            ],  # [8775]
            "Quick Parameter Input": [  # [8776]
                ("Shift + PageUp/Down", "Adjust Transparency (%)"),  # [8777]
                ("Ctrl + PageUp/Down", "Adjust Arrow Head Size"),  # [8778]
                ("Alt + PageUp/Down", "Adjust Brush Size"),  # [8779]
                ("Ctrl+Shift + PageUp/Down", "Cycle Line Style"),  # [8780]
            ],  # [8781]
            "Color Shortcuts (DRAW/TEMP Mode - Press key)": [  # [8782]
                (
                    "0-9",
                    "Apply Color (Selected or Current Pen / Dim Preview)",
                ),  # [8783]
                ("(See tooltips/docs for color mapping)", ""),  # [8784]
            ],  # [8785]
            "BOARD/EDIT Mode Only": [  # [8786]
                (
                    "0-9",
                    "Apply Color (Selected Shape(s) or Current Edit/Board Pen)",
                ),  # [8787]
                (
                    "Alt + 0-9",
                    "Change BOARD Background Color (RGB, preserves Alpha)",
                ),  # [8788]
                (
                    "Ctrl + 0-9",
                    "Change BOARD Background Transparency (0=Min Alpha(1), 9=Opaque)",
                ),  # [8789]
                ("(See tooltips/docs for color mapping)", ""),  # [8790]
            ],  # [8791]
            "Shape Property Shortcuts": [  # [8792]
                (
                    "RAlt + Numpad 0-9",
                    "Set Alpha for Selected Shape(s) (0=0%, 9=100%)",
                ),  # [8793]
                (
                    "Numpad +/- (no selection)",
                    "Change Line Thickness (+/- 1px)",
                ),  # [8794]
            ],  # [8795]
            "Guide Lines Module Specific": [  # [8796]
                ("Alt+Shift+PageUp", "Change Lines Position"),  # [8797]
                ("Ctrl+Alt+F9", "Clear All Lines"),  # [8798]
                ("Ctrl+Alt+PageUp", "Increase Line Thickness"),  # [8799]
                ("Ctrl+Alt+PageDown", "Decrease Line Thickness"),  # [8800]
            ],  # [8801]
            "Grid Module Specific": [  # [8802]
                (
                    "Ctrl+Alt+F10",
                    "Toggle Grid Visibility (also main shortcut)",
                ),  # [8803]
                ("Ctrl+Alt+Up", "Increase Columns (Sections Mode)"),  # [8804]
                ("Ctrl+Alt+Down", "Decrease Columns (Sections Mode)"),  # [8805]
                ("Ctrl+Alt+Right", "Increase Rows (Sections Mode)"),  # [8806]
                ("Ctrl+Alt+Left", "Decrease Rows (Sections Mode)"),  # [8807]
                ("Ctrl+Alt+.", "Decrease X Offset"),  # [8808]
                ("Ctrl+Alt+,", "Increase X Offset"),  # [8809]
                ("Ctrl+Alt+[", "Decrease Y Offset"),  # [8810]
                ("Ctrl+Alt+]", "Increase Y Offset"),  # [8811]
                ("Ctrl+Alt+F11", "Reset Grid Offset to 0,0"),  # [8812]
                ("Ctrl+Alt+F12", "Toggle Grid Dots"),  # [8813]
            ],  # [8814]
        }  # [8815]
        self.table_widget = QTableWidget()
        self.table_widget.setColumnCount(2)
        self.table_widget.setHorizontalHeaderLabels(
            ["Shortcut", "Description"]
        )  # [8816]
        self.table_widget.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table_widget.setSelectionBehavior(
            QTableWidget.SelectionBehavior.SelectRows
        )
        self.table_widget.setSelectionMode(
            QTableWidget.SelectionMode.SingleSelection
        )  # [8817]
        self.table_widget.verticalHeader().setVisible(False)
        self.table_widget.setShowGrid(True)
        self.table_widget.setAlternatingRowColors(True)  # [8818]
        self.table_widget.setStyleSheet(
            "QTableWidget { gridline-color: #888888; outline: 1px solid #666666; border: 1px solid #a0a0a0; } QTableWidget::item { padding: 4px; border-bottom: 1px solid #c0c0c0; border-right: 1px solid #c0c0c0; } QTableWidget QHeaderView::section { background-color: #e0e0e0; padding: 4px; border: 1px solid #b0b0b0; border-bottom: 2px solid #909090; } QTableWidget::item:hover { background-color: #e8f0fe; }"
        )  # [8819]
        row = 0  # [8820]
        for section, shortcuts in self.shortcuts_data.items():  # [8821]
            if not shortcuts:
                continue  # [8822]
            section_item = QTableWidgetItem(f"--- {section} ---")
            section_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            f = section_item.font()
            f.setBold(True)
            section_item.setFont(f)
            section_item.setBackground(QColor("#f0f0f0"))  # [8823]
            self.table_widget.insertRow(row)
            self.table_widget.setItem(row, 0, section_item)
            self.table_widget.setSpan(row, 0, 1, 2)
            row += 1  # [8824]
            for key, desc in shortcuts:  # [8825]
                self.table_widget.insertRow(row)
                key_item = QTableWidgetItem(key)
                desc_item = QTableWidgetItem(desc)
                f = key_item.font()
                f.setBold(True)
                key_item.setFont(f)  # [8826]
                self.table_widget.setItem(row, 0, key_item)
                self.table_widget.setItem(row, 1, desc_item)
                row += 1  # [8827]
            if (
                section != list(k for k, v in self.shortcuts_data.items() if v)[-1]
            ):  # [8828]
                self.table_widget.insertRow(row)
                self.table_widget.setSpan(row, 0, 1, 2)
                self.table_widget.setRowHeight(row, 1)  # [8829]
                spacer_item = QTableWidgetItem("")
                spacer_item.setBackground(self.palette().color(QPalette.ColorRole.Base))
                self.table_widget.setItem(row, 0, spacer_item)
                row += 1  # [8830]
        self.table_widget.resizeColumnsToContents()
        self.table_widget.horizontalHeader().setSectionResizeMode(
            1, QHeaderView.ResizeMode.Stretch
        )  # [8831]
        scrollbar_width = (
            self.table_widget.verticalScrollBar().sizeHint().width()
            if self.table_widget.verticalScrollBar().isVisible()
            else 0
        )  # [8832]
        width_hint = (
            self.table_widget.horizontalHeader().length()
            + self.table_widget.verticalHeader().width()
            + self.table_widget.frameWidth() * 2
            + scrollbar_width
            + 15
        )  # [8833]
        self.setMinimumWidth(max(550, width_hint))
        layout.addWidget(self.table_widget)  # [8834]
        button_layout = QHBoxLayout()
        export_button = QPushButton("Export to File")
        export_button.setSizePolicy(
            QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )
        export_button.clicked.connect(self.export_shortcuts)
        button_layout.addWidget(export_button)  # [8835]
        print_button = QPushButton("Print")
        print_button.setSizePolicy(
            QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed
        )  # [8836]
        if not _QT_PRINT_SUPPORT_AVAILABLE:
            print_button.setEnabled(False)
            print_button.setToolTip("Printing requires QtPrintSupport")  # [8837]
        else:
            print_button.clicked.connect(self.print_shortcuts)  # [8838]
        button_layout.addWidget(print_button)
        button_layout.addStretch()
        close_button = QPushButton("Close")
        close_button.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Fixed)
        close_button.clicked.connect(self.close)
        button_layout.addWidget(close_button)
        layout.addLayout(button_layout)  # [8839]

    def reset_and_center(self):  # [8840]
        try:  # [8841]
            screen_geo = QGuiApplication.primaryScreen().availableGeometry()
            max_height = screen_geo.height() - 40  # [8842]
            target_width = self.minimumWidth()
            self.resize(target_width, max_height)  # [8843]
            x = screen_geo.left() + (screen_geo.width() - target_width) // 2
            y = screen_geo.top() + (screen_geo.height() - max_height) // 2  # [8844]
            self.move(max(screen_geo.left(), x), max(screen_geo.top(), y))
            print(
                f"Shortcuts window reset to max height ({max_height}px) and centered."
            )  # [8845]
        except Exception as e:
            print(f"Error resetting/centering shortcuts window: {e}")
            self.resize(600, 800)  # [8846]

    def restore_geometry_from_settings(self):  # [8847]
        if self.settings:  # [8848]
            geom_bytes = self.settings.value("shortcutsWindow/geometry")  # [8849]
            if geom_bytes and isinstance(geom_bytes, (bytes, bytearray)):  # [8850]
                if self.restoreGeometry(geom_bytes):  # [8851]
                    if (
                        not QGuiApplication.primaryScreen()
                        .availableGeometry()
                        .intersects(self.geometry().adjusted(-5, -5, 5, 5))
                    ):
                        return False  # [8852]
                    return True  # [8853]
        return False  # [8854]

    def save_geometry_to_settings(self):  # [8855]
        if self.settings and not self.isMinimized():
            self.settings.setValue(
                "shortcutsWindow/geometry", self.saveGeometry()
            )  # [8856]

    def closeEvent(self, event):
        self.save_geometry_to_settings()
        super().closeEvent(event)  # [8857]

    def get_shortcuts_html(self):  # [8858]
        html = """<!DOCTYPE html><html><head><style>table { border-collapse: collapse; width: 100%; font-family: sans-serif; font-size: 10pt; border: 1px solid #666; } th, td { border: 1px solid #a0a0a0; padding: 4px; text-align: left; vertical-align: top; } th { background-color: #e0e0e0; font-weight: bold; border-bottom: 2px solid #666; } .section-header td { font-weight: bold; text-align: center; background-color: #f0f0f0; border-top: 2px solid #666; border-bottom: 1px solid #aaa; } .shortcut-key { font-weight: bold; }</style></head><body><h2>Keyboard Shortcuts</h2><table><thead><tr><th>Shortcut</th><th>Description</th></tr></thead><tbody>"""  # [8859]
        first_section = True  # [8860]
        for section, shortcuts in self.shortcuts_data.items():  # [8861]
            if not shortcuts:
                continue  # [8862]
            style_attr = "" if first_section else ' style="border-top: 2px solid #666;"'
            html += f'<tr class="section-header"><td colspan="2"{style_attr}>--- {section} ---</td></tr>\n'
            first_section = False  # [8863]
            for key, desc in shortcuts:
                html += f'<tr><td class="shortcut-key">{key}</td><td>{desc}</td></tr>\n'  # [8864]
        html += "</tbody></table></body></html>"
        return html  # [8865]

    def get_shortcuts_text(self):  # [8866]
        lines = []  # [8867]
        for section, shortcuts in self.shortcuts_data.items():  # [8868]
            if not shortcuts:
                continue  # [8869]
            lines.append(f"--- {section} ---")
            lines.append("")
            [lines.append(f"{key:<30}: {desc}") for key, desc in shortcuts]
            lines.append("-" * 40)
            lines.append("")  # [8870]
        return "\n".join(lines)  # [8871]

    @Slot()  # [8872]
    def export_shortcuts(self):  # [8873]
        text_content = self.get_shortcuts_text()
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export Shortcuts As", "", "Text Files (*.txt)"
        )  # [8874]
        if filename:  # [8875]
            try:  # [8876]
                with open(filename, "w", encoding="utf-8") as f:
                    f.write(text_content)
                    print(f"Shortcuts exported to {filename}")  # [8877]
            except IOError as e:
                QMessageBox.warning(
                    self, "Export Error", f"Could not save file:\n{e}"
                )  # [8878]

    @Slot()  # [8879]
    def print_shortcuts(self):  # [8880]
        if not _QT_PRINT_SUPPORT_AVAILABLE:
            QMessageBox.warning(
                self, "Printing Unavailable", "QtPrintSupport not found."
            )
            return  # [8881]
        html_content = self.get_shortcuts_html()
        doc = QTextDocument()
        doc.setHtml(html_content)  # [8882]
        printer = QPrinter(QPrinter.PrinterMode.HighResolution)
        dialog = QPrintDialog(printer, self)
        dialog.setWindowTitle("Print Shortcuts")  # [8883]
        if dialog.exec() == QDialog.DialogCode.Accepted:  # [8884]
            try:  # [8885]
                doc.print_(printer)
                print("Shortcuts sent to printer.")  # [8886]
            except Exception as e:  # [8887]
                QMessageBox.warning(
                    self, "Print Error", f"Could not print:\n{e}"
                )  # [8888]
        else:  # [8889]
            print("Printing cancelled.")  # [8890]


class MainApplication(QApplication):  # [8891]
    def __init__(self, args):  # [8892]
        super().__init__(args)  # [8893]
        self.setOrganizationName("MyCompany")
        self.setApplicationName("DesktopOverlayRGN_Integrated")  # [8894]
        self._is_exiting = False  # NEW ATTRIBUTE

        self.overlay = DesktopOverlayRgn()  # First create overlay
        self.overlay.main_app_parent = self  # Set reference for overlay

        self.control_panel = ControlPanel(
            self.overlay
        )  # Then create control_panel, passing overlay
        self.control_panel.main_app_parent = (
            self  # Only now set reference for control_panel
        )

        self.overlay.defaults_changed.connect(
            self.control_panel.update_controls_from_defaults
        )  # [8895]
        self.control_panel.show()  # [8896]
        self._is_animation_active = False  # [8897]
        self.hotkey_filter = GlobalHotkeyFilter(
            lambda hotkey_id: self.handle_global_hotkey(hotkey_id)
        )  # [8898]
        self.installNativeEventFilter(self.hotkey_filter)  # [8899]

        # Initialize Lines App # [8900]
        global lines_app_instance  # [8901]
        lines_app_instance = AplikacjaLiniiPomocniczych(self)  # [8902]
        lines_app_instance.lines_visibility_changed_signal.connect(
            self.control_panel.update_lines_toggle_checkbox_state
        )  # [8903]

        # Initialize Grid Overlay and Settings # [8904]
        global grid_overlay_instance, grid_settings_window_instance  # [8905]
        grid_overlay_instance = GridOverlay()  # [8906]
        grid_settings_window_instance = GridSettingsWindow(
            grid_overlay_instance
        )  # [8907]
        grid_settings_window_instance.grid_visibility_changed_signal.connect(
            self.control_panel.update_grid_toggle_checkbox_state
        )  # [8908]
        grid_overlay_instance.setVisible(grid_overlay_instance.visible)  # [8909]
        if grid_overlay_instance.visible:
            grid_overlay_instance.show()  # [8910]
        self.aboutToQuit.connect(self.cleanup_resources)  # Connect signal

    def set_animation_active_status(self, is_active):  # [8911]
        self._is_animation_active = is_active
        print(f"MainApplication: Animation status set to {is_active}")  # [8912]

    def cleanup_resources(self):
        print(
            "MainApplication: Starting cleanup_resources (triggered by aboutToQuit)..."
        )
        # Stop animation if active
        if (
            hasattr(self, "control_panel")
            and self.control_panel
            and hasattr(self.control_panel, "_animation_running")
            and self.control_panel._animation_running
        ):
            print("MainApplication: Stopping animation on exit.")
            self.control_panel.stop_animation_playback(
                triggered_by_escape=False
            )  # Don't want it to clear scene if exiting

        # Save settings if exit was not initiated by _exit_application
        if not self._is_exiting:
            print(
                "MainApplication: Saving settings during cleanup (exit not from _exit_application)."
            )
            if (
                hasattr(self, "overlay")
                and self.overlay
                and hasattr(self.overlay, "save_all_settings")
            ):
                self.overlay.save_all_settings()
            if (
                hasattr(self, "control_panel")
                and self.control_panel
                and hasattr(self.control_panel, "save_settings")
            ):
                self.control_panel.save_settings()
            global lines_app_instance
            if lines_app_instance and hasattr(lines_app_instance, "zapisz_stan"):
                lines_app_instance.zapisz_stan()
            global grid_settings_window_instance
            if grid_settings_window_instance and hasattr(
                grid_settings_window_instance, "saveSettings"
            ):
                grid_settings_window_instance.saveSettings()

        # Remove global event filter
        if hasattr(self, "hotkey_filter") and self.hotkey_filter:
            print("MainApplication: Removing native event filter...")
            self.removeNativeEventFilter(self.hotkey_filter)
            self.hotkey_filter = None

        # Close dialog windows that might be open by ControlPanel
        if hasattr(self, "control_panel") and self.control_panel:
            print(
                "MainApplication: Closing ControlPanel's child windows (shortcuts, info, anim_config)..."
            )
            self.control_panel.close_all_child_windows_if_any()

        # Lines
        global lines_settings_dialog_instance  # Already declared global
        if lines_settings_dialog_instance:
            if lines_settings_dialog_instance.isVisible():
                print("MainApplication: Closing Lines settings dialog...")
                lines_settings_dialog_instance.setAttribute(
                    Qt.WidgetAttribute.WA_DeleteOnClose, True
                )
                lines_settings_dialog_instance.close()
            lines_settings_dialog_instance = None

        if lines_app_instance:  # Check if lines_app_instance still exists
            print("MainApplication: Shutting down Lines app logic and UI...")
            lines_app_instance.zamknij_aplikacje_lines()
            # lines_app_instance = None # Intentionally not nullifying here, _exit_application might still need it

        # Grid
        global grid_overlay_instance  # Already declared global
        if (
            grid_settings_window_instance
        ):  # Check if grid_settings_window_instance still exists
            print("MainApplication: Closing Grid settings window...")
            # grid_settings_window_instance.saveSettings() # Already saved if _is_exiting is False
            grid_settings_window_instance.setAttribute(
                Qt.WidgetAttribute.WA_DeleteOnClose, True
            )
            grid_settings_window_instance.close()
            grid_settings_window_instance = None

        if grid_overlay_instance:  # Check if grid_overlay_instance still exists
            print("MainApplication: Closing Grid overlay...")
            grid_overlay_instance.setAttribute(
                Qt.WidgetAttribute.WA_DeleteOnClose, True
            )
            grid_overlay_instance.hide()
            grid_overlay_instance.close()
            grid_overlay_instance = None

        # Main application windows - their closing is managed by Qt after self.quit()
        # (called in _exit_application)
        # Ensure they are marked for deletion and closed
        # so their closeEvents can execute correctly.
        if hasattr(self, "control_panel") and self.control_panel:
            print(
                "MainApplication: Ensuring ControlPanel is marked for deletion and closed..."
            )
            self.control_panel.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
            self.control_panel.close()  # Call panel's closeEvent
            self.control_panel = None  # Prevent double closing

        if hasattr(self, "overlay") and self.overlay:
            print(
                "MainApplication: Ensuring Overlay is marked for deletion and closed..."
            )
            self.overlay.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)
            self.overlay.close()  # closeEvent in overlay will handle hotkey unregister
            self.overlay = None  # Prevent double closing

        print("MainApplication: Processing events to ensure windows close...")
        self.processEvents()  # Give Qt a chance to process close events
        self.processEvents()  # Sometimes one is not enough

        print("MainApplication: cleanup_resources finished.")

    def _exit_application(self):
        """
        Saves settings, tries to terminate py.exe processes, and quits the application.
        """
        if self._is_exiting:
            print("MainApplication: Already in exit process.")
            return
        self._is_exiting = True
        print("MainApplication: Starting application exit process...")

        # 1. Save all settings
        print("MainApplication: Saving all settings...")
        if (
            hasattr(self, "overlay")
            and self.overlay
            and hasattr(self.overlay, "save_all_settings")
        ):
            self.overlay.save_all_settings()
        if (
            hasattr(self, "control_panel")
            and self.control_panel
            and hasattr(self.control_panel, "save_settings")
        ):
            self.control_panel.save_settings()

        global lines_app_instance
        if lines_app_instance and hasattr(lines_app_instance, "zapisz_stan"):
            lines_app_instance.zapisz_stan()

        global grid_settings_window_instance
        if grid_settings_window_instance and hasattr(
            grid_settings_window_instance, "saveSettings"
        ):
            grid_settings_window_instance.saveSettings()

        print("MainApplication: All settings presumably saved.")

        # 2. Terminate py.exe processes (optional, Windows only)
        if _IS_WINDOWS and _PSUTIL_AVAILABLE:
            print("MainApplication: Attempting to kill py.exe processes...")
            try:
                find_me = "py.exe"
                killed_count = 0
                current_pid = os.getpid()
                for proc in psutil.process_iter(["pid", "name"]):
                    try:
                        if (
                            proc.info["name"].lower() == find_me
                            and proc.info["pid"] != current_pid
                        ):
                            p = psutil.Process(proc.info["pid"])
                            p.kill()
                            killed_count += 1
                            print(
                                f"Killed process {proc.info['pid']} ({proc.info['name']})"
                            )
                    except psutil.NoSuchProcess:
                        # print(f"Process {proc.info['pid']} ({proc.info['name']}) no longer exists.")
                        pass  # Might already be killed by another instance
                    except psutil.AccessDenied:
                        print(
                            f"Access denied to kill process {proc.info['pid']} ({proc.info['name']})."
                        )
                    except Exception as e_kill:
                        print(
                            f"Error killing process {proc.info['pid']} ({proc.info['name']}): {e_kill}"
                        )
                if killed_count > 0:
                    print(f"MainApplication: Killed {killed_count} py.exe process(es).")
                else:
                    print(
                        "MainApplication: No other py.exe processes found to kill or all were skipped/failed."
                    )
            except Exception as e_psutil:
                print(
                    f"MainApplication: Error iterating or killing processes with psutil: {e_psutil}"
                )
        elif _IS_WINDOWS and not _PSUTIL_AVAILABLE:
            print(
                "MainApplication: psutil not available, skipping py.exe process kill."
            )

        # 3. Call quit() for the Qt application
        # This will trigger aboutToQuit -> cleanup_resources
        print("MainApplication: Quitting application event loop...")
        self.quit()

    @Slot(int)  # [8913]
    def handle_global_hotkey(self, hotkey_id):  # [8914]
        is_anim_active = (
            self.control_panel._animation_running if self.control_panel else False
        )  # [8915]
        if is_anim_active:  # [8916]
            print(f"Ignoring global hotkey {hotkey_id} during animation.")  # [8917]
            return  # [8918]
        if hotkey_id == HOTKEY_ID_DRAW:  # [8919]
            print("Global Hotkey Ctrl+\\ triggered → toggling drawing mode")  # [8920]
            self.overlay.set_drawing_mode(
                not self.overlay.drawing_mode, called_from_hotkey=True
            )  # [8921]
        elif hotkey_id == HOTKEY_ID_EDIT:  # [8922]
            print(
                "Global Hotkey Ctrl+Alt+\\ (RAlt+\\) triggered → entering EDIT mode"
            )  # [8923]
            self.overlay.enter_edit_mode()  # [8924]
        elif hotkey_id == HOTKEY_ID_BOARD:  # [8925]
            print("Global Hotkey Alt+\\ triggered → entering BOARD mode")  # [8926]
            self.overlay.enter_board_mode()  # [8927]
        elif hotkey_id == HOTKEY_ID_TEMP:  # [8928]
            print("Global Hotkey Alt+Shift+\\ triggered → entering TEMP mode")  # [8929]
            self.overlay.enter_temp_mode()  # [8930]
        elif hotkey_id == HOTKEY_ID_SHIFT_PRINTSCREEN:  # [8931]
            print(
                "Global Hotkey Shift+PrintScreen triggered → capturing screenshot"
            )  # [8932]
            self.overlay.capture_screenshot()  # [8933]
        # Lines Hotkeys # [8934]
        elif hotkey_id == HOTKEY_ID_LINES_TOGGLE:  # [8935]
            print(
                "Global Hotkey Alt+Shift+Home triggered → toggling Lines visibility"
            )  # [8936]
            if lines_app_instance:  # [8937]
                new_state = lines_app_instance.toggle_lines_visibility()  # [8938]
                self.control_panel.update_lines_toggle_checkbox_state(
                    new_state
                )  # [8939]
        elif hotkey_id == HOTKEY_ID_LINES_POS:  # [8940]
            print(
                "Global Hotkey Alt+Shift+PageUp triggered → changing Lines position"
            )  # [8941]
            if lines_app_instance:
                lines_app_instance.zmien_pozycje_linijek_cyklicznie()  # [8942]
        elif hotkey_id == HOTKEY_ID_LINES_CLEAR:  # [8943]
            print("Global Hotkey Ctrl+Alt+F9 triggered → clearing all Lines")  # [8944]
            if lines_app_instance:
                lines_app_instance.wyczysc_wszystkie_linie()  # [8945]
        elif hotkey_id == HOTKEY_ID_LINES_INC_THICK:  # [8946]
            print(
                "Global Hotkey Ctrl+Alt+PageUp triggered → increasing Lines thickness"
            )  # [8947]
            if lines_app_instance:
                lines_app_instance.slot_zwieksz_grubosc_lines()  # [8948]
        elif hotkey_id == HOTKEY_ID_LINES_DEC_THICK:  # [8949]
            print(
                "Global Hotkey Ctrl+Alt+PageDown triggered → decreasing Lines thickness"
            )  # [8950]
            if lines_app_instance:
                lines_app_instance.slot_zmniejsz_grubosc_lines()  # [8951]
        # Grid Hotkeys # [8952]
        elif hotkey_id == HOTKEY_ID_GRID_TOGGLE:  # [8953]
            print(
                "Global Hotkey Ctrl+Alt+F10 triggered → toggling Grid visibility"
            )  # [8954]
            if grid_settings_window_instance and grid_overlay_instance:  # [8955]
                current_state_val = (
                    Qt.CheckState.Checked.value
                    if grid_overlay_instance.isVisible()
                    else Qt.CheckState.Unchecked.value
                )  # [8956]
                grid_settings_window_instance.toggleGrid(
                    Qt.CheckState.Unchecked.value
                    if current_state_val == Qt.CheckState.Checked.value
                    else Qt.CheckState.Checked.value
                )  # [8957]
        elif hotkey_id == HOTKEY_ID_GRID_INC_COLS:  # [8958]
            if (
                grid_settings_window_instance
                and grid_overlay_instance.grid_mode == GridOverlay.MODE_SECTIONS
            ):  # [8959]
                new_val = grid_overlay_instance.vertical_sections + 1  # [8960]
                print(grid_tr("shortcut_inc_cols", new_val=new_val))  # [8961]
                grid_settings_window_instance.updateVerticalSectionsValue(
                    new_val
                )  # [8962]
            elif grid_overlay_instance:
                print(grid_tr("shortcut_ignored_mode"))  # [8963]
        elif hotkey_id == HOTKEY_ID_GRID_DEC_COLS:  # [8964]
            if (
                grid_settings_window_instance
                and grid_overlay_instance.grid_mode == GridOverlay.MODE_SECTIONS
            ):  # [8965]
                new_val = max(1, grid_overlay_instance.vertical_sections - 1)  # [8966]
                print(grid_tr("shortcut_dec_cols", new_val=new_val))  # [8967]
                grid_settings_window_instance.updateVerticalSectionsValue(
                    new_val
                )  # [8968]
            elif grid_overlay_instance:
                print(grid_tr("shortcut_ignored_mode"))  # [8969]
        elif hotkey_id == HOTKEY_ID_GRID_INC_ROWS:  # [8970]
            if (
                grid_settings_window_instance
                and grid_overlay_instance.grid_mode == GridOverlay.MODE_SECTIONS
            ):  # [8971]
                new_val = grid_overlay_instance.horizontal_sections + 1  # [8972]
                print(grid_tr("shortcut_inc_rows", new_val=new_val))  # [8973]
                grid_settings_window_instance.updateHorizontalSectionsValue(
                    new_val
                )  # [8974]
            elif grid_overlay_instance:
                print(grid_tr("shortcut_ignored_mode"))  # [8975]
        elif hotkey_id == HOTKEY_ID_GRID_DEC_ROWS:  # [8976]
            if (
                grid_settings_window_instance
                and grid_overlay_instance.grid_mode == GridOverlay.MODE_SECTIONS
            ):  # [8977]
                new_val = max(
                    1, grid_overlay_instance.horizontal_sections - 1
                )  # [8978]
                print(grid_tr("shortcut_dec_rows", new_val=new_val))  # [8979]
                grid_settings_window_instance.updateHorizontalSectionsValue(
                    new_val
                )  # [8980]
            elif grid_overlay_instance:
                print(grid_tr("shortcut_ignored_mode"))  # [8981]
        elif hotkey_id == HOTKEY_ID_GRID_DEC_X_OFFSET:  # [8982]
            if grid_settings_window_instance:  # [8983]
                new_val = grid_overlay_instance.offset_x - 1  # [8984]
                print(grid_tr("shortcut_dec_x", new_val=new_val))  # [8985]
                grid_settings_window_instance.updateOffsetXValue(new_val)  # [8986]
        elif hotkey_id == HOTKEY_ID_GRID_INC_X_OFFSET:  # [8987]
            if grid_settings_window_instance:  # [8988]
                new_val = grid_overlay_instance.offset_x + 1  # [8989]
                print(grid_tr("shortcut_inc_x", new_val=new_val))  # [8990]
                grid_settings_window_instance.updateOffsetXValue(new_val)  # [8991]
        elif hotkey_id == HOTKEY_ID_GRID_DEC_Y_OFFSET:  # [8992]
            if grid_settings_window_instance:  # [8993]
                new_val = grid_overlay_instance.offset_y - 1  # [8994]
                print(grid_tr("shortcut_dec_y", new_val=new_val))  # [8995]
                grid_settings_window_instance.updateOffsetYValue(new_val)  # [8996]
        elif hotkey_id == HOTKEY_ID_GRID_INC_Y_OFFSET:  # [8997]
            if grid_settings_window_instance:  # [8998]
                new_val = grid_overlay_instance.offset_y + 1  # [8999]
                print(grid_tr("shortcut_inc_y", new_val=new_val))  # [9000]
                grid_settings_window_instance.updateOffsetYValue(new_val)  # [9001]
        elif hotkey_id == HOTKEY_ID_GRID_RESET_OFFSET:  # [9002]
            if grid_settings_window_instance:  # [9003]
                print(grid_tr("shortcut_reset_offset"))  # [9004]
                grid_settings_window_instance.resetOffsets()  # [9005]
        elif hotkey_id == HOTKEY_ID_GRID_TOGGLE_DOTS:  # [9006]
            if grid_settings_window_instance:  # [9007]
                current_state = (
                    grid_settings_window_instance.dots_checkbox.isChecked()
                )  # [9008]
                new_state = not current_state  # [9009]
                state_key = "show_dots_checkbox" if new_state else "hide_dots"  # [9010]
                print(
                    grid_tr("shortcut_toggle_dots", state=grid_tr(state_key))
                )  # [9011]
                grid_settings_window_instance.dots_checkbox.setChecked(
                    new_state
                )  # [9012]
        # Snap Hotkeys # [9013]
        elif hotkey_id == HOTKEY_ID_SNAP_LINES:  # [9014]
            print(
                "Global Hotkey Alt+Shift+F1 triggered → toggling Snap to Lines"
            )  # [9015]
            if self.control_panel:
                self.control_panel.snap_to_lines_checkbox.toggle()  # [9016]
        elif hotkey_id == HOTKEY_ID_SNAP_GRID:  # [9017]
            print(
                "Global Hotkey Alt+Shift+F2 triggered → toggling Snap to Grid"
            )  # [9018]
            if self.control_panel:
                self.control_panel.snap_to_grid_checkbox.toggle()  # [9019]
        elif hotkey_id == HOTKEY_ID_SNAP_ALL:  # [9020]
            print(
                "Global Hotkey Alt+Shift+F3 triggered → toggling Snap to All"
            )  # [9021]
            if self.control_panel:
                self.control_panel.snap_to_all_checkbox.toggle()  # [9022]
        elif hotkey_id == HOTKEY_ID_SNAP_OFF:  # New handling # [9023]
            print("Global Hotkey Alt+Shift+F4 triggered → turning Snap OFF")  # [9024]
            if self.control_panel:
                self.control_panel.snap_off_radio.setChecked(True)  # [9025]
        else:  # [9026]
            print(f"Unhandled hotkey ID: {hotkey_id}")  # [9027]

    def exec(self):
        print("Starting application event loop...")
        result = super().exec()
        # cleanup_resources is now called by aboutToQuit, so no need to call it explicitly here.
        # self.cleanup_resources() # Removed to avoid double call
        print(f"Application event loop finished with result code: {result}")
        return result


if __name__ == "__main__":  # [9028]
    if hasattr(Qt, "AA_EnableHighDpiScaling"):
        QApplication.setAttribute(
            Qt.ApplicationAttribute.AA_EnableHighDpiScaling, True
        )  # [9029]
    if hasattr(Qt, "AA_UseHighDpiPixmaps"):
        QApplication.setAttribute(
            Qt.ApplicationAttribute.AA_UseHighDpiPixmaps, True
        )  # [9030]
    if hasattr(Qt, "HighDpiScaleFactorRoundingPolicy") and hasattr(
        QApplication, "setHighDpiScaleFactorRoundingPolicy"
    ):  # [9031]
        try:  # [9032]
            QApplication.setHighDpiScaleFactorRoundingPolicy(
                Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
            )  # [9033]
            print("Set HighDpiScaleFactorRoundingPolicy to PassThrough")  # [9034]
        except AttributeError:  # [9035]
            print(
                "Warning: Could not set HighDpiScaleFactorRoundingPolicy (might be older Qt version)"
            )  # [9036]
        except Exception as e:  # [9037]
            print(
                f"Warning: Error setting HighDpiScaleFactorRoundingPolicy: {e}"
            )  # [9038]
    app = MainApplication(sys.argv)  # [9039]

    # Start UI for Lines and Grid after MainApplication and its widgets are created
    # This UI initialization is important for widgets to be shown correctly
    if lines_app_instance:
        lines_app_instance.uruchom_lines_ui()
    if grid_overlay_instance:
        # grid_overlay_instance visibility is already set in its constructor and loadSettings
        # grid_overlay_instance.setVisible(grid_overlay_instance.visible)
        if grid_overlay_instance.visible:
            grid_overlay_instance.show()

    if not _GRID_HAS_KEYBOARD_LIB:  # [9040]
        print(f"\n*** {grid_tr('warning_keyboard_lib')} ***\n")  # [9041]

    if sys.platform == "linux":  # [9042]
        if (
            _GRID_HAS_KEYBOARD_LIB and hasattr(os, "geteuid") and os.geteuid() != 0
        ):  # [9043]
            print(f"\n*** {grid_tr('info_linux_sudo')} ***\n")  # [9044]
    elif sys.platform == "win32":  # [9045]
        print(f"\n*** {grid_tr('info_qtwin_removed')} ***\n")  # [9046]

    exit_code = app.exec()  # [9047] # Changed to .exec()
    print(
        f"Main application exited cleanly with code: {exit_code}"
    )  # [9048] # Corrected message
    sys.exit(exit_code)  # [9049]
